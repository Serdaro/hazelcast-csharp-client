<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Clustering\ClusterState.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Hazelcast.Core;
using Hazelcast.Exceptions;
using Hazelcast.Networking;
using Hazelcast.Partitioning;
using Microsoft.Extensions.Logging;

namespace Hazelcast.Clustering
{
    /// &lt;summary&gt;
    /// Represents the state of the cluster.
    /// &lt;/summary&gt;
    internal class ClusterState : IAsyncDisposable
    {
        private readonly CancellationTokenSource _clusterCancellation = new CancellationTokenSource(); // general kill switch
        private readonly object _mutex = new object();
        private readonly StateChangeQueue _stateChangeQueue;

        private Action _shutdownRequested;
        private volatile bool _readonlyProperties;

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;ClusterState&quot;/&gt; class.
        /// &lt;/summary&gt;
        public ClusterState(IClusterOptions options, string clusterName, string clientName, Partitioner partitioner, ILoggerFactory loggerFactory)
        {
            Options = options;
            ClusterName = clusterName;
            ClientName = clientName;
            Partitioner = partitioner;
            LoggerFactory = loggerFactory;

            AddressProvider = new AddressProvider(AddressProvider.GetSource(options.Networking, loggerFactory), LoggerFactory);

            _stateChangeQueue = new StateChangeQueue(loggerFactory);

            HConsole.Configure(x=&gt; x.Configure&lt;ClusterState&gt;().SetPrefix(&quot;CLUST.STATE&quot;));
        }

        #region Events

        /// &lt;summary&gt;
        /// Triggers when the state changes.
        /// &lt;/summary&gt;
        public Func&lt;ClientState, ValueTask&gt; StateChanged
        {
            get =&gt; _stateChangeQueue.StateChanged;
            set
            {
                ThrowIfPropertiesAreReadOnly();
                _stateChangeQueue.StateChanged = value ?? throw new ArgumentNullException(nameof(value));
            }
        }

        /// &lt;summary&gt;
        /// Triggers when shutdown is requested.
        /// &lt;/summary&gt;
        public Action ShutdownRequested
        {
            get =&gt; _shutdownRequested;
            set
            {
                ThrowIfPropertiesAreReadOnly();
                _shutdownRequested = value;
            }
        }

        #endregion

        #region Readonly Properties

        /// &lt;summary&gt;
        /// Throws an &lt;see cref=&quot;InvalidOperationException&quot;/&gt; if properties (On...) are read-only.
        /// &lt;/summary&gt;
        public void ThrowIfPropertiesAreReadOnly()
        {
            if (_readonlyProperties) throw new InvalidOperationException(ExceptionMessages.PropertyIsNowReadOnly);
        }

        /// &lt;summary&gt;
        /// Sets properties (On...) as read-only.
        /// &lt;/summary&gt;
        public void SetPropertiesReadOnly()
        {
            _readonlyProperties = true;
        }

        #endregion

        #region Infos

        /// &lt;summary&gt;
        /// Gets the unique identifier of the cluster, as assigned by the client.
        /// &lt;/summary&gt;
        public Guid ClientId { get; } = Guid.NewGuid();

        /// &lt;summary&gt;
        /// Gets the name of the cluster client, as assigned by the client.
        /// &lt;/summary&gt;
        public string ClientName { get; }

        /// &lt;summary&gt;
        /// Gets the name of the cluster server.
        /// &lt;/summary&gt;
        public string ClusterName { get; }

        #endregion

        #region ClientState

        // NOTE: the initial ClientState is the default value, i.e. zero
        // we don&#39;t make it ClientState.Unknown because we don&#39;t want it
        // to be publicly visible, as this is a purely internal state

        /// &lt;summary&gt;
        /// Gets the client state.
        /// &lt;/summary&gt;
        public ClientState ClientState { get; private set; }

        /// &lt;summary&gt;
        /// Changes the state, and pushes the change to the events queue.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;newState&quot;&gt;The new state.&lt;/param&gt;
        public void ChangeState(ClientState newState)
        {
            lock (_mutex)
            {
                if (ClientState == newState)
                    return;

                ClientState = newState;
                HConsole.WriteLine(this, $&quot;{ClientName} state -&gt; {ClientState}&quot;);
                _stateChangeQueue.Add(newState);
            }
        }

        /// &lt;summary&gt;
        /// Changes the state if it is as expected, and pushes the change to the events queue.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;newState&quot;&gt;The new state.&lt;/param&gt;
        /// &lt;param name=&quot;expectedState&quot;&gt;The expected state.&lt;/param&gt;
        /// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt; if the state was as expected, and thus changed; otherwise &lt;c&gt;false&lt;/c&gt;.&lt;/returns&gt;
        public bool ChangeState(ClientState newState, ClientState expectedState)
        {
            lock (_mutex)
            {
                if (ClientState != expectedState)
                    return false;

                ClientState = newState;
                HConsole.WriteLine(this, $&quot;{ClientName} state -&gt; {ClientState}&quot;);
                _stateChangeQueue.Add(newState);
                return true;
            }
        }

        /// &lt;summary&gt;
        /// Changes the state if it is as expected, and pushes the change to the events queue.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;newState&quot;&gt;The new state.&lt;/param&gt;
        /// &lt;param name=&quot;expectedStates&quot;&gt;The expected states.&lt;/param&gt;
        /// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt; if the state was as expected, and thus changed; otherwise &lt;c&gt;false&lt;/c&gt;.&lt;/returns&gt;
        public bool ChangeState(ClientState newState, params ClientState[] expectedStates)
        {
            lock (_mutex)
            {
                if (!expectedStates.Contains(ClientState))
                    return false;

                ClientState = newState;
                HConsole.WriteLine(this, $&quot;{ClientName} state -&gt; {ClientState}&quot;);
                _stateChangeQueue.Add(newState);
                return true;
            }
        }

        /// &lt;summary&gt;
        /// Changes the state if it is as expected, and pushes the change to the events queue,
        /// then waits for the event to be handled.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;newState&quot;&gt;The new state.&lt;/param&gt;
        /// &lt;returns&gt;A task that will complete when the state change event has been handled.&lt;/returns&gt;
        public async Task ChangeStateAndWait(ClientState newState)
        {
            Task wait;
            lock (_mutex)
            {
                if (ClientState == newState)
                    return;

                ClientState = newState;
                HConsole.WriteLine(this, $&quot;{ClientName} state -&gt; {ClientState}&quot;);
                wait = _stateChangeQueue.AddAndWait(newState);
            }

            await wait.CfAwait();
        }

        /// &lt;summary&gt;
        /// Changes the state if it is as expected, and pushes the change to the events queue,
        /// then waits for the event to be handled.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;newState&quot;&gt;The new state.&lt;/param&gt;
        /// &lt;param name=&quot;expectedState&quot;&gt;The expected state.&lt;/param&gt;
        /// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt; if the state was as expected, and thus changed, and the corresponding
        /// event has been handled; otherwise (not changed) &lt;c&gt;false&lt;/c&gt;.&lt;/returns&gt;
        public async Task&lt;bool&gt; ChangeStateAndWait(ClientState newState, ClientState expectedState)
        {
            Task wait;
            lock (_mutex)
            {
                if (ClientState != expectedState)
                    return false;

                ClientState = newState;
                HConsole.WriteLine(this, $&quot;{ClientName} state -&gt; {ClientState}&quot;);
                wait = _stateChangeQueue.AddAndWait(newState);
            }

            await wait.CfAwait();
            return true;
        }

        /// &lt;summary&gt;
        /// Changes the state if it is as expected, and pushes the change to the events queue,
        /// then waits for the event to be handled.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;newState&quot;&gt;The new state.&lt;/param&gt;
        /// &lt;param name=&quot;expectedStates&quot;&gt;The expected states.&lt;/param&gt;
        /// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt; if the state was as expected, and thus changed, and the corresponding
        /// event has been handled; otherwise (not changed) &lt;c&gt;false&lt;/c&gt;.&lt;/returns&gt;
        public async Task&lt;bool&gt; ChangeStateAndWait(ClientState newState, params ClientState[] expectedStates)
        {
            Task wait;
            lock (_mutex)
            {
                if (!expectedStates.Contains(ClientState))
                    return false;

                ClientState = newState;
                wait = _stateChangeQueue.AddAndWait(newState);
            }

            await wait.CfAwait();
            return true;
        }

        /// &lt;summary&gt;
        /// Waits until connected, or it becomes impossible to connect.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;A cancellation token.&lt;/param&gt;
        /// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt; if connected; otherwise &lt;c&gt;false&lt;/c&gt; meaning it has become impossible to connect.&lt;/returns&gt;
        public ValueTask&lt;bool&gt; WaitForConnectedAsync(CancellationToken cancellationToken)
        {
            lock (_mutex)
            {
                // already connected
                if (ClientState == ClientState.Connected) return new ValueTask&lt;bool&gt;(true);

                // never going to be connected
                if (ClientState != ClientState.Started &amp;&amp; ClientState != ClientState.Disconnected) return new ValueTask&lt;bool&gt;(false);
            }

            return WaitForConnectedAsync2(cancellationToken);
        }

        private async ValueTask&lt;bool&gt; WaitForConnectedAsync2(CancellationToken cancellationToken)
        {
            TaskCompletionSource&lt;ClientState&gt; wait;
            CancellationTokenRegistration reg;

            lock (_mutex)
            {
                // already connected
                if (ClientState == ClientState.Connected) return true;

                // never going to be connected
                if (ClientState != ClientState.Started &amp;&amp; ClientState != ClientState.Disconnected) return false;

                // must wait
                wait = new TaskCompletionSource&lt;ClientState&gt;();
                reg = cancellationToken.Register(() =&gt; wait.TrySetCanceled());
                _stateChangeQueue.StateChanged += x =&gt;
                {
                    // either connected, or never going to be connected
                    if (x != ClientState.Started &amp;&amp; x != ClientState.Disconnected)
                        wait.TrySetResult(x);

                    // keep waiting
                    return default;
                };
            }

            ClientState state;
            try { state  = await wait.Task.CfAwait(); } catch {  state = 0; }

            reg.Dispose();

            return state == ClientState.Connected;
        }

        /// &lt;summary&gt;
        /// Whether the cluster is connected.
        /// &lt;/summary&gt;
        public bool IsConnected =&gt; ClientState == ClientState.Connected;

        /// &lt;summary&gt;
        /// Whether the cluster is active i.e. connected or connecting.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;When the cluster is active it is either connected, or trying to get
        /// connected. It may make sense to retry operations that fail, because they
        /// should succeed when the cluster is eventually connected.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public bool IsActive =&gt; ClientState.IsActiveState();

        /// &lt;summary&gt;
        /// Throws a &lt;see cref=&quot;ClientOfflineException&quot;/&gt; if the cluster is not active.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;innerException&quot;&gt;An optional inner exception.&lt;/param&gt;
        public void ThrowIfNotActive(Exception innerException = null)
        {
            if (!IsActive) throw new ClientOfflineException(innerException, ClientState);
        }

        #endregion

        public Exception ThrowClientOfflineException()
        {
            // due to a race condition between ClusterMembers potentially removing all its connections,
            // and ClusterConnections figuring we are now disconnected and changing the state, the state
            // here could still be ClientState.Connected - fix it.

            var clientState = ClientState;
            if (clientState == ClientState.Connected) clientState = ClientState.Disconnected;
            return new ClientOfflineException(clientState);
        }

        /// &lt;summary&gt;
        /// Requests that the client shuts down.
        /// &lt;/summary&gt;
        public void RequestShutdown()
        {
            _shutdownRequested?.Invoke();
        }

        /// &lt;summary&gt;
        /// Gets the options.
        /// &lt;/summary&gt;
        public IClusterOptions Options { get; }

        /// &lt;summary&gt;
        /// Whether smart routing is enabled.
        /// &lt;/summary&gt;
        public bool IsSmartRouting =&gt; Options.Networking.SmartRouting;

        /// &lt;summary&gt;
        /// Gets the address provider.
        /// &lt;/summary&gt;
        public AddressProvider AddressProvider { get; }

        /// &lt;summary&gt;
        /// Gets the partitioner.
        /// &lt;/summary&gt;
        public Partitioner Partitioner { get; }

        /// &lt;summary&gt;
        /// Gets the logger factory.
        /// &lt;/summary&gt;
        public ILoggerFactory LoggerFactory { get; }

        /// &lt;summary&gt;
        /// Gets the cluster instrumentation.
        /// &lt;/summary&gt;
        public ClusterInstrumentation Instrumentation { get; } = new ClusterInstrumentation();

        /// &lt;summary&gt;
        /// Gets the correlation identifier sequence.
        /// &lt;/summary&gt;
        public ISequence&lt;long&gt; CorrelationIdSequence { get; } = new Int64Sequence();

        /// &lt;summary&gt;
        /// Gets the next correlation identifier.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;The next correlation identifier.&lt;/returns&gt;
        public long GetNextCorrelationId() =&gt; CorrelationIdSequence.GetNext();

        /// &lt;summary&gt;
        /// &lt;inheritdoc /&gt;
        public async ValueTask DisposeAsync()
        {
            await _stateChangeQueue.DisposeAsync().CfAwait();
            _clusterCancellation.Dispose();
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[32,9,32,103,1],[33,9,33,55,1],[42,9,42,147,1],[44,13,44,31,1],[45,13,45,39,1],[46,13,46,37,1],[47,13,47,39,1],[48,13,48,43,1],[50,13,50,128,1],[52,13,52,69,1],[55,9,55,10,1],[64,20,64,50,1],[67,17,67,48,1],[68,17,68,106,1],[69,13,69,14,1],[77,20,77,38,1],[80,17,80,48,1],[81,17,81,44,1],[82,13,82,14,1],[94,13,94,37,1],[94,38,94,115,0],[95,9,95,10,1],[102,13,102,40,1],[103,9,103,10,1],[112,32,112,36,1],[112,41,112,55,1],[117,36,117,40,1],[122,37,122,41,1],[135,42,135,46,1],[135,47,135,59,1],[143,13,143,26,0],[145,17,145,45,0],[146,21,146,28,0],[148,17,148,40,0],[150,17,150,49,0],[151,13,151,14,0],[152,9,152,10,0],[162,13,162,26,1],[164,17,164,50,1],[165,21,165,34,1],[167,17,167,40,1],[169,17,169,49,1],[170,17,170,29,1],[172,9,172,10,1],[182,13,182,26,1],[184,17,184,59,1],[185,21,185,34,0],[187,17,187,40,1],[189,17,189,49,1],[190,17,190,29,1],[192,9,192,10,1],[203,13,203,26,1],[205,17,205,45,1],[206,21,206,28,0],[208,17,208,40,1],[210,17,210,63,1],[211,13,211,14,1],[213,13,213,34,1],[214,9,214,10,1],[227,13,227,26,1],[229,17,229,50,1],[230,21,230,34,0],[232,17,232,40,1],[234,17,234,63,1],[235,13,235,14,1],[237,13,237,34,1],[238,13,238,25,1],[239,9,239,10,1],[252,13,252,26,0],[254,17,254,59,0],[255,21,255,34,0],[257,17,257,40,0],[258,17,258,63,0],[259,13,259,14,0],[261,13,261,34,0],[262,13,262,25,0],[263,9,263,10,0],[272,13,272,26,1],[275,17,275,58,1],[275,59,275,92,1],[278,17,278,99,1],[278,100,278,134,0],[279,13,279,14,1],[281,13,281,62,1],[282,9,282,10,1],[289,13,289,26,1],[292,17,292,58,1],[292,59,292,71,0],[295,17,295,99,1],[295,100,295,113,0],[298,17,298,64,1],[299,17,299,56,1],[299,56,299,77,0],[299,77,299,79,1],[300,17,303,21,1],[303,21,303,83,1],[303,83,304,25,1],[304,25,304,46,1],[304,46,307,21,1],[307,21,307,36,1],[307,36,308,19,1],[309,13,309,14,1],[312,19,312,54,1],[312,55,312,56,1],[312,57,312,62,0],[312,66,312,76,0],[312,77,312,78,0],[314,13,314,27,1],[316,13,316,51,1],[317,9,317,10,1],[322,36,322,72,1],[332,33,332,60,1],[340,13,340,27,1],[340,28,340,90,1],[341,9,341,10,1],[351,13,351,43,1],[352,13,352,54,1],[352,55,352,94,0],[353,13,353,60,1],[361,13,361,42,1],[362,9,362,10,1],[367,42,367,46,1],[372,39,372,70,1],[377,50,377,54,1],[382,42,382,46,1],[387,47,387,51,1],[392,57,392,61,1],[392,66,392,94,1],[397,56,397,60,1],[397,65,397,84,1],[403,47,403,78,1],[409,13,409,62,1],[410,13,410,44,1],[411,9,411,10,1]]);
    </script>
  </body>
</html>