<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Serialization\HeapData.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Text;
using Hazelcast.Core;

namespace Hazelcast.Serialization
{
    /// &lt;summary&gt;
    /// Implements &lt;see cref=&quot;IData&quot;/&gt; on the heap.
    /// &lt;/summary&gt;
    internal sealed class HeapData : IData
    {
        // structure is:
        // partition-hash (4 bytes) | type (4 bytes) | data (byte[])

        internal const int PartitionHashOffset = 0;
        internal const int TypeOffset = 4;
        internal const int DataOffset = 8;

        private const int HeapDataOverHead = DataOffset;

        private const int ArrayHeaderSizeInBytes = 16;

        private readonly byte[] _bytes;

        /// &lt;summary&gt;
        /// Initializes a new empty instance of the &lt;see cref=&quot;HeapData&quot;/&gt; class.
        /// &lt;/summary&gt;
        public HeapData()
        { }

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;HeapData&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;bytes&quot;&gt;The data bytes.&lt;/param&gt;
        public HeapData(byte[] bytes)
        {
            //??
            // will use a byte to store partition_hash bit
            // array (12: array header, 4: length)

            // type and partition hash are always written with BIG_ENDIAN byte order
            // either we don&#39;t have bytes, or we have enough bytes
            if (bytes != null &amp;&amp; bytes.Length &gt; 0 &amp;&amp; bytes.Length &lt; HeapDataOverHead)
                throw new ArgumentException($&quot;Data should either be empty or contain at least {HeapDataOverHead} bytes.&quot;);

            // TODO: HeapData bytes should in fact never be null, we can simplify all this

            _bytes = bytes;
        }

        /// &lt;inheritdoc /&gt;
        public int DataSize =&gt; Math.Max(TotalSize - HeapDataOverHead, 0);

        /// &lt;inheritdoc /&gt;
        public int TotalSize =&gt; _bytes?.Length ?? 0;

        /// &lt;inheritdoc /&gt;
        public int PartitionHash
        {
            get
            {
                int hash;
                return _bytes != null &amp;&amp;
                       _bytes.Length &gt;= HeapDataOverHead &amp;&amp;
                       (hash = _bytes.ReadInt(PartitionHashOffset, Endianness.BigEndian)) != 0
                    ? hash
                    : GetHashCode();
            }
        }

        public bool HasPartitionHash
            =&gt; _bytes != null &amp;&amp;
               _bytes.Length &gt;= HeapDataOverHead &amp;&amp;
               _bytes.ReadInt(PartitionHashOffset, Endianness.BigEndian) != 0;

        /// &lt;inheritdoc /&gt;
        public byte[] ToByteArray() =&gt; _bytes ?? Array.Empty&lt;byte&gt;();

        /// &lt;inheritdoc /&gt;
        public int TypeId
            =&gt; TotalSize == 0 ? SerializationConstants.ConstantTypeNull : _bytes.ReadInt(TypeOffset, Endianness.BigEndian);

        /// &lt;inheritdoc /&gt;
        public int HeapCost
            // where does this come from?
            =&gt; BytesExtensions.SizeOfInt + (_bytes != null ? ArrayHeaderSizeInBytes + _bytes.Length : 0);

        /// &lt;inheritdoc /&gt;
        public bool IsPortable
            =&gt; SerializationConstants.ConstantTypePortable == TypeId;

        /// &lt;inheritdoc /&gt;
        public override bool Equals(object o)
        {
            if (this == o)
                return true;

            if (!(o is IData data))
                return false;

            if (TypeId != data.TypeId)
                return false;

            var dataSize = DataSize;
            if (dataSize != data.DataSize)
                return false;

            return dataSize == 0 || Equals(_bytes, data.ToByteArray());
        }

        /// &lt;inheritdoc /&gt;
        public override int GetHashCode()
        {
            return Murmur3HashCode.Hash(_bytes, DataOffset, DataSize);
        }

        /// &lt;inheritdoc /&gt;
        public override string ToString()
        {
            var sb = new StringBuilder(&quot;DefaultData{&quot;);
            sb.Append(&quot;type=&quot;).Append(TypeId);
            sb.Append(&quot;, hashCode=&quot;).Append(GetHashCode());
            sb.Append(&quot;, partitionHash=&quot;).Append(PartitionHash);
            sb.Append(&quot;, totalSize=&quot;).Append(TotalSize);
            sb.Append(&quot;, dataSize=&quot;).Append(DataSize);
            sb.Append(&quot;, heapCost=&quot;).Append(HeapCost);
            sb.Append(&#39;}&#39;);
            return sb.ToString();
        }

        // Same as Arrays.equals(byte[] a, byte[] a2) but loop order is reversed.
        private static bool Equals(byte[] data1, byte[] data2)
        {
            if (data1 == data2)
                return true;

            if (data1 == null || data2 == null)
                return false;

            var length = data1.Length;
            if (data2.Length != length)
                return false;

            unchecked
            {
                for (var i = length - 1; i &gt;= DataOffset; i--)
                {
                    if (data1[i] != data2[i])
                        return false;
                }
            }

            return true;
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[42,9,42,26,1],[43,11,43,12,1],[49,9,49,38,1],[57,13,57,86,1],[58,17,58,123,0],[62,13,62,28,1],[63,9,63,10,1],[66,32,66,73,1],[69,33,69,52,1],[77,17,81,37,1],[86,16,88,78,0],[91,40,91,69,1],[95,16,95,123,1],[100,16,100,105,0],[104,16,104,69,1],[109,13,109,27,1],[110,17,110,29,1],[112,13,112,36,1],[113,17,113,30,0],[115,13,115,39,1],[116,17,116,30,0],[118,13,118,37,1],[119,13,119,43,1],[120,17,120,30,0],[122,13,122,72,1],[128,13,128,71,1],[134,13,134,56,0],[135,13,135,47,0],[136,13,136,60,0],[137,13,137,65,0],[138,13,138,57,0],[139,13,139,55,0],[140,13,140,55,0],[141,13,141,28,0],[142,13,142,34,0],[148,13,148,32,1],[149,17,149,29,0],[151,13,151,48,1],[152,17,152,30,0],[154,13,154,39,1],[155,13,155,40,1],[156,17,156,30,0],[160,22,160,40,1],[160,42,160,57,1],[160,59,160,62,1],[162,21,162,46,1],[163,25,163,38,0],[167,13,167,25,1]]);
    </script>
  </body>
</html>