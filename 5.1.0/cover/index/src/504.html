<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\NearCaching\NearCacheBase.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Hazelcast.Clustering;
using Hazelcast.Core;
using Hazelcast.Exceptions;
using Hazelcast.Serialization;
using Microsoft.Extensions.Logging;

namespace Hazelcast.NearCaching
{
    /// &lt;summary&gt;
    /// Provides a base class for Near Caches.
    /// &lt;/summary&gt;
    internal abstract class NearCacheBase : IAsyncDisposable
    {
        private readonly int _evictionPercentage;
        private readonly int _cleanupInterval;

        private readonly ConcurrentAsyncDictionary&lt;IData, NearCacheEntry&gt; _entries;
        private readonly EvictionPolicy _evictionPolicy;
        private readonly long _maxIdleMilliseconds;
        private readonly int _maxSize;
        private readonly long _timeToLive;
        private readonly IComparer&lt;NearCacheEntry&gt; _evictionComparer;

        private int _expiring;
        private int _evicting;
        private long _lastExpire; // last time expiration ran

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;NearCacheBase&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;name&quot;&gt;The name of the cache.&lt;/param&gt;
        /// &lt;param name=&quot;cluster&quot;&gt;The cluster.&lt;/param&gt;
        /// &lt;param name=&quot;serializationService&quot;&gt;The localization service.&lt;/param&gt;
        /// &lt;param name=&quot;loggerFactory&quot;&gt;A logger factory.&lt;/param&gt;
        /// &lt;param name=&quot;nearCacheOptions&quot;&gt;NearCache options.&lt;/param&gt;
        protected NearCacheBase(string name, Cluster cluster, SerializationService serializationService, ILoggerFactory loggerFactory, NearCacheOptions nearCacheOptions)
        {
            if (string.IsNullOrWhiteSpace(name)) throw new ArgumentException(ExceptionMessages.NullOrEmpty, nameof(name));
            Name = name;
            Cluster = cluster ?? throw new ArgumentNullException(nameof(cluster));
            SerializationService = serializationService ?? throw new ArgumentNullException(nameof(serializationService));
            LoggerFactory = loggerFactory ?? throw new ArgumentNullException(nameof(loggerFactory));
            Options = nearCacheOptions ?? throw new ArgumentNullException(nameof(nearCacheOptions));

            _entries = new ConcurrentAsyncDictionary&lt;IData, NearCacheEntry&gt;();
            Statistics = new NearCacheStatistics(name);

            _lastExpire = Clock.Never;

            _maxSize = nearCacheOptions.MaxSize;
            _maxIdleMilliseconds = nearCacheOptions.MaxIdleSeconds * 1000;
            InMemoryFormat = nearCacheOptions.InMemoryFormat;
            _timeToLive = nearCacheOptions.TimeToLiveSeconds * 1000;
            _evictionPolicy = nearCacheOptions.EvictionPolicy;
            _evictionComparer = GetEvictionComparer(_evictionPolicy);
            _evictionPercentage = nearCacheOptions.EvictionPercentage;
            _cleanupInterval = nearCacheOptions.CleanupPeriodSeconds * 1000;

            cluster.State.Failover.ClusterChanged += (options) =&gt;
            {
                 Clear();
            };
        }

        /// &lt;summary&gt;
        /// Gets the name of the cache.
        /// &lt;/summary&gt;
        public string Name { get; }

        /// &lt;summary&gt;
        /// Gets the options for this cache.
        /// &lt;/summary&gt;
        protected NearCacheOptions Options { get; }

        /// &lt;summary&gt;
        /// Gets the cluster.
        /// &lt;/summary&gt;
        protected Cluster Cluster { get; }

        /// &lt;summary&gt;
        /// Gets the in-memory format.
        /// &lt;/summary&gt;
        public InMemoryFormat InMemoryFormat { get; }

        /// &lt;summary&gt;
        /// Gets the serialization service.
        /// &lt;/summary&gt;
        public SerializationService SerializationService { get; }

        /// &lt;summary&gt;
        /// Gets the logger factory.
        /// &lt;/summary&gt;
        protected ILoggerFactory LoggerFactory { get; }

        /// &lt;summary&gt;
        /// Gets statistics
        /// &lt;/summary&gt;
        public NearCacheStatistics Statistics { get; }

        /// &lt;summary&gt;
        /// Gets the raw entries count.
        /// &lt;/summary&gt;
        public int Count =&gt; _entries.Count;

        /// &lt;summary&gt;
        /// (internal for tests only)
        /// Gets a snapshot of the cache entries.
        /// &lt;/summary&gt;
        internal async Task&lt;List&lt;NearCacheEntry&gt;&gt; SnapshotEntriesAsync()
        {
            var list = new List&lt;NearCacheEntry&gt;();
            await foreach (var e in _entries)
                list.Add(e.Value);
            return list;
        }

        #region Initialize &amp; Destroy

        /// &lt;summary&gt;
        /// Initializes the cache.
        /// &lt;/summary&gt;
        public abstract ValueTask InitializeAsync();

        /// &lt;inheritdoc /&gt;
        public async ValueTask DisposeAsync()
        {
            await DisposeAsyncCore().CfAwait();
            _entries.Clear();
        }

        /// &lt;summary&gt;
        /// Performs &lt;see cref=&quot;DisposeAsync&quot;/&gt; in inherited classes.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        protected virtual ValueTask DisposeAsyncCore() =&gt; default;

        #endregion

        #region Add, Get, Contains, Remove &amp; Clear

        /// &lt;summary&gt;
        /// Tries to add a value to the cache.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;keyData&quot;&gt;The key data.&lt;/param&gt;
        /// &lt;param name=&quot;valueData&quot;&gt;The value data.&lt;/param&gt;
        /// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt; if the value could be added; otherwise &lt;c&gt;false&lt;/c&gt;.&lt;/returns&gt;
        public async Task&lt;bool&gt; TryAddAsync(IData keyData, IData valueData)
        {
            // kick eviction policy if needed
            if (_evictionPolicy != EvictionPolicy.None &amp;&amp; _entries.Count &gt;= _maxSize)
                await EvictEntries().CfAwait();

            // cannot add if the cache is full
            if (_evictionPolicy == EvictionPolicy.None &amp;&amp; _entries.Count &gt;= _maxSize)
                return false;

            ValueTask&lt;NearCacheEntry&gt; CreateEntry(IData _, CancellationToken __)
            {
                return new ValueTask&lt;NearCacheEntry&gt;(CreateCacheEntry(keyData, ToCachedValue(valueData)));
            }

            // if we put an async entry in an async dictionary and the factory throws,
            // then the entry will be removed from the dictionary - and also, when
            // TryAddAsync completes, the value has been added (the factory has completed
            // too) - so, there is no need to remove anything from the cache in case
            // of an exception
            //
            // likewise, the dictionary treats null values as invalid and CreateCacheEntry
            // returns null if the cached value (ValueObject) is null - all in all, safe

            try
            {
                var added = await _entries.TryAddAsync(keyData, CreateEntry).CfAwait();
                if (added) Statistics.NotifyEntryAdded();
                return added;
            }
            catch
            {
                // ignore - should we log?
                return false;
            }
        }

        /// &lt;summary&gt;
        /// Tries to get a value from, or add a value to, the cache.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;keyData&quot;&gt;The key data.&lt;/param&gt;
        /// &lt;param name=&quot;valueFactory&quot;&gt;A factory that accepts the key data and returns the value data.&lt;/param&gt;
        /// &lt;returns&gt;An attempt at getting or adding a value to the cache.&lt;/returns&gt;
        public async Task&lt;Attempt&lt;object&gt;&gt; TryGetOrAddAsync(IData keyData, Func&lt;IData, Task&lt;IData&gt;&gt; valueFactory)
        {
            // if it&#39;s in the cache already, return it
            // (and TryGetAsync counts a hit)
            // (otherwise, TryGetAsync counts a miss, so we don&#39;t have to do it here)
            var (hasEntry, valueObject) = await TryGetAsync(keyData).CfAwait();
            if (hasEntry) return valueObject;

            // kick eviction policy if needed
            if (_evictionPolicy != EvictionPolicy.None &amp;&amp; _entries.Count &gt;= _maxSize)
                await EvictEntries().CfAwait();

            // if the cache is full, directly return the un-cached value
            if (_evictionPolicy == EvictionPolicy.None &amp;&amp; _entries.Count &gt;= _maxSize &amp;&amp; !await _entries.ContainsKeyAsync(keyData).CfAwait())
                return Attempt.Fail(ToCachedValue(await valueFactory(keyData).CfAwait()));

            async ValueTask&lt;NearCacheEntry&gt; CreateEntry(IData _, CancellationToken __)
            {
                var valueData = await valueFactory(keyData).CfAwait();
                var cachedValue = ToCachedValue(valueData);

                return CreateCacheEntry(keyData, cachedValue); // null if cachedValue is null
            }

            var entry = await _entries.GetOrAddAsync(keyData, CreateEntry).CfAwait();
            if (entry != null) // null if ValueObject would have been null
            {

                Statistics.NotifyEntryAdded();
                return entry.ValueObject;
            }

            // the entry will not stick in _entries
            // and we haven&#39;t notified statistics

            return Attempt.Failed;
        }

        /// &lt;summary&gt;
        /// Tries to get a value from the cache.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;keyData&quot;&gt;The key data.&lt;/param&gt;
        /// &lt;param name=&quot;hit&quot;&gt;Whether to hit the entry or not.&lt;/param&gt;
        /// &lt;returns&gt;An attempt at getting the value for the specified key.&lt;/returns&gt;
        public async ValueTask&lt;Attempt&lt;object&gt;&gt; TryGetAsync(IData keyData, bool hit = true)
        {
            await ExpireEntries().CfAwait();

            // it is not possible to get a null entry, nor an entry with a null ValueObject
            var (hasEntry, entry) = await _entries.TryGetAsync(keyData).CfAwait();

            if (!hasEntry)
            {
                Statistics.NotifyMiss();
                return Attempt.Failed;
            }

            if (IsStaleRead(entry))
            {
                Remove(keyData);
                Statistics.NotifyMiss();
                Statistics.NotifyStaleRead();
                return Attempt.Failed;
            }

            if (IsExpired(entry))
            {
                Remove(keyData);
                Statistics.NotifyMiss();
                Statistics.NotifyExpiration();
                return Attempt.Failed;
            }

            if (hit)
            {
                entry.NotifyHit();
                Statistics.NotifyHit();
            }

            return entry.ValueObject;
        }

        /// &lt;summary&gt;
        /// Determines whether the cache contains an entry.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;keyData&quot;&gt;The key data.&lt;/param&gt;
        /// &lt;param name=&quot;hit&quot;&gt;Whether to hit the entry or not.&lt;/param&gt;
        /// &lt;returns&gt;Whether the cache contains an entry with the specified key.&lt;/returns&gt;
        public async ValueTask&lt;bool&gt; ContainsKeyAsync(IData keyData, bool hit = true)
        {
            var (contains, _) = await TryGetAsync(keyData, hit).CfAwait();
            return contains;
        }

        /// &lt;summary&gt;
        /// Removes an entry from the cache.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;keyData&quot;&gt;The key data.&lt;/param&gt;
        /// &lt;returns&gt;Whether an entry was removed.&lt;/returns&gt;
        public bool Remove(IData keyData)
        {
            if (!_entries.TryRemove(keyData))
                return false;

            Statistics.NotifyEntryRemoved();
            return true;
        }

        /// &lt;summary&gt;
        /// Clears the cache.
        /// &lt;/summary&gt;
        public void Clear()
        {
            _entries.Clear();
            Statistics.ResetEntryCount();
        }

        /// &lt;summary&gt;
        /// Creates a new cache entry.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;keyData&quot;&gt;The key data.&lt;/param&gt;
        /// &lt;param name=&quot;valueObject&quot;&gt;The value object, which is either &lt;see cref=&quot;IData&quot;/&gt; or the actual &lt;see cref=&quot;object&quot;/&gt;.&lt;/param&gt;
        /// &lt;returns&gt;A new cache entry, if &lt;paramref name=&quot;valueObject&quot;/&gt; is not &lt;c&gt;null&lt;/c&gt;, otherwise &lt;c&gt;null&lt;/c&gt;.&lt;/returns&gt;
        protected virtual NearCacheEntry CreateCacheEntry(IData keyData, object valueObject)
        {
            return valueObject == null ? null : new NearCacheEntry(keyData, valueObject, _timeToLive);
        }

        /// &lt;summary&gt;
        /// Determines whether a cached entry is stale.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;entry&quot;&gt;The entry.&lt;/param&gt;
        /// &lt;returns&gt;Whether the entry is stale.&lt;/returns&gt;
        protected virtual bool IsStaleRead(NearCacheEntry entry) =&gt; false;

        /// &lt;summary&gt;
        /// Converts a value &lt;see cref=&quot;IData&quot;/&gt; to the internal cached value format.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;valueData&quot;&gt;Value data.&lt;/param&gt;
        /// &lt;returns&gt;Internal cached value.&lt;/returns&gt;
        protected virtual object ToCachedValue(IData valueData)
        {
            return InMemoryFormat.Equals(InMemoryFormat.Binary)
                ? valueData
                : SerializationService.ToObject&lt;object&gt;(valueData);
        }

        #endregion

        #region Evict &amp; Expire

        // entries are evicted on each add (TryAdd, TryGetOrAdd)
        // entries are expired on each get (TryGetValue)

        /// &lt;summary&gt;
        /// Evicts entries if not already evicting.
        /// &lt;/summary&gt;
        private async ValueTask EvictEntries()
        {
            try
            {
                // only one at a time please
                if (Interlocked.CompareExchange(ref _evicting, 1, 0) == 1)
                    return;

                await DoEvictEntries().CfAwait();
            }
            finally
            {
                // make sure to release the lock
                Interlocked.Exchange(ref _evicting, 0);
            }
        }

        /// &lt;summary&gt;
        /// Evicts entries.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        private async ValueTask DoEvictEntries()
        {
            if (_evictionPolicy == EvictionPolicy.None || _entries.Count &lt; _maxSize)
                return;

            var entries = new SortedSet&lt;NearCacheEntry&gt;(_evictionComparer);
            await foreach (var (_, value) in _entries)
                entries.Add(value);

            var evictCount = entries.Count * _evictionPercentage / 100;
            if (evictCount &lt; 1)
                return;

            var count = 0;

            // ReSharper disable once ForeachCanBePartlyConvertedToQueryUsingAnotherGetEnumerator
            foreach (var entry in entries)
            {
                if (!_entries.TryRemove(entry.KeyData))
                    continue;

                Statistics.NotifyEntryRemoved();
                Statistics.NotifyEviction();

                if (++count &gt; evictCount)
                    break;
            }

            // original code would repeat if (_entries.Count &gt;= _maxSize)
            // but that can potentially lead to endless loops - removing
        }

        /// &lt;summary&gt;
        /// Expires entries if not already expiring.
        /// &lt;/summary&gt;
        private async ValueTask ExpireEntries()
        {
            // run when it is time to run
            if (Clock.Milliseconds &lt; _lastExpire + _cleanupInterval)
                return;

            try
            {
                // only one at a time please
                if (Interlocked.CompareExchange(ref _expiring, 1, 0) == 1)
                    return;

                _lastExpire = Clock.Milliseconds;

                await DoExpireEntries().CfAwait();
            }
            finally
            {
                // make sure to release the lock
                Interlocked.Exchange(ref _expiring, 0);
            }
        }

        /// &lt;summary&gt;
        /// Expire entries.
        /// &lt;/summary&gt;
        private async ValueTask DoExpireEntries()
        {
            await foreach (var (key, entry) in _entries)
            {
                if (!IsExpired(entry)) continue;

                Remove(key);
                Statistics.NotifyExpiration();
            }
        }

        /// &lt;summary&gt;
        /// Gets the record comparer corresponding to an eviction policy.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;policy&quot;&gt;The eviction policy.&lt;/param&gt;
        /// &lt;returns&gt;The record comparer corresponding to the specified eviction policy.&lt;/returns&gt;
        private static IComparer&lt;NearCacheEntry&gt; GetEvictionComparer(EvictionPolicy policy)
        {
            return policy switch
            {
                EvictionPolicy.Lfu =&gt; new LfuComparer(),
                EvictionPolicy.Lru =&gt; new LruComparer(),
                EvictionPolicy.None =&gt; new DefaultComparer(),
                EvictionPolicy.Random =&gt; new RandomComparer(),
                _ =&gt; throw new NotSupportedException()
            };
        }

        /// &lt;summary&gt;
        /// Determines whether a record has expired.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;entry&quot;&gt;The record.&lt;/param&gt;
        /// &lt;returns&gt;true if the record has expired; false otherwise.&lt;/returns&gt;
        private bool IsExpired(NearCacheEntry entry)
        {
            var now = Clock.Milliseconds;
            return entry.IsExpiredAt(now) || entry.IsIdleAt(_maxIdleMilliseconds, now);
        }

        #endregion
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[54,9,54,170,1],[56,13,56,49,1],[56,50,56,123,0],[57,13,57,25,1],[58,13,58,83,1],[59,13,59,122,1],[60,13,60,101,1],[61,13,61,101,1],[63,13,63,79,1],[64,13,64,56,1],[66,13,66,39,1],[68,13,68,49,1],[69,13,69,75,1],[70,13,70,62,1],[71,13,71,69,1],[72,13,72,63,1],[73,13,73,70,1],[74,13,74,71,1],[75,13,75,77,1],[77,13,79,18,1],[79,18,79,26,0],[79,26,80,13,1],[80,13,80,14,0],[80,14,80,15,1],[81,9,81,10,1],[86,30,86,34,1],[91,46,91,50,1],[96,37,96,41,1],[101,48,101,52,1],[106,60,106,64,1],[111,50,111,54,1],[116,49,116,53,1],[121,29,121,43,1],[129,13,129,51,1],[130,28,130,33,1],[130,34,130,36,1],[130,37,130,45,1],[131,17,131,35,1],[132,13,132,25,1],[133,9,133,10,1],[145,13,145,48,1],[146,13,146,30,1],[147,9,147,10,1],[153,59,153,66,0],[168,13,168,86,1],[169,17,169,48,0],[172,13,172,86,1],[173,17,173,30,1],[177,17,177,107,1],[191,17,191,88,1],[192,17,192,27,1],[192,28,192,58,1],[193,17,193,30,1],[195,13,195,18,0],[198,17,198,30,0],[200,9,200,10,1],[213,13,213,80,1],[214,13,214,26,1],[214,27,214,46,1],[217,13,217,86,1],[218,17,218,48,1],[221,13,221,141,1],[222,17,222,91,0],[226,17,226,71,1],[227,17,227,60,1],[229,17,229,63,1],[230,13,230,14,1],[232,13,232,86,1],[233,13,233,31,1],[236,17,236,47,1],[237,17,237,42,1],[243,13,243,35,1],[244,9,244,10,1],[254,13,254,45,1],[257,13,257,83,1],[259,13,259,27,1],[261,17,261,41,1],[262,17,262,39,1],[265,13,265,36,1],[267,17,267,33,0],[268,17,268,41,0],[269,17,269,46,0],[270,17,270,39,0],[273,13,273,34,1],[275,17,275,33,1],[276,17,276,41,1],[277,17,277,47,1],[278,17,278,39,1],[281,13,281,21,1],[283,17,283,35,1],[284,17,284,40,1],[287,13,287,38,1],[288,9,288,10,1],[298,13,298,75,1],[299,13,299,29,1],[300,9,300,10,1],[309,13,309,46,1],[310,17,310,30,1],[312,13,312,45,1],[313,13,313,25,1],[321,13,321,30,1],[322,13,322,42,1],[323,9,323,10,1],[333,13,333,103,1],[341,69,341,74,0],[350,13,352,68,1],[370,17,370,75,1],[371,21,371,28,0],[373,17,373,50,1],[374,13,374,14,1],[378,17,378,56,1],[380,9,380,10,1],[388,13,388,85,1],[389,17,389,24,0],[391,13,391,76,1],[392,28,392,42,1],[392,43,392,45,1],[392,46,392,54,1],[393,17,393,36,1],[395,13,395,72,1],[396,13,396,32,1],[397,17,397,24,0],[399,13,399,27,1],[402,22,402,31,1],[402,32,402,34,1],[402,35,402,42,1],[404,17,404,56,1],[407,17,407,49,1],[408,17,408,45,1],[410,17,410,42,1],[416,9,416,10,1],[424,13,424,69,1],[425,17,425,24,1],[430,17,430,75,1],[431,21,431,28,1],[433,17,433,50,1],[435,17,435,51,1],[436,13,436,14,1],[440,17,440,56,1],[442,9,442,10,1],[449,28,449,44,1],[449,45,449,47,1],[449,48,449,56,1],[451,17,451,39,1],[453,17,453,29,0],[454,17,454,47,0],[456,9,456,10,1],[465,13,467,39,1],[467,39,467,56,1],[467,56,468,39,1],[468,39,468,56,1],[468,56,469,40,1],[469,40,469,61,1],[469,61,470,42,1],[470,42,470,62,0],[470,62,471,22,1],[471,22,471,55,0],[471,55,472,15,1],[482,13,482,42,1],[483,13,483,88,1]]);
    </script>
  </body>
</html>