<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Clustering\MemberConnectionQueue.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Hazelcast.Core;
using Hazelcast.Models;
using Microsoft.Extensions.Logging;

namespace Hazelcast.Clustering
{
    /// &lt;summary&gt;
    /// Represents the queue of members that need to be connected.
    /// &lt;/summary&gt;
    internal class MemberConnectionQueue : IAsyncEnumerable&lt;MemberConnectionRequest&gt;, IAsyncDisposable
    {
        private readonly AsyncQueue&lt;MemberConnectionRequest&gt; _requests = new AsyncQueue&lt;MemberConnectionRequest&gt;();
        private readonly AsyncQueue&lt;MemberConnectionRequest&gt; _delayed = new AsyncQueue&lt;MemberConnectionRequest&gt;();
        private readonly CancellationTokenSource _cancel = new CancellationTokenSource();

        private readonly SemaphoreSlim _resume = new SemaphoreSlim(0); // blocks the queue when it is suspended
        private readonly SemaphoreSlim _enumerate = new SemaphoreSlim(1); // ensures there can be only 1 concurrent enumerator

        private readonly object _mutex = new object();

        private readonly ILogger _logger;
        private readonly Task _delaying;

        private volatile bool _disposed;
        private MemberConnectionRequest _request;
        private bool _suspended;

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;MemberConnectionQueue&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loggerFactory&quot;&gt;A logger factory.&lt;/param&gt;
        public MemberConnectionQueue(ILoggerFactory loggerFactory)
        {
            if (loggerFactory == null) throw new ArgumentNullException(nameof(loggerFactory));
            _logger = loggerFactory.CreateLogger&lt;MemberConnectionQueue&gt;();
            _delaying = Delay();

            HConsole.Configure(x =&gt; x.Configure&lt;MemberConnectionQueue&gt;().SetPrefix(&quot;MBRQ&quot;));
        }

        public event EventHandler&lt;MemberConnectionRequest&gt; ConnectionFailed;

        /// &lt;summary&gt;
        /// (internals for tests only) Gets the count of requests in the queue.
        /// &lt;/summary&gt;
        internal int RequestsCount =&gt; _requests.Count;

        /// &lt;summary&gt;
        /// (internals for tests only) Gets the count of delayed requests in the queue.
        /// &lt;/summary&gt;
        internal int DelayedRequestsCount =&gt; _delayed.Count;

        /// &lt;summary&gt;
        /// Suspends the queue.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;A &lt;see cref=&quot;ValueTask&quot;/&gt; that will be completed when the queue is suspended.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;If an item is being processed, this waits for the processing to complete.&lt;/para&gt;
        /// &lt;para&gt;When the queue is suspended, calls to the enumerator&#39;s MoveNextAsync() method blocks.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public ValueTask SuspendAsync()
        {
            lock (_mutex)
            {
                if (_disposed) return default; // nothing to suspend - but no need to throw about it

                _logger.IfDebug()?.LogDebug(&quot;Suspend the members connection queue.&quot;);
                _suspended = true;

                // _request is a struct and cannot be null
                // the default MemberConnectionRequest&#39;s Completion is the default ValueTask
                // otherwise, is used to ensure that the request is completed before actually being suspended
                return _request.Completion;
            }
        }

        /// &lt;summary&gt;
        /// Resumes the queue.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;If &lt;paramref name=&quot;drain&quot;/&gt; is &lt;c&gt;true&lt;/c&gt;, de-queues and ignores all queued items.&lt;/para&gt;
        /// &lt;para&gt;Unblocks calls to the enumerator MoveNextAsync() method.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public void Resume(bool drain = false)
        {
            lock (_mutex)
            {
                if (_disposed) return; // nothing to resume - but no need to throw about it
                if (!_suspended) throw new InvalidOperationException(&quot;Not suspended.&quot;);
                _logger.IfDebug()?.LogDebug(&quot;{DrainState} the members connection queue.&quot;, (drain ? &quot;Drain and resume&quot; : &quot;Resume&quot;));
                if (drain)
                {
                    _requests.ForEach(x =&gt; x.Cancel());
                    _delayed.ForEach(x =&gt; x.Cancel());
                }
                _suspended = false;
                _resume.Release();
            }
        }

        /// &lt;summary&gt;
        /// Adds a member to connect.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;member&quot;&gt;The member to connect.&lt;/param&gt;
        public void Add(MemberInfo member)
        {
            if (_disposed) return; // no need to add - no need to throw about it

            lock (_mutex)
            {
                if (!_requests.TryWrite(new MemberConnectionRequest(member)))
                {
                    // that should not happen, but log to be sure
                    _logger.IfWarning()?.LogWarning(&quot;Failed to add member ({MemberId}).&quot;, member.Id.ToShortString());
                }
                else
                {
                    _logger.IfDebug()?.LogDebug(&quot;Added member {MemberId}&quot;, member.Id.ToShortString());
                }
            }
        }

        /// &lt;summary&gt;
        /// Adds a request again.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;request&quot;&gt;The request.&lt;/param&gt;
        public void AddAgain(MemberConnectionRequest request)
        {
            if (_disposed || request.Cancelled) return; // no need to add - no need to throw about it

            _delayed.TryWrite(request);
        }

        private async Task Delay()
        {
            const int minDelay = 1000; // milliseconds - but later on each request could have a retry strategy

            await foreach (var request in _delayed.WithCancellation(_cancel.Token))
            {
                var elapsed = DateTime.UtcNow - request.CreateDate;
                var delay = minDelay - (int)elapsed.TotalMilliseconds;
                if (delay &gt; 0) await Task.Delay(delay, _cancel.Token).CfAwait();
                _requests.TryWrite(request);
            }
        }

        // when receiving members from the cluster... if a member is gone,
        // we need to remove it from the queue, no need to ever try to connect
        // to it again - so it remains in the _members async queue, but we
        // flag it so that when we dequeue it, we can ignore it

        /// &lt;summary&gt;
        /// Removes a member.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;memberId&quot;&gt;The identifier of the member.&lt;/param&gt;
        public void Remove(Guid memberId)
        {
            // cancel all corresponding requests - see notes in AsyncQueue, this is best-effort,
            // a member that we want to remove *may* end up being enumerated, and we&#39;re going to
            // to to connect to it, and either fail, or drop the connection - accepted tradeoff
            lock (_mutex) {
                _requests.ForEach(x =&gt;
                {
                    if (x.Member.Id == memberId) x.Cancel();
                });
                _delayed.ForEach(x =&gt;
                {
                    if (x.Member.Id == memberId) x.Cancel();
                });
            }
        }

        /// &lt;inheritdoc /&gt;
        public IAsyncEnumerator&lt;MemberConnectionRequest&gt; GetAsyncEnumerator(CancellationToken cancellationToken = default)
        {
            if (_disposed) throw new ObjectDisposedException(nameof(MemberConnectionQueue));

            // ensure that disposing this class cancels the enumeration
            return new AsyncEnumerator(this, _cancel.Token, cancellationToken);
        }

        private class AsyncEnumerator : IAsyncEnumerator&lt;MemberConnectionRequest&gt;
        {
            private readonly MemberConnectionQueue _queue;
            private readonly CancellationTokenSource _cancellation;
            private IAsyncEnumerator&lt;MemberConnectionRequest&gt; _queueRequestsEnumerator;

            public AsyncEnumerator(MemberConnectionQueue queue, CancellationToken cancellationToken1, CancellationToken cancellationToken2)
            {
                _queue = queue;
                _cancellation = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken1, cancellationToken2);
            }

            public async ValueTask&lt;bool&gt; MoveNextAsync()
            {
                if (_cancellation.IsCancellationRequested) return false;

                // if this is the first call, validate that we are only enumerating once at a time &amp; create the enumerator
                if (_queueRequestsEnumerator == null)
                {
                    var acquired = await _queue._enumerate.WaitAsync(TimeSpan.Zero, default).CfAwait();
                    if (!acquired) throw new InvalidOperationException(&quot;Can only enumerate once at a time.&quot;);
                    _queueRequestsEnumerator = _queue._requests.GetAsyncEnumerator(_cancellation.Token);
                }

                // there is only one consumer, and the consumer *must* complete a request before picking a new one
                if (_queue._request != null &amp;&amp; !_queue._request.Completed)
                {
                    throw new InvalidOperationException(&quot;Cannot move to next request if previous request has not completed.&quot;);
                }

                // loop until we have a valid request to return, because we may dequeue nulls or cancelled members
                while (!_cancellation.IsCancellationRequested)
                {
                    // dequeue a request
                    if (!await _queueRequestsEnumerator.MoveNextAsync().CfAwait())
                        return false;

                    while (!_cancellation.IsCancellationRequested)
                    {
                        // if not suspended, make that request the current one and return - this request is not in the queue
                        // anymore, it&#39;s going to be processed no matter what even if the queue is drained or the member is
                        // removed, and then the established connection (if any) will be dropped
                        lock (_queue._mutex)
                        {
                            if (!_queue._suspended)
                            {
                                var request = _queueRequestsEnumerator.Current;
                                if (request.Member == null || request.Cancelled) break; // that request is to be skipped
                                request.Failed += (r, _) =&gt; _queue.ConnectionFailed?.Invoke(_queue, (MemberConnectionRequest)r);
                                _queue._request = request;
                                return true;
                            }
                        }

                        // if we reach this point, we did not return nor break = the queue was suspended, wait until it is released
                        // and then loop within the nested while =&gt; the dequeued request will be considered again
                        await _queue._resume.WaitAsync(_cancellation.Token).CfAwaitCanceled();
                    }
                }

                return false;
            }

            /// &lt;inheritdoc /&gt;
            public MemberConnectionRequest Current =&gt; _queue._request;

            public async ValueTask DisposeAsync()
            {
                if (_queueRequestsEnumerator != null)
                {
                    await _queueRequestsEnumerator.DisposeAsync().CfAwait();
                    _queue._enumerate.Release();
                }

                _cancellation.Dispose();
            }
        }

        /// &lt;inheritdoc /&gt;
        public async ValueTask DisposeAsync()
        {
            // note: DisposeAsync should not throw (CA1065)

            lock (_mutex)
            {
                if (_disposed) return;
                _disposed = true;
            }

            _requests.Complete();
            _delayed.Complete();
            _cancel.Cancel();
            _cancel.Dispose();

            await _delaying.CfAwaitNoThrow();

            // cannot wait until enumeration (if any) is complete,
            // because that depends on the caller calling MoveNext,
            // instead, we return false if the caller calls MoveNext,
            // and the caller should dispose the enumerator

            _resume.Dispose();
            _enumerate.Dispose();
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[30,9,30,116,1],[31,9,31,115,1],[32,9,32,90,1],[34,9,34,71,1],[35,9,35,74,1],[37,9,37,55,1],[50,9,50,67,1],[52,13,52,39,1],[52,40,52,95,0],[53,13,53,75,1],[54,13,54,33,1],[57,9,57,10,1],[64,39,64,54,1],[69,46,69,60,1],[81,13,81,26,1],[83,17,83,31,1],[83,32,83,47,0],[85,17,85,86,1],[86,17,86,35,1],[91,17,91,44,1],[93,9,93,10,1],[104,13,104,26,1],[106,17,106,31,1],[106,32,106,39,1],[107,17,107,33,1],[107,34,107,88,0],[108,17,108,132,1],[109,17,109,27,1],[111,21,111,44,1],[111,44,111,54,1],[111,54,111,56,1],[112,21,112,43,1],[112,43,112,53,1],[112,53,112,55,1],[114,17,114,36,1],[115,17,115,35,1],[116,13,116,14,1],[117,9,117,10,1],[125,13,125,27,1],[125,28,125,35,1],[127,13,127,26,1],[129,17,129,78,1],[132,21,132,118,0],[136,21,136,103,1],[138,13,138,14,1],[139,9,139,10,1],[147,13,147,48,1],[147,49,147,56,0],[149,13,149,40,1],[150,9,150,10,1],[156,28,156,39,1],[156,40,156,42,1],[156,43,156,83,1],[158,17,158,68,1],[159,17,159,71,1],[160,17,160,31,1],[160,32,160,81,1],[161,17,161,45,1],[162,13,162,14,1],[163,9,163,10,1],[179,13,179,26,1],[180,17,182,21,1],[182,21,182,49,0],[182,49,182,50,1],[182,50,182,61,0],[182,61,183,17,1],[183,17,183,18,0],[183,18,183,20,1],[184,17,186,21,1],[186,21,186,49,1],[186,49,186,50,1],[186,50,186,61,1],[186,61,187,17,1],[187,17,187,18,1],[187,18,187,20,1],[188,13,188,14,1],[189,9,189,10,1],[194,13,194,27,1],[194,28,194,93,0],[197,13,197,80,1],[206,13,206,140,1],[208,17,208,32,1],[209,17,209,121,1],[210,13,210,14,1],[214,17,214,59,1],[214,60,214,73,0],[217,17,217,54,1],[219,21,219,104,1],[220,21,220,35,1],[220,36,220,110,0],[221,21,221,105,1],[225,17,225,75,1],[227,21,227,127,0],[231,17,231,63,1],[234,21,234,83,1],[235,25,235,38,1],[237,21,237,67,1],[242,25,242,45,1],[244,29,244,52,1],[246,33,246,80,1],[247,33,247,81,1],[247,82,247,88,1],[248,33,248,129,1],[248,61,248,128,1],[249,33,249,59,1],[250,33,250,45,1],[252,25,252,26,1],[256,25,256,95,1],[260,17,260,30,0],[261,13,261,14,1],[264,55,264,70,1],[268,17,268,54,1],[270,21,270,77,1],[271,21,271,49,1],[274,17,274,41,1],[275,13,275,14,1],[283,13,283,26,1],[285,17,285,31,1],[285,32,285,39,0],[286,17,286,34,1],[287,13,287,14,1],[289,13,289,34,1],[290,13,290,33,1],[291,13,291,30,1],[292,13,292,31,1],[294,13,294,46,1],[301,13,301,31,1],[302,13,302,34,1],[303,9,303,10,1]]);
    </script>
  </body>
</html>