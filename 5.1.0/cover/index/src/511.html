<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\NearCaching\RepairingHandler.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using Hazelcast.Core;
using Hazelcast.Partitioning;
using Hazelcast.Serialization;
using Microsoft.Extensions.Logging;

namespace Hazelcast.NearCaching
{
    /// &lt;summary&gt;
    /// Represents a Near Cache repairing handler.
    /// &lt;/summary&gt;
    internal class RepairingHandler
    {
        private readonly ILogger _logger;
        private readonly Guid _clusterClientId;
        private readonly int _maxToleratedMissCount;
        private readonly MetaData[] _metadataTable;
        private readonly NearCache _nearCache;
        private readonly int _partitionCount;
        private readonly SerializationService _serializationService;
        private readonly Partitioner _partitioner;

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;RepairingHandler&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;clusterClientId&quot;&gt;The unique identifier of the cluster, as assigned by the client.&lt;/param&gt;
        /// &lt;param name=&quot;nearCache&quot;&gt;The near cache instance.&lt;/param&gt;
        /// &lt;param name=&quot;maxToleratedMissCount&quot;&gt;The max tolerated miss count.&lt;/param&gt;
        /// &lt;param name=&quot;partitioner&quot;&gt;The partitioner.&lt;/param&gt;
        /// &lt;param name=&quot;serializationService&quot;&gt;The serialization service.&lt;/param&gt;
        /// &lt;param name=&quot;loggerFactory&quot;&gt;A logger factory.&lt;/param&gt;
        public RepairingHandler(Guid clusterClientId, NearCache nearCache, int maxToleratedMissCount, Partitioner partitioner, SerializationService serializationService, ILoggerFactory loggerFactory)
        {
            _clusterClientId = clusterClientId;
            _nearCache = nearCache;
            _partitioner = partitioner;
            _partitionCount = partitioner.Count;
            _metadataTable = CreateMetadataTable(_partitionCount);
            _maxToleratedMissCount = maxToleratedMissCount;
            _serializationService = serializationService;
            _logger = loggerFactory.CreateLogger&lt;RepairingHandler&gt;();
        }

        // multiple threads can concurrently call this method: one is anti-entropy, other one is event service thread
        // TODO: understand and document what those GUIDs are?!
        /// &lt;summary&gt;
        /// Updates the ???
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;partitionId&quot;&gt;The partition identifier.&lt;/param&gt;
        /// &lt;param name=&quot;newUuid&quot;&gt;???&lt;/param&gt;
        public void UpdateUuid(int partitionId, Guid newUuid)
        {
            if (newUuid == default) throw new ArgumentOutOfRangeException(nameof(newUuid));

            var metadata = GetMetadata(partitionId);

            while (true)
            {
                var currentUuid = metadata.Guid;

                // ignore if not changed
                if (currentUuid.Equals(newUuid))
                    break;

                // try to update the ???, loop if current ??? is locked?
                // assuming that eventually, the new ??? will be accepted
                if (!metadata.TrySetGuid(newUuid))
                    continue;

                // reset and report
                metadata.ResetSequences();
                _logger.IfDebug()?.LogDebug(&quot;Invalid UUID, lost remote partition data unexpectedly (map={NearCacheName}, partition={PartitionId}, current={CurrentUuid}, new={NewUuid})&quot;, _nearCache.Name, partitionId, currentUuid, newUuid);

                // we&#39;re done
                break;
            }
        }

        /// &lt;summary&gt;
        /// Updates the sequence of a partition.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;partitionId&quot;&gt;The partition identifier.&lt;/param&gt;
        /// &lt;param name=&quot;newSequence&quot;&gt;The new sequence value.&lt;/param&gt;
        /// &lt;param name=&quot;viaAntiEntropy&quot;&gt;Whether the method is invoked by the anti-entropy task.&lt;/param&gt;
        public void UpdateSequence(int partitionId, long newSequence, bool viaAntiEntropy)
        {
            if (newSequence &lt; 0) throw new ArgumentOutOfRangeException(nameof(newSequence));

            var metadata = GetMetadata(partitionId);

            while (true)
            {
                var currentSequence = metadata.Sequence;

                // ignore an obsolete new sequence
                if (currentSequence &gt;= newSequence)
                    break;

                // try to update the sequence, loop if current sequence has changed in the meantime
                // assuming that, eventually, the new sequence will either be accepted, or obsolete
                if (!metadata.UpdateSequence(currentSequence, newSequence))
                    continue;

                // sequence has been updated - handle the change
                var sequenceDelta = newSequence - currentSequence;
                if (viaAntiEntropy || sequenceDelta &gt; 1L)
                {
                    // we have found at least one missing sequence between current and new sequences. if miss is detected by
                    // anti-entropy, number of missed sequences will be &#39;miss = new - current&#39;, otherwise it means miss is
                    // detected by observing received invalidation event sequence numbers and number of missed sequences will be
                    // &#39;miss =  new - current - 1&#39;.
                    var missCount = viaAntiEntropy ? sequenceDelta : sequenceDelta - 1;
                    var totalMissCount = metadata.AddMissedSequences(missCount);

                    // report
                    _logger.IfDebug()?.LogDebug(&quot;Invalid sequence (map={NearCacheName}, partition={PartitionId}, current={CurrentSequence}, new={NewSequence}, totalMiss={TotalMissCount})&quot;, _nearCache.Name, partitionId, currentSequence, newSequence, totalMissCount);
                }

                // we&#39;re done
                break;
            }
        }

        #region Meta data

        /// &lt;summary&gt;
        /// Populates a meta data table.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;partitionCount&quot;&gt;The number of partitions.&lt;/param&gt;
        /// &lt;returns&gt;A meta data table.&lt;/returns&gt;
        private static MetaData[] CreateMetadataTable(int partitionCount)
        {
            var metaData = new MetaData[partitionCount];
            for (var partitionId = 0; partitionId &lt; partitionCount; partitionId++)
                metaData[partitionId] = new MetaData();
            return metaData;
        }

        /// &lt;summary&gt;
        /// Gets meta data for a partition.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;partitionId&quot;&gt;The partition identifier.&lt;/param&gt;
        /// &lt;returns&gt;Meta data for the specified partition.&lt;/returns&gt;
        public MetaData GetMetadata(int partitionId)
            =&gt; _metadataTable[partitionId];

        #endregion

        /// &lt;summary&gt;
        /// Handles an invalidation.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;key&quot;&gt;The invalidated key.&lt;/param&gt;
        /// &lt;param name=&quot;sourceClusterClientId&quot;&gt;The identifier of the cluster client originating the event.&lt;/param&gt;
        /// &lt;param name=&quot;partitionGuid&quot;&gt;???&lt;/param&gt;
        /// &lt;param name=&quot;sequence&quot;&gt;The sequence.&lt;/param&gt;
        public void Handle(IData key, Guid sourceClusterClientId, Guid partitionGuid, long sequence)
        {
            // apply invalidation if it&#39;s not originated by the cluster client (Hazelcast client)
            // running this code, because local Near Caches are invalidated immediately.
            if (!_clusterClientId.Equals(sourceClusterClientId))
            {
                // sourceClusterClientId is allowed to be null, meaning: all
                if (key == null)
                    _nearCache.Clear();
                else
                    _nearCache.Remove(key);
            }

            var partitionId = GetPartitionIdOrDefault(key);
            UpdateUuid(partitionId, partitionGuid);
            UpdateSequence(partitionId, sequence, false);
        }

        /// &lt;summary&gt;
        /// Handles an invalidation.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;keys&quot;&gt;The invalidated keys.&lt;/param&gt;
        /// &lt;param name=&quot;sourceClusterClientIds&quot;&gt;The identifiers of the cluster client originating the event.&lt;/param&gt;
        /// &lt;param name=&quot;partitionUuids&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;sequences&quot;&gt;The sequences.&lt;/param&gt;
        public void Handle(IEnumerable&lt;IData&gt; keys, IEnumerable&lt;Guid&gt; sourceClusterClientIds, IEnumerable&lt;Guid&gt; partitionUuids,
            IEnumerable&lt;long&gt; sequences)
        {
            foreach (var (key, sourceClusterClientId, partitionUuid, sequence) in (keys, sourceClusterClientIds, partitionUuids, sequences).Combine())
                Handle(key, sourceClusterClientId, partitionUuid, sequence);
        }

        /// &lt;summary&gt;
        /// Initializes the ????
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;partitionUuidList&quot;&gt;&lt;/param&gt;
        public void InitializeGuids(IList&lt;KeyValuePair&lt;int, Guid&gt;&gt; partitionUuidList)
        {
            // received from server:
            // (partition id -&gt; partition ???), (...), ...

            foreach (var (partitionId, partitionUuid) in partitionUuidList)
            {
                var metadata = GetMetadata(partitionId);
                metadata.Guid = partitionUuid;
            }
        }

        /// &lt;summary&gt;
        /// Initializes the partition sequences.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;partitionSequencesTable&quot;&gt;The partition sequences table.&lt;/param&gt;
        public void InitializeSequences(IList&lt;KeyValuePair&lt;string, IList&lt;KeyValuePair&lt;int, long&gt;&gt;&gt;&gt; partitionSequencesTable)
        {
            // received from server:
            // cache name -&gt; ( partition id -&gt; partition sequence ), (...), ...

            foreach (var (_, partitionSequences) in partitionSequencesTable)
            foreach (var (partitionId, partitionSequence) in partitionSequences)
            {
                var metadata = GetMetadata(partitionId);
                metadata.Sequence = partitionSequence;
            }
        }

        public override string ToString()
        {
            return $&quot;RepairingHandler{{name=&#39;{_nearCache.Name}&#39;, localUuid=&#39;{_clusterClientId}&#39;}}&quot;;
        }

        internal void FixSequenceGap()
        {
            if (IsAboveMaxToleratedMissCount())
            {
                UpdateLastKnownStaleSequences();
            }
        }

        private int GetPartitionIdOrDefault(IData key)
        {
            // `name` is used to determine partition ID of map-wide events like clear()
            // since key is `null`, we are using `name` to find the partition ID
            if (key == null) key = _serializationService.ToData(_nearCache.Name);
            return _partitioner.GetPartitionId(key.PartitionHash);
        }

        // Calculates number of missed invalidations and checks if repair is needed for the supplied handler.
        // Every handler represents a single Near Cache.
        private bool IsAboveMaxToleratedMissCount()
        {
            int partition = 0;
            long missCount = 0;
            do
            {
                var metaData = GetMetadata(partition);
                missCount += metaData.MissedSequenceCount;

                if (missCount &gt; _maxToleratedMissCount)
                {
                    _logger.IfDebug()?.LogDebug(&quot;Exceeded tolerated miss count (map={NearCacheName}, miss={MissCount}, max={MaxToleratedMissCount}).&quot;, _nearCache.Name, missCount, _maxToleratedMissCount);
                    return true;
                }
            } while (++partition &lt; _partitionCount);
            return false;
        }

        private void UpdateLastKnownStaleSequences()
        {
            foreach (var metaDataContainer in _metadataTable)
            {
                var missCount = metaDataContainer.MissedSequenceCount;
                if (metaDataContainer.MissedSequenceCount != 0)
                {
                    metaDataContainer.AddMissedSequences(-missCount);
                    metaDataContainer.UpdateStaleSequence();
                }
            }
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[47,9,47,200,1],[49,13,49,48,1],[50,13,50,36,1],[51,13,51,40,1],[52,13,52,49,1],[53,13,53,67,1],[54,13,54,60,1],[55,13,55,58,1],[56,13,56,70,1],[57,9,57,10,1],[68,13,68,36,1],[68,37,68,92,0],[70,13,70,53,1],[74,17,74,49,1],[77,17,77,49,1],[82,17,82,51,1],[86,17,86,43,1],[87,17,87,239,1],[92,9,92,10,1],[102,13,102,33,1],[102,34,102,93,0],[104,13,104,53,1],[108,17,108,57,1],[111,17,111,52,1],[116,17,116,76,1],[120,17,120,67,1],[121,17,121,58,1],[127,21,127,88,1],[128,21,128,81,1],[131,21,131,266,1],[137,9,137,10,1],[148,13,148,57,1],[149,18,149,37,1],[149,39,149,67,1],[149,69,149,82,1],[150,17,150,56,1],[151,13,151,29,1],[160,16,160,43,1],[175,13,175,65,1],[178,17,178,33,1],[179,21,179,40,1],[181,21,181,44,1],[184,13,184,60,1],[185,13,185,52,1],[186,13,186,58,1],[187,9,187,10,1],[199,22,199,79,0],[199,80,199,82,0],[199,83,199,150,0],[200,17,200,77,0],[201,9,201,10,0],[212,22,212,54,0],[212,55,212,57,0],[212,58,212,75,0],[214,17,214,57,0],[215,17,215,47,0],[217,9,217,10,0],[228,22,228,49,0],[228,50,228,52,0],[228,53,228,76,0],[229,22,229,58,0],[229,59,229,61,0],[229,62,229,80,0],[231,17,231,57,0],[232,17,232,55,0],[234,9,234,10,0],[238,13,238,100,0],[243,13,243,48,1],[245,17,245,49,0],[247,9,247,10,1],[253,13,253,29,1],[253,30,253,82,1],[254,13,254,67,1],[261,13,261,31,1],[262,13,262,32,1],[265,17,265,55,1],[266,17,266,59,1],[268,17,268,56,1],[270,21,270,204,0],[271,21,271,33,0],[273,15,273,53,1],[274,13,274,26,1],[279,22,279,43,0],[279,44,279,46,0],[279,47,279,61,0],[281,17,281,71,0],[282,17,282,64,0],[284,21,284,70,0],[285,21,285,61,0],[288,9,288,10,0]]);
    </script>
  </body>
</html>