<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Networking\AddressProvider.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using Hazelcast.Configuration;
using Hazelcast.Exceptions;
using Microsoft.Extensions.Logging;

namespace Hazelcast.Networking
{
    /// &lt;summary&gt;
    /// Provides addresses to connect to a cluster.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// &lt;para&gt;The addresses can either come from configuration, or from a discovery
    /// service such as the Cloud Discovery service. They can be retrieved, in order to
    /// establish the very first to the cluster, via &lt;see cref=&quot;GetAddresses&quot;/&gt;.&lt;/para&gt;
    /// &lt;para&gt;When using a discovery service, it may be that the members are only
    /// aware of their own internal address, but the discovery service knows that they
    /// can only be reached through their public address. In which case, the address
    /// provider also provides a map from internal to public. When receiving members
    /// through the members view event, this map can be used to assign public addresses
    /// to members.&lt;/para&gt;
    /// &lt;/remarks&gt;
    internal class AddressProvider
    {
        private IAddressProviderSource _source;
        private readonly ILogger _logger;

        // maps internal addresses to public addresses
        private IDictionary&lt;NetworkAddress, NetworkAddress&gt; _internalToPublicMap;

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;AddressProvider&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;networkingOptions&quot;&gt;The networking configuration.&lt;/param&gt;
        /// &lt;param name=&quot;loggerFactory&quot;&gt;A logger factory.&lt;/param&gt;
        public AddressProvider(IAddressProviderSource source, ILoggerFactory loggerFactory)
        {
            if (loggerFactory == null) throw new ArgumentNullException(nameof(loggerFactory));

            _source = source ?? throw new ArgumentNullException(nameof(source));
            _logger = loggerFactory.CreateLogger&lt;AddressProvider&gt;();
        }

        /// &lt;summary&gt;
        /// Obtains the &lt;see cref=&quot;IAddressProviderSource&quot;/&gt; as per configuration.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;networkingOptions&quot;&gt;The networking options.&lt;/param&gt;
        /// &lt;param name=&quot;loggerFactory&quot;&gt;A logger factory.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;IAddressProviderSource&quot;/&gt; corresponding the the configuration.&lt;/returns&gt;
        public static IAddressProviderSource GetSource(NetworkingOptions networkingOptions, ILoggerFactory loggerFactory)
        {
            if (networkingOptions.Cloud.Enabled)
            {
                if (networkingOptions.Addresses.Count &gt; 0)
                    throw new ConfigurationException(&quot;Only one address configuration method can be enabled at a time.&quot;);
                return new CloudAddressProviderSource(networkingOptions, loggerFactory);
            }

            return new ConfigurationAddressProviderSource(networkingOptions, loggerFactory);
        }

        /// &lt;summary&gt;
        /// Whether the address provider has a map of internal addresses to public addresses.
        /// &lt;/summary&gt;
        public bool HasMap =&gt; _source.Maps;

        // ensures that we have a map, returns the map + whether it&#39;s a new map
        private (bool NewMap, IDictionary&lt;NetworkAddress, NetworkAddress&gt; Map) EnsureMap(bool forceRenew)
        {
            if (!forceRenew &amp;&amp; _internalToPublicMap != null) return (false, _internalToPublicMap);
            _internalToPublicMap = _source.CreateInternalToPublicMap() ?? throw new HazelcastException(&quot;Failed to obtain addresses.&quot;);
            return (true, _internalToPublicMap);
        }

        /// &lt;summary&gt;
        /// Gets known possible addresses for a cluster.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;All addresses.&lt;/returns&gt;
        public IEnumerable&lt;NetworkAddress&gt; GetAddresses() =&gt; EnsureMap(true).Map.Values;

        /// &lt;summary&gt;
        /// Gets &lt;see cref=&quot;IAddressProviderSource&quot;/&gt;
        /// &lt;/summary&gt;
        public IAddressProviderSource AddressProviderSource
        {
            get =&gt; _source;
            internal set { 
                _source = value;
                EnsureMap(true);
            }
        }

        /// &lt;summary&gt;
        /// Maps an internal address to a public address.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;address&quot;&gt;The private address.&lt;/param&gt;
        /// &lt;returns&gt;The public address, or null if no address was found.&lt;/returns&gt;
        public NetworkAddress Map(NetworkAddress address)
        {
            if (address == null || !HasMap)
                return address;

            var (fresh, map) = EnsureMap(false);

            // if we can map, return
            if (map.TryGetValue(address, out var publicAddress))
                return publicAddress;

            if (fresh)
            {
                // if we just created the map, no point re-creating it
                _logger.LogDebug($&quot;Address {address} was not found in the map.&quot;);
                return null;
            }

            // otherwise, re-scan
            _logger.LogDebug($&quot;Address {address} was not found in the map, re-scanning.&quot;);

            // if the map is not &#39;fresh&#39; force-recreate the map and try again, else give up
            // TODO: throttle?
            map = EnsureMap(true).Map;

            // now try again
            if (map.TryGetValue(address, out publicAddress))
                return publicAddress;

            _logger.LogDebug($&quot;Address {address} was not found in the map.&quot;);
            return null;
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[50,9,50,92,1],[52,13,52,39,1],[52,40,52,95,1],[54,13,54,81,1],[55,13,55,69,1],[56,9,56,10,1],[66,13,66,49,1],[68,17,68,59,1],[69,21,69,121,1],[70,17,70,89,0],[73,13,73,93,1],[79,31,79,43,1],[84,13,84,61,1],[84,62,84,99,1],[85,13,85,135,1],[86,13,86,49,1],[93,62,93,88,1],[100,20,100,27,0],[102,17,102,33,1],[103,17,103,33,1],[104,13,104,14,1],[114,13,114,44,1],[115,17,115,32,1],[117,13,117,49,1],[120,13,120,65,1],[121,17,121,38,1],[123,13,123,23,1],[126,17,126,82,1],[127,17,127,29,1],[131,13,131,91,1],[135,13,135,39,1],[138,13,138,61,1],[139,17,139,38,0],[141,13,141,78,1],[142,13,142,25,1]]);
    </script>
  </body>
</html>