<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Core\AsyncQueue.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace Hazelcast.Core
{
    /// &lt;summary&gt;
    /// Provides a lightweight asynchronous queue for multiple providers,
    /// and one single sequential consumer.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;T&quot;&gt;The type of the items.&lt;/typeparam&gt;
    internal sealed class AsyncQueue&lt;T&gt; : IAsyncEnumerable&lt;T&gt;
    {
        private readonly ConcurrentQueue&lt;T&gt; _items = new ConcurrentQueue&lt;T&gt;();
        private readonly object _lock = new object();
        private TaskCompletionSource&lt;bool&gt; _waiting;
        private CancellationTokenRegistration _reg;
        private T _current;
        private bool _completed;

        /// &lt;summary&gt;
        /// (internals for tests only) Gets the count of items in the queue.
        /// &lt;/summary&gt;
        internal int Count =&gt; _items.Count;

        /// &lt;summary&gt;
        /// Tries to write an item to the queue.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;item&quot;&gt;The item.&lt;/param&gt;
        /// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt; if the item was written; otherwise (the queue is complete) &lt;c&gt;false&lt;/c&gt;.&lt;/returns&gt;
        public bool TryWrite(T item)
        {
            TaskCompletionSource&lt;bool&gt; waiting = null;

            // lock writes
            lock (_lock)
            {
                if (_completed) return false;

                if (_waiting == null)
                {
                    // if not waiting for an item, just enqueue it
                    _items.Enqueue(item);
                }
                else
                {
                    // if waiting for an item, make the item the current item
                    // and succeed the wait
                    _current = item;
                    waiting = _waiting;
                    _waiting = null;
                    _reg.Dispose();
                }
            }

            waiting?.TrySetResult(true);
            return true;
        }

        /// &lt;summary&gt;
        /// Completes the queue.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;The queue keeps providing its items for reading, but it is not possible to write items anymore.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public void Complete()
        {
            TaskCompletionSource&lt;bool&gt; waiting;

            // lock writes
            lock (_lock)
            {
                _completed = true;
                waiting = _waiting;
                _waiting = null;
                _reg.Dispose();
            }

            // in case we were waiting, fail the wait
            waiting?.TrySetResult(false);
        }

        /// &lt;summary&gt;
        /// Applies an action to each item in the queue (see notes in method).
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;action&quot;&gt;The action to apply.&lt;/param&gt;
        public void ForEach(Action&lt;T&gt; action)
        {
            // this is a &quot;best effort&quot; approach: items can be queued after we take the snapshot of the queue,
            // and they won&#39;t be processed, and items can be de-queued before we take the snapshot of the queue,
            // and they won&#39;t be processed either, so ... we just do our best ... this is used to cancel some
            // member connection requests, and if a request fails to cancel and goes through and we connect to
            // the member, the connection will simply be rejected and discarded.

            var current = _current;
            foreach (var item in _items) // snapshot items and run the action
                action(item);
            if (current != null) // also run the action on whatever was the &quot;current&quot; item
                action(current);
        }

        // there is going to be only 1 reader pumping items out and processing them
        // sequentially, so if we enter this method and the queue is empty and we
        // return a task, we are not going to enter this method again until that task
        // has completed - in other words, there can only be one _waiting at a time

        /// &lt;summary&gt;
        /// Waits for an item to become available.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;A cancellation token.&lt;/param&gt;
        /// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt; if an item is available; otherwise (the queue is complete) &lt;c&gt;false&lt;/c&gt;.&lt;/returns&gt;
        public ValueTask&lt;bool&gt; WaitAsync(CancellationToken cancellationToken = default)
        {
            // if there is an item in the queue, return it immediately and synchronously
            if (_items.TryDequeue(out _current))
                return new ValueTask&lt;bool&gt;(true);

            // else, lock writes
            lock (_lock)
            {
                // (again)
                if (_items.TryDequeue(out _current))
                    return new ValueTask&lt;bool&gt;(true);

                // if completed, fail
                if (_completed)
                    return new ValueTask&lt;bool&gt;(false);

                // create the waiting task
                _waiting = new TaskCompletionSource&lt;bool&gt;();
                _reg = cancellationToken.Register(() =&gt; _waiting.TrySetCanceled());
                return new ValueTask&lt;bool&gt;(_waiting.Task);
            }
        }

        /// &lt;summary&gt;
        /// Reads the last available item.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;The last available item, if any, or &lt;c&gt;default(T)&lt;/c&gt;.&lt;/returns&gt;
        public T Read()
        {
            return _current;
        }

        // ---- IAsyncEnumerable ----

        /// &lt;inheritdoc /&gt;
        public IAsyncEnumerator&lt;T&gt; GetAsyncEnumerator(CancellationToken cancellationToken = default)
            =&gt; new AsyncEnumerator(this, cancellationToken);

        // ---- IAsyncEnumerator ----

        private class AsyncEnumerator : IAsyncEnumerator&lt;T&gt;
        {
            private readonly AsyncQueue&lt;T&gt; _queue;
            private readonly CancellationToken _cancellationToken;

            public AsyncEnumerator(AsyncQueue&lt;T&gt; queue, CancellationToken cancellationToken)
            {
                _queue = queue;
                _cancellationToken = cancellationToken;
            }

            /// &lt;inheritdoc /&gt;
            public ValueTask&lt;bool&gt; MoveNextAsync() =&gt; _queue.WaitAsync(_cancellationToken);

            /// &lt;inheritdoc /&gt;
            public T Current =&gt; _queue._current;

            /// &lt;inheritdoc /&gt;
            public ValueTask DisposeAsync() =&gt; default;
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[30,9,30,79,1],[31,9,31,54,1],[40,31,40,43,1],[49,13,49,55,1],[52,13,52,25,1],[54,17,54,32,1],[54,33,54,46,1],[56,17,56,38,1],[59,21,59,42,1],[65,21,65,37,1],[66,21,66,40,1],[67,21,67,37,1],[68,21,68,36,1],[70,13,70,14,1],[72,13,72,41,1],[73,13,73,25,1],[74,9,74,10,1],[87,13,87,25,1],[89,17,89,35,1],[90,17,90,36,1],[91,17,91,33,1],[92,17,92,32,1],[93,13,93,14,1],[96,13,96,42,1],[97,9,97,10,1],[111,13,111,36,1],[112,22,112,30,1],[112,31,112,33,1],[112,34,112,40,1],[113,17,113,30,1],[114,13,114,33,1],[115,17,115,33,1],[116,9,116,10,1],[131,13,131,49,1],[132,17,132,50,1],[135,13,135,25,1],[138,17,138,53,1],[139,21,139,54,0],[142,17,142,32,1],[143,21,143,55,1],[146,17,146,61,1],[147,17,147,57,1],[147,57,147,82,1],[147,82,147,84,1],[148,17,148,59,1],[150,9,150,10,1],[158,13,158,29,1],[165,16,165,60,1],[174,13,174,93,1],[176,17,176,32,1],[177,17,177,56,1],[178,13,178,14,1],[181,55,181,91,1],[184,33,184,48,1],[187,48,187,55,1]]);
    </script>
  </body>
</html>