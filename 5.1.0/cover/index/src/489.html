<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Networking\ConnectAddressResolver.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Hazelcast.Core;
using Hazelcast.Models;
using Microsoft.Extensions.Logging;

namespace Hazelcast.Networking
{
    /// &lt;summary&gt;
    /// Resolves connect addresses for members by determining whether to use internal or public addresses.
    /// &lt;/summary&gt;
    internal class ConnectAddressResolver
    {
        private readonly NetworkingOptions _options;
        private readonly ILogger _logger;

        public ConnectAddressResolver(NetworkingOptions options, ILoggerFactory loggerFactory)
        {
            _options = options;
            _logger = loggerFactory.CreateLogger&lt;ConnectAddressResolver&gt;();
        }

        /// &lt;summary&gt;
        /// Determines whether to use public addresses.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;members&quot;&gt;A collection of members.&lt;/param&gt;
        /// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt; if public addresses must be used; otherwise &lt;c&gt;false&lt;/c&gt;, indicating that internal addresses can be used.&lt;/returns&gt;
        public async Task&lt;bool&gt; DetermineUsePublicAddresses(IReadOnlyCollection&lt;MemberInfo&gt; members)
        {
            // if the user has specified its intention, respect it, otherwise try to decide
            // automatically whether to use private or public addresses by trying to reach
            // a few members

            if (_options.UsePublicAddresses is {} usePublicAddresses)
            {
                _logger.IfDebug()?.LogDebug(usePublicAddresses
                    ? &quot;NetworkingOptions.UsePublicAddresses is true, use public addresses.&quot;
                    : &quot;NetworkingOptions.UsePublicAddresses is false, use internal addresses.&quot;);

                return usePublicAddresses;
            }

            _logger.IfDebug()?.LogDebug(&quot;NetworkingOptions.UsePublicAddresses is not set, decide by ourselves.&quot;);

            // if ssl is enabled, then the client uses internal addresses
            if (_options.Ssl.Enabled)
            {
                _logger.IfDebug()?.LogDebug(&quot;Ssl is enabled, use internal addresses.&quot;);

                return false;
            }

            if (_logger.IsEnabled(LogLevel.Debug))
            {
                var text = new StringBuilder();
                text.Append(&quot;Members [&quot;);
                text.Append(members.Count);
                text.Append(&quot;] {&quot;);
                text.AppendLine();
                foreach (var member in members)
                {
                    text.Append(&quot;    &quot;);
                    text.Append(member.ToShortString(false));
                    text.AppendLine();
                    foreach (var entry in member.AddressMap)
                    {
                        text.Append(&quot;        &quot;);
                        text.Append(entry.Key);
                        text.Append(&quot;: &quot;);
                        text.Append(entry.Value);
                        text.AppendLine();
                    }
                }
                text.Append(&#39;}&#39;);
                _logger.IfDebug()?.LogDebug(text.ToString());
            }

            // if at least one member has its internal address that matches options, assume we can use internal addresses
            if (DetermineAnyMemberInternalAddressMatchesOptions(members))
            {
                _logger.IfDebug()?.LogDebug(&quot;At least one member&#39;s internal address matches options, assume that the client can use internal addresses.&quot;);
                return false;
            }

            // if one member does not have a public address, then the client has to use internal addresses
            if (members.Any(x =&gt; x.PublicAddress is null))
            {
                _logger.IfDebug()?.LogDebug(&quot;At least one member does not have a public address, use internal addresses.&quot;);

                return false;
            }

            // else try to reach addresses to figure out which ones to use
            return await DeterminePublicAddressesAreRequired(members).CfAwait();
        }

        // determines whether at least one member has its internal address specified in options,
        // which would mean that the client can reach the configured addresses and we can use
        // internal addresses
        private bool DetermineAnyMemberInternalAddressMatchesOptions(IReadOnlyCollection&lt;MemberInfo&gt; members)
        {
            // both NodeJS and Java code plainly ignore ports and only focus on the host name

            var optionHosts = _options.Addresses
                .Select(x =&gt; NetworkAddress.TryParse(x, out var a) ? a : null)
                .Where(x =&gt; x != null)
                .Select(x =&gt; x.HostName);

            var memberHosts = members.Select(x =&gt; x.Address.HostName);

            return memberHosts.Intersect(optionHosts).Any();
        }

        // determines whether using public addresses is required
        // by testing a subset of all members
        private Task&lt;bool&gt; DeterminePublicAddressesAreRequired(IReadOnlyCollection&lt;MemberInfo&gt; members)
            =&gt; DeterminePublicAddressesAreRequired(members.Shuffle(), _options.AddressResolver_SampleSize);

        // determines whether using public addresses is required
        private async Task&lt;bool&gt; DeterminePublicAddressesAreRequired(IReadOnlyCollection&lt;MemberInfo&gt; members, int sampleCount)
        {
            var count = 0;
            var requirePublic = false;

            foreach (var member in members)
            {
                // we failed to find a member that can be reached at its internal address, but enough members can
                // be reached at their public addresses, so assume public addresses are required for all
                if (count++ == sampleCount &amp;&amp; requirePublic)
                {
                    _logger.IfDebug()?.LogDebug(&quot;At least {Count} members only respond on their public address, the client has to use public addresses.&quot;, sampleCount);

                    return true;
                }

                var canReachInternal = await member.Address.TryReachAsync(_options.AddressResolver_InternalAddressTryReachTimeout).CfAwait();

                // if one member can be reached at its internal address then assume internal addresses are ok for all
                if (canReachInternal)
                {
                    _logger.IfDebug()?.LogDebug(&quot;Member {Member} responds on its internal address, assume that the client can use internal addresses.&quot;, member.Address);

                    return false;
                }

                var canReachPublic = await member.PublicAddress.TryReachAsync(_options.AddressResolver_PublicAddressTryReachTimeout).CfAwait();

                // if the member cannot be reached at its internal address but can be reached at its public address,
                // this would indicate that the client has to use public addresses, but we are going to try a few
                // more members just to be sure - maybe the failure to reach the internal address was a glitch and
                // another member will make it
                if (canReachPublic)
                {
                    _logger.IfDebug()?.LogDebug(&quot;Member {Member} does not respond on its internal address, responds on its public address.&quot;, member.Address, member.PublicAddress);

                    requirePublic = true;
                }

                // otherwise, the client cannot be reached at all - both NodeJS and Java immediately return false,
                // but really - this could very well be a glitch and we should probably try a few more members
            }

            // we failed to find a member that can be reached at its internal address, but members can be reached at
            // their public addresses, so assume public addresses are required for all
            if (requirePublic)
            {
                _logger.IfDebug()?.LogDebug(&quot;Members can only be reached at their public address, the client has to use public addresses.&quot;);
                return true;
            }

            // otherwise, we tested all members and could not reach any or them, neither on internal nor on public address,
            // and this is a sad situation indeed - we&#39;re going to go with internal addresses but... something is wrong
            _logger.IfDebug()?.LogDebug(&quot;Could not connect to any member. Assume the client can use internal addresses.&quot;);
            return false;
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[33,9,33,95,1],[35,13,35,32,1],[36,13,36,76,1],[37,9,37,10,1],[50,13,50,70,1],[52,17,54,97,1],[56,17,56,43,1],[59,13,59,114,1],[62,13,62,38,1],[64,17,64,88,1],[66,17,66,30,1],[69,13,69,51,1],[71,17,71,48,1],[72,17,72,42,1],[73,17,73,44,1],[74,17,74,36,1],[75,17,75,35,1],[76,26,76,36,1],[76,37,76,39,1],[76,40,76,47,1],[78,21,78,41,1],[79,21,79,62,1],[80,21,80,39,1],[81,30,81,39,1],[81,40,81,42,1],[81,43,81,60,1],[83,25,83,49,1],[84,25,84,48,1],[85,25,85,43,1],[86,25,86,50,1],[87,25,87,43,1],[90,17,90,34,1],[91,17,91,62,1],[95,13,95,74,1],[97,17,97,155,1],[98,17,98,30,1],[102,13,102,59,1],[102,34,102,57,1],[104,17,104,124,1],[106,17,106,30,1],[110,13,110,81,0],[111,9,111,10,1],[120,13,121,30,1],[121,30,121,78,1],[121,78,122,29,1],[122,29,122,38,1],[122,38,123,30,1],[123,30,123,40,1],[123,40,123,42,1],[125,13,125,51,1],[125,51,125,69,1],[125,69,125,71,1],[127,13,127,61,1],[133,16,133,107,0],[138,13,138,27,0],[139,13,139,39,0],[141,22,141,32,0],[141,33,141,35,0],[141,36,141,43,0],[145,17,145,61,0],[147,21,147,168,0],[149,21,149,33,0],[152,17,152,142,0],[155,17,155,38,0],[157,21,157,169,0],[159,21,159,34,0],[162,17,162,144,0],[168,17,168,36,0],[170,21,170,180,0],[172,21,172,42,0],[177,13,177,14,0],[181,13,181,31,0],[183,17,183,141,0],[184,17,184,29,0],[189,13,189,123,0],[190,13,190,26,0],[191,9,191,10,0]]);
    </script>
  </body>
</html>