<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Clustering\MemberConnection.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Concurrent;
using System.Net;
using System.Threading;
using System.Threading.Tasks;
using Hazelcast.Core;
using Hazelcast.Exceptions;
using Hazelcast.Messaging;
using Hazelcast.Models;
using Hazelcast.Networking;
using Hazelcast.Protocol;
using Microsoft.Extensions.Logging;

namespace Hazelcast.Clustering
{
    // NOTES
    //
    // older versions of the code had a background task that would check every invocation
    // and terminate them if their attached client was not alive anymore - but really that
    // should be taken care of by the OnShutdown handler when the socket goes down.
    //
    // also, every invocation has a timeout by default, so unless users set an absurdly
    // long timeout, invocations *will* be collected eventually and we do not leak.

    /// &lt;summary&gt;
    /// Represents a connection to a cluster member.
    /// &lt;/summary&gt;
    internal class MemberConnection : IAsyncDisposable
    {
        internal static readonly byte[] ClientProtocolInitBytes = { 67, 80, 50 }; //&quot;CP2&quot;;

        private readonly ConcurrentDictionary&lt;long, Invocation&gt; _invocations = new ConcurrentDictionary&lt;long, Invocation&gt;();

        private readonly Authenticator _authenticator;
        private readonly MessagingOptions _messagingOptions;
        private readonly NetworkingOptions _networkingOptions;
        private readonly SslOptions _sslOptions;
        private readonly ISequence&lt;long&gt; _correlationIdSequence;
        private readonly ILoggerFactory _loggerFactory;
        private readonly ILogger _logger;

        private bool _readonlyProperties; // whether some properties (_onXxx) are readonly
        private Action&lt;ClientMessage&gt; _receivedEvent;
        private Func&lt;MemberConnection, ValueTask&gt; _closed;

        private ClientSocketConnection _socketConnection;
        private ClientMessageConnection _messageConnection;

        private readonly object _mutex = new object();
        private volatile bool _disposed;
        private volatile bool _active;

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;MemberConnection&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;address&quot;&gt;The network address.&lt;/param&gt;
        /// &lt;param name=&quot;authenticator&quot;&gt;The authenticator.&lt;/param&gt;
        /// &lt;param name=&quot;messagingOptions&quot;&gt;Messaging options.&lt;/param&gt;
        /// &lt;param name=&quot;networkingOptions&quot;&gt;Networking options.&lt;/param&gt;
        /// &lt;param name=&quot;sslOptions&quot;&gt;SSL options.&lt;/param&gt;
        /// &lt;param name=&quot;correlationIdSequence&quot;&gt;A sequence of unique correlation identifiers.&lt;/param&gt;
        /// &lt;param name=&quot;loggerFactory&quot;&gt;A logger factory.&lt;/param&gt;
        public MemberConnection(NetworkAddress address, Authenticator authenticator, MessagingOptions messagingOptions, NetworkingOptions networkingOptions, SslOptions sslOptions, ISequence&lt;long&gt; correlationIdSequence, ILoggerFactory loggerFactory)
        {
            Address = address ?? throw new ArgumentNullException(nameof(address));
            _authenticator = authenticator ?? throw new ArgumentNullException(nameof(authenticator));
            _messagingOptions = messagingOptions ?? throw new ArgumentNullException(nameof(messagingOptions));
            _networkingOptions = networkingOptions ?? throw new ArgumentNullException(nameof(networkingOptions));
            _sslOptions = sslOptions ?? throw new ArgumentNullException(nameof(sslOptions));
            _correlationIdSequence = correlationIdSequence ?? throw new ArgumentNullException(nameof(correlationIdSequence));
            _loggerFactory = loggerFactory ?? throw new ArgumentNullException(nameof(loggerFactory));
            _logger = loggerFactory.CreateLogger&lt;MemberConnection&gt;();

            HConsole.Configure(x =&gt; x.Configure&lt;MemberConnection&gt;().SetIndent(4).SetPrefix(&quot;MBR.CONN&quot;));
        }

        #region Events

        /// &lt;summary&gt;
        /// Gets or sets an action that will be executed when the connection receives an event message.
        /// &lt;/summary&gt;
        public Action&lt;ClientMessage&gt; ReceivedEvent
        {
            get =&gt; _receivedEvent;
            set
            {
                if (_readonlyProperties)
                    throw new InvalidOperationException(ExceptionMessages.PropertyIsNowReadOnly);
                _receivedEvent = value;
            }
        }

        /// &lt;summary&gt;
        /// Gets or sets an action that will be executed when the connection has closed.
        /// &lt;/summary&gt;
        public Func&lt;MemberConnection, ValueTask&gt; Closed
        {
            get =&gt; _closed;
            set
            {
                if (_readonlyProperties)
                    throw new InvalidOperationException(ExceptionMessages.PropertyIsNowReadOnly);
                _closed = value;
            }
        }

        #endregion

        /// &lt;summary&gt;
        /// Gets the unique identifier of this connection.
        /// &lt;/summary&gt;
        public Guid Id { get; } = Guid.NewGuid();

        /// &lt;summary&gt;
        /// Whether the connection is active.
        /// &lt;/summary&gt;
        public bool Active =&gt; _active;

        /// &lt;summary&gt;
        /// Gets the unique identifier of the cluster member that this connection is connected to.
        /// &lt;/summary&gt;
        public Guid MemberId { get; private set; }

        /// &lt;summary&gt;
        /// Gets the unique identifier of the cluster that this connection is connected to.
        /// &lt;/summary&gt;
        public Guid ClusterId { get; private set; }

        /// &lt;summary&gt;
        /// Gets the network address the client is connected to.
        /// &lt;/summary&gt;
        public NetworkAddress Address { get; }

        /// &lt;summary&gt;
        /// Gets the local endpoint of the socket connection.
        /// &lt;/summary&gt;
        public IPEndPoint LocalEndPoint =&gt; _socketConnection.LocalEndPoint;

        /// &lt;summary&gt;
        /// Gets the authentication principal.
        /// &lt;/summary&gt;
        public string Principal { get; private set; }

        /// &lt;summary&gt;
        /// Gets the date and time when the connection was established.
        /// &lt;/summary&gt;
        public DateTimeOffset ConnectTime { get; private set; }

        /// &lt;summary&gt;
        /// Gets the date and time when bytes where last read by the client.
        /// &lt;/summary&gt;
        public DateTime LastReadTime =&gt; _socketConnection?.LastReadTime ?? DateTime.MinValue;

        /// &lt;summary&gt;
        /// Gets the date and time when bytes where last written by the client.
        /// &lt;/summary&gt;
        public DateTime LastWriteTime =&gt; _socketConnection?.LastWriteTime ?? DateTime.MinValue;

        /// &lt;summary&gt;
        /// Connects the client to the server.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;clusterState&quot;&gt;The cluster state.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;A cancellation token.&lt;/param&gt;
        /// &lt;returns&gt;A task that will complete when the client is connected.&lt;/returns&gt;
        public async ValueTask&lt;AuthenticationResult&gt; ConnectAsync(ClusterState clusterState, CancellationToken cancellationToken)
        {
            // as soon as we even try to connect, some properties cannot change anymore
            _readonlyProperties = true;

            // MessageConnection is just a wrapper around a true SocketConnection, and
            // the SocketConnection must be open *after* everything has been wired

            _socketConnection = new ClientSocketConnection(Id, Address.IPEndPoint, _networkingOptions, _sslOptions, _loggerFactory)
                { OnShutdown = OnSocketShutdown };

            _messageConnection = new ClientMessageConnection(_socketConnection, _loggerFactory)
                { OnReceiveMessage = ReceiveMessage };

            HConsole.Configure(x =&gt; x.Configure(_messageConnection).SetIndent(8).SetPrefix($&quot;CLT.MSG [{Id.ToShortString()}]&quot;));

            AuthenticationResult result;
            try
            {
                // connect
                await _socketConnection.ConnectAsync(cancellationToken).CfAwait();
                _logger.IfDebug()?.LogDebug($&quot;Established {(_sslOptions.Enabled?&quot;SSL &quot;:&quot;&quot;)}connection {Id.ToShortString()} to {Address}.&quot;);

                // send protocol bytes
                var sent = await _socketConnection.SendAsync(ClientProtocolInitBytes, ClientProtocolInitBytes.Length, cancellationToken).CfAwait();
                if (!sent) throw new ConnectionException(&quot;Failed to send protocol bytes.&quot;);

                // authenticate (does not return null, throws if it fails to authenticate)
                result = await _authenticator
                    .AuthenticateAsync(this, clusterState.ClusterName, clusterState.ClientId, clusterState.ClientName, clusterState.Options.Labels, cancellationToken)
                    .CfAwait();
            }
            catch
            {
                lock (_mutex) _disposed = true;
                await DisposeInnerConnectionAsync().CfAwait();
                throw;
            }

            MemberId = result.MemberId;
            ClusterId = result.ClusterId;
            ConnectTime = DateTimeOffset.Now;
            Principal = result.Principal;

            bool disposed;
            lock (_mutex)
            {
                disposed = _disposed;
                _active = !_disposed;
            }

            if (disposed)
            {
                await DisposeInnerConnectionAsync().CfAwait();
                throw new ConnectionException(&quot;Failed to connect.&quot;);
            }

            return result;
        }

        /// &lt;summary&gt;
        /// Handles connection shutdown.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;connection&quot;&gt;The connection.&lt;/param&gt;
        /// &lt;returns&gt;A task that will complete when the shutdown has been handled.&lt;/returns&gt;
#pragma warning disable IDE0079 // Remove unnecessary suppression - false positive ?!
#pragma warning disable CA1801 // Parameter is never used.
        private async ValueTask OnSocketShutdown(SocketConnectionBase connection)
#pragma warning restore CA1801
#pragma warning restore IDE0079
        {
            await DisposeAsync().CfAwait();
        }

        /// &lt;summary&gt;
        /// Handles messages.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;connection&quot;&gt;The connection.&lt;/param&gt;
        /// &lt;param name=&quot;message&quot;&gt;The message.&lt;/param&gt;
        /// &lt;returns&gt;A task that will complete when the message has been handled.&lt;/returns&gt;
#pragma warning disable IDE0079 // Remove unnecessary suppression - false positive ?!
#pragma warning disable CA1801 // Parameter is never used.
        private void ReceiveMessage(ClientMessageConnection connection, ClientMessage message)
#pragma warning restore CA1801
#pragma warning restore IDE0079
        {
            // proceed, regardless of _active, because why not?

            if (message.IsEvent)
            {
                HConsole.WriteLine(this, $&quot;Receive event {Id.ToShortString()}:{message.CorrelationId}&quot; +
                                         HConsole.Lines(this, 2, message.Dump(HConsole.Level(this))));
                ReceiveEvent(message); // should not throw
                return;
            }

            if (message.IsBackupEvent)
            {
                HConsole.WriteLine(this, $&quot;Receive backup event {Id.ToShortString()}:{message.CorrelationId}&quot; +
                                         HConsole.Lines(this, 2, message.Dump(HConsole.Level(this))));

                // backup events are not supported
                _logger.LogWarning(&quot;Ignoring unsupported backup event.&quot;);
                return;
            }

            // message has to be a response
            HConsole.WriteLine(this, $&quot;Receive response {Id.ToShortString()}:{message.CorrelationId} from {MemberId.ToShortString()} at {Address}&quot; +
                                     HConsole.Lines(this, 2, message.Dump(HConsole.Level(this))));

            // find the corresponding invocation
            // and remove invocation
            if (!_invocations.TryRemove(message.CorrelationId, out var invocation))
            {
                // orphan messages are ignored (but logged)
                _logger.LogWarning($&quot;Received message for unknown invocation {Id.ToShortString()}:{message.CorrelationId}.&quot;);
                HConsole.WriteLine(this, $&quot;Unknown invocation {Id.ToShortString()}:{message.CorrelationId}&quot;);
                return;
            }

            // receive exception or message
            if (message.IsException)
                ReceiveException(invocation, message); // should not throw
            else
                ReceiveResponse(invocation, message); // should not throw
        }

        // ReceiveMessage -&gt; event message
        private void ReceiveEvent(ClientMessage message)
        {
            try
            {
                HConsole.WriteLine(this, $&quot;Raise event {Id.ToShortString()}:{message.CorrelationId}&quot;);
                _receivedEvent(message);
            }
            catch (Exception e)
            {
                // _onReceiveEventMessage should just queue the event and not fail - if it fails
                // then some nasty internal error is happening - log, at least, make some noise

                _logger.LogWarning(e, $&quot;Failed to raise event {Id.ToShortString()}:{message.CorrelationId}.&quot;);
            }
        }

        // ReceiveMessage -&gt; exception message
        private void ReceiveException(Invocation invocation, ClientMessage message)
        {
            Exception exception;
            try
            {
                exception = RemoteExceptions.CreateException(MemberId, ErrorsCodec.Decode(message));
            }
            catch (Exception e)
            {
                exception = e;
            }

            HConsole.WriteLine(this, $&quot;Fail invocation {Id.ToShortString()}:{message.CorrelationId}&quot;);
            invocation.TrySetException(exception);
        }

        // ReceiveMessage -&gt; response message
        private void ReceiveResponse(Invocation invocation, ClientMessage message)
        {
            HConsole.WriteLine(this, $&quot;Complete invocation {Id.ToShortString()}:{message.CorrelationId}&quot;);

            // returns immediately, releases the invocation task
            invocation.TrySetResult(message);
        }

        /// &lt;summary&gt;
        /// Sends a message.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;message&quot;&gt;The message.&lt;/param&gt;
        /// &lt;returns&gt;A task that will complete when the response has been received, and represents the response.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;The operation must complete within the default operation timeout specified by the networking options.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public async Task&lt;ClientMessage&gt; SendAsync(ClientMessage message)
        {
            if (message == null) throw new ArgumentNullException(nameof(message));

            // assign a unique identifier to the message
            // and send in one fragment, with proper flags
            message.CorrelationId = _correlationIdSequence.GetNext();
            message.Flags |= ClientMessageFlags.BeginFragment | ClientMessageFlags.EndFragment;

            // create the invocation
            var invocation = new Invocation(message, _messagingOptions, this);

            // and send
            return await SendAsync(invocation).CfAwait();
        }

        /// &lt;summary&gt;
        /// Sends an invocation message.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;invocation&quot;&gt;The invocation.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;A cancellation token.&lt;/param&gt;
        /// &lt;returns&gt;A task that will complete when the response has been received, and represents the response.&lt;/returns&gt;
        public Task&lt;ClientMessage&gt; SendAsync(Invocation invocation, CancellationToken cancellationToken = default)
        {
            return SendAsyncInternal(invocation, cancellationToken);
        }

        private async Task&lt;ClientMessage&gt; SendAsyncInternal(Invocation invocation, CancellationToken cancellationToken)
        {
            if (invocation == null) throw new ArgumentNullException(nameof(invocation));

            // _active     false ----&gt; true ----&gt; false
            // _disposed   false            ----&gt; true
            //             ^--------------^
            //               here, ok to send messages, either active, or connecting

            // adds the invocation, so that it can be completed as soon as the response is received
            // it will be removed when receiving the response (or error or timeout or...)
            lock (_mutex)
            {
                if (_disposed) throw new TargetDisconnectedException();
                _invocations[invocation.CorrelationId] = invocation;
            }

            HConsole.WriteLine(this, $&quot;Send message {Id.ToShortString()}:{invocation.CorrelationId} to {MemberId.ToShortString()} at {Address}&quot; +
                                     HConsole.Lines(this, 1, invocation.RequestMessage.Dump(HConsole.Level(this))));

            // actually send the message
            bool success;
            Exception captured = null;
            try
            {
                success = await _messageConnection.SendAsync(invocation.RequestMessage, cancellationToken).CfAwait();
            }
            catch (Exception e)
            {
                HConsole.WriteLine(this, &quot;Exception while sending: &quot; + e);
                captured = e;
                _invocations.TryRemove(invocation.CorrelationId, out _);
                if (_active) throw; // if not active, better throw a disconnected exception below
                success = false;
            }

            if (!success)
            {
                _invocations.TryRemove(invocation.CorrelationId, out _);
                HConsole.WriteLine(this, &quot;Failed to send a message.&quot;);

                if (!_active)
                    throw new TargetDisconnectedException();

                // TODO: we need a better exception
                throw new TargetUnreachableException(captured);
            }

            // now wait for the response
            HConsole.WriteLine(this, &quot;Wait for response...&quot;);

            try
            {
                // propagate the cancellationToken to the invocation
#if !NETSTANDARD2_0
                await
#endif
                using var reg = cancellationToken.Register(invocation.TrySetCanceled);

                var response = await invocation.Task.CfAwait();
                HConsole.WriteLine(this, &quot;Received response&quot;);
                return response;
            }
            catch (Exception e)
            {
                HConsole.WriteLine(this, $&quot;Failed ({e})&quot;);
                _invocations.TryRemove(invocation.CorrelationId, out _);
                throw;
            }
        }

        /// &lt;inheritdoc /&gt;
        public async ValueTask DisposeAsync()
        {
            // note: DisposeAsync should not throw (CA1065)

            bool active;
            lock (_mutex)
            {
                if (_disposed) return;
                _disposed = true;
                active = _active;
                _active = false;
            }

            try
            {
                // if we were connected, we need to trigger the closed event
                if (active) await _closed.AwaitEach(this).CfAwait(); // may throw, never knows
            }
            catch (Exception e)
            {
                _logger.LogWarning(e, &quot;Caught an exception while raising Closed.&quot;);
            }

            // if if we were not yet active / connected, we might have ONE invocation
            // pending: the authentication one - it is important to abort it too

            // capture all invocations, _disposed is true so no new invocation can be
            // accepted, and if one invocation completes, TrySetException will just do
            // nothing
            var invocations = _invocations.Values;
            foreach (var invocation in invocations)
                invocation.TrySetException(new TargetDisconnectedException()); // does not throw

            // ConnectAsync would deal with the situation
            if (!active) return;

            // then kill our inner connection
            await DisposeInnerConnectionAsync().CfAwait();

            _logger.LogDebug($&quot;Connection {Id.ToShortString()} closed and disposed.&quot;);

#pragma warning disable CA1816 // Dispose methods should call SuppressFinalize - DisposeAsync too!
            GC.SuppressFinalize(this);
#pragma warning restore CA1816
        }

        private async Task DisposeInnerConnectionAsync()
        {
            // tear down inner connections
            if (_messageConnection != null) // also disposes the socket connection
                await _messageConnection.DisposeAsync().CfAwait(); // does not throw
            else if (_socketConnection != null)
                await _socketConnection.DisposeAsync().CfAwait(); // does not throw

            _messageConnection = null;
            _socketConnection = null;
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[44,9,44,82,1],[46,9,46,125,1],[63,9,63,55,1],[77,9,77,249,1],[79,13,79,83,1],[80,13,80,102,1],[81,13,81,111,1],[82,13,82,114,1],[83,13,83,93,1],[84,13,84,126,1],[85,13,85,102,1],[86,13,86,70,1],[89,9,89,10,1],[98,20,98,34,1],[101,17,101,41,1],[102,21,102,98,0],[103,17,103,40,1],[104,13,104,14,1],[112,20,112,27,1],[115,17,115,41,1],[116,21,116,98,0],[117,17,117,33,1],[118,13,118,14,1],[126,26,126,30,1],[126,35,126,49,1],[131,31,131,38,1],[136,32,136,36,1],[136,37,136,49,1],[141,33,141,37,1],[141,38,141,50,1],[146,41,146,45,1],[151,44,151,75,1],[156,35,156,39,0],[156,40,156,52,1],[161,45,161,49,0],[161,50,161,62,1],[166,41,166,93,1],[171,42,171,95,1],[182,13,182,40,1],[187,13,188,51,1],[190,13,191,55,1],[199,17,199,83,1],[200,17,200,140,1],[203,17,203,148,1],[204,17,204,27,1],[204,28,204,92,0],[207,17,209,32,1],[210,13,210,14,1],[211,13,211,18,1],[213,17,213,30,1],[213,31,213,48,1],[214,17,214,63,1],[215,17,215,23,1],[218,13,218,40,1],[219,13,219,42,1],[220,13,220,46,1],[221,13,221,42,1],[224,13,224,26,1],[226,17,226,38,1],[227,17,227,38,1],[228,13,228,14,1],[230,13,230,26,1],[232,17,232,63,0],[233,17,233,69,0],[236,13,236,27,1],[237,9,237,10,1],[250,13,250,44,1],[251,9,251,10,1],[267,13,267,33,1],[271,17,271,39,1],[272,17,272,24,1],[275,13,275,39,1],[281,17,281,74,0],[282,17,282,24,0],[291,13,291,84,1],[294,17,294,126,1],[296,17,296,24,1],[300,13,300,37,1],[301,17,301,55,1],[303,17,303,54,1],[304,9,304,10,1],[312,17,312,41,1],[313,13,313,14,1],[314,13,314,32,0],[319,17,319,111,0],[320,13,320,14,0],[321,9,321,10,1],[329,17,329,101,1],[330,13,330,14,1],[333,17,333,31,0],[334,13,334,14,0],[337,13,337,51,1],[338,9,338,10,1],[346,13,346,46,1],[347,9,347,10,1],[359,13,359,33,1],[359,34,359,83,0],[363,13,363,70,1],[364,13,364,96,1],[367,13,367,79,1],[370,13,370,58,1],[371,9,371,10,1],[381,13,381,69,1],[386,13,386,36,1],[386,37,386,89,0],[395,13,395,26,1],[397,17,397,31,1],[397,32,397,72,0],[398,17,398,69,1],[399,13,399,14,1],[406,13,406,39,1],[409,17,409,118,1],[410,13,410,14,1],[411,13,411,32,0],[414,17,414,30,0],[415,17,415,73,0],[416,17,416,29,0],[416,30,416,36,0],[417,17,417,33,0],[418,13,418,14,0],[420,13,420,26,1],[422,17,422,73,0],[425,17,425,30,0],[426,21,426,61,0],[429,17,429,64,0],[439,17,441,87,1],[443,17,443,64,1],[445,17,445,33,1],[446,13,446,14,0],[447,13,447,32,1],[450,17,450,73,1],[451,17,451,23,1],[453,9,453,10,1],[461,13,461,26,1],[463,17,463,31,1],[463,32,463,39,1],[464,17,464,34,1],[465,17,465,34,1],[466,17,466,33,1],[467,13,467,14,1],[472,17,472,28,1],[472,29,472,69,1],[473,13,473,14,1],[474,13,474,32,0],[476,17,476,84,0],[477,13,477,14,0],[485,13,485,51,1],[486,22,486,36,0],[486,37,486,39,1],[486,40,486,51,1],[487,17,487,79,0],[490,13,490,25,1],[490,26,490,33,0],[493,13,493,59,1],[495,13,495,87,1],[498,13,498,39,1],[500,9,500,10,1],[505,13,505,44,1],[506,17,506,67,1],[507,18,507,48,1],[508,17,508,66,0],[510,13,510,39,1],[511,13,511,38,1],[512,9,512,10,1]]);
    </script>
  </body>
</html>