<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Clustering\Cluster.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Threading;
using System.Threading.Tasks;
using Hazelcast.Core;
using Hazelcast.Exceptions;
using Hazelcast.Partitioning;
using Hazelcast.Serialization;
using Microsoft.Extensions.Logging;

namespace Hazelcast.Clustering
{
    internal class Cluster : IAsyncDisposable
    {
        // generates unique cluster identifiers
        private static readonly ISequence&lt;int&gt; ClusterIdSequence = new Int32Sequence();

        private readonly TerminateConnections _terminateConnections;
        private readonly Heartbeat _heartbeat;

        private volatile int _disposed; // disposed flag

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;Cluster&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;options&quot;&gt;The cluster configuration.&lt;/param&gt;
        /// &lt;param name=&quot;serializationService&quot;&gt;The serialization service.&lt;/param&gt;
        /// &lt;param name=&quot;loggerFactory&quot;&gt;A logger factory.&lt;/param&gt;
        public Cluster(IClusterOptions options, SerializationService serializationService, ILoggerFactory loggerFactory)
        {
            if (options == null) throw new ArgumentNullException(nameof(options));
            if (serializationService == null) throw new ArgumentNullException(nameof(serializationService));
            if (loggerFactory is null) throw new ArgumentNullException(nameof(loggerFactory));

            var clientName = string.IsNullOrWhiteSpace(options.ClientName)
                ? options.ClientNamePrefix + ClusterIdSequence.GetNext()
                : options.ClientName;

            var clusterName = string.IsNullOrWhiteSpace(options.ClusterName) ? &quot;dev&quot; : options.ClusterName;

            State = new ClusterState(options, clusterName, clientName, new Partitioner(), loggerFactory);
            State.ShutdownRequested += () =&gt;
            {
                // yes, we are starting a fire-and-forget task
                // but, DisposeAsync should never throw
                // yet we add a CfAwaitNoThrow() for more safety
                DisposeAsync().CfAwaitNoThrow();
            };

            // create components
            _terminateConnections = new TerminateConnections(loggerFactory);
            Members = new ClusterMembers(State, _terminateConnections);
            Messaging = new ClusterMessaging(State, Members);
            Events = new ClusterEvents(State, Messaging, _terminateConnections, Members);
            Connections = new ClusterConnections(State, Members, serializationService);
            _heartbeat = new Heartbeat(State, Messaging, options.Heartbeat, _terminateConnections);

            // wire components
            WireComponents();

            HConsole.Configure(x =&gt; x.Configure&lt;Cluster&gt;().SetIndent(2).SetPrefix(&quot;CLUSTER&quot;));
        }

        private void WireComponents()
        {
            // beware! assigning multicast handlers *must* use +=

            // wire members
            Connections.ConnectionOpened += (conn, isFirstEver, isFirst, isNewCluster) =&gt; { Members.AddConnection(conn, isNewCluster); return default; };
            Connections.ConnectionClosed += async conn =&gt; { await Members.RemoveConnectionAsync(conn).CfAwait(); };

            // wire events
            // connection created = wire connection.ReceivedEvent -&gt; Events.OnReceivedEvent in order to handle events
            // connection opened = install subscriptions on new connection + ensure there is a cluster views connection
            // connection closed = clears subscriptions + ensure there is a cluster views connection
            Connections.ConnectionCreated += Events.OnConnectionCreated;
            Connections.ConnectionOpened += Events.OnConnectionOpened;
            Connections.ConnectionClosed += Events.OnConnectionClosed;

            // wire heartbeat
            Connections.ConnectionOpened += (conn, isFirstEver, isFirst, isNewCluster) =&gt; { _heartbeat.AddConnection(conn); return default; };
            Connections.ConnectionClosed += conn =&gt; { _heartbeat.RemoveConnection(conn); return default; };
        }

        /// &lt;summary&gt;
        /// Gets the cluster state.
        /// &lt;/summary&gt;
        public ClusterState State { get; }

        /// &lt;summary&gt;
        /// Gets the client name.
        /// &lt;/summary&gt;
        public string ClientName =&gt; State.ClientName;

        /// &lt;summary&gt;
        /// Gets the unique identifier of the cluster, as assigned by the client.
        /// &lt;/summary&gt;
        public Guid ClientId =&gt; State.ClientId;

        /// &lt;summary&gt;
        /// Gets the cluster name;
        /// &lt;/summary&gt;
        public string Name =&gt; State.ClusterName;

        /// &lt;summary&gt;
        /// Gets the cluster instrumentation.
        /// &lt;/summary&gt;
        public ClusterInstrumentation Instrumentation =&gt; State.Instrumentation;

        /// &lt;summary&gt;
        /// Gets the connections service.
        /// &lt;/summary&gt;
        public ClusterConnections Connections { get; }

        /// &lt;summary&gt;
        /// Gets the messaging service.
        /// &lt;/summary&gt;
        public ClusterMessaging Messaging { get; }

        /// &lt;summary&gt;
        /// Gets the members service.
        /// &lt;/summary&gt;
        public ClusterMembers Members { get; }

        /// &lt;summary&gt;
        /// Gets the cluster events service.
        /// &lt;/summary&gt;
        public ClusterEvents Events { get; }

        /// &lt;summary&gt;
        /// Determines whether the cluster is using smart routing.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;In &quot;smart mode&quot; the clients connect to each member of the cluster. Since each
        /// data partition uses the well known and consistent hashing algorithm, each client
        /// can send an operation to the relevant cluster member, which increases the
        /// overall throughput and efficiency. Smart mode is the default mode.&lt;/para&gt;
        /// &lt;para&gt;In &quot;uni-socket mode&quot; the clients is required to connect to a single member, which
        /// then behaves as a gateway for the other members. Firewalls, security, or some
        /// custom networking issues can be the reason for these cases.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public bool IsSmartRouting =&gt; State.IsSmartRouting;

        /// &lt;summary&gt;
        /// Whether the cluster is connected.
        /// &lt;/summary&gt;
        public bool IsConnected =&gt; State.IsConnected;

        /// &lt;summary&gt;
        /// Whether the cluster is active.
        /// &lt;/summary&gt;
        public bool IsActive =&gt; _disposed == 0;

        /// &lt;summary&gt;
        /// Gets the partitioner.
        /// &lt;/summary&gt;
        public Partitioner Partitioner =&gt; State.Partitioner;

        /// &lt;summary&gt;
        /// Connects the cluster.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;A cancellation token.&lt;/param&gt;
        /// &lt;returns&gt;A task that will complete when the cluster is connected.&lt;/returns&gt;
        public async Task ConnectAsync(CancellationToken cancellationToken)
        {
            // change state to Starting if it is zero aka New
            var changed = await State.ChangeStateAndWait(ClientState.Starting, 0 /* ClientState.New */).CfAwait();
            if (!changed)
                throw new ConnectionException(&quot;Failed to connected (aborted).&quot;);

            // connect
            await Connections.ConnectAsync(cancellationToken).CfAwait();
        }

        /// &lt;inheritdoc /&gt;
        public async ValueTask DisposeAsync()
        {
            if (Interlocked.CompareExchange(ref _disposed, 1, 0) == 1)
                return;

            // disposing the cluster terminates all operations
            HConsole.WriteLine(this, &quot;Shutting down&quot;);

            // notify we are shutting down - the user may have things to do that
            // require talking to the cluster, so we *wait* for the corresponding
            // event handlers to run before proceeding
            await State.ChangeStateAndWait(ClientState.ShuttingDown).CfAwait();

            // at that point,
            // - the state is &#39;ShuttingDown&#39;
            // - all user code handling the state change event has run
            // - it is still possible to talk to the cluster

            // the user *should* have shut their own operations down, and if they
            // still try to talk to the cluster, we cannot guarantee anything

            // stop terminating connections, heart-beating
            HConsole.WriteLine(this, &quot;Dispose TerminateConnections&quot;);
            await _terminateConnections.DisposeAsync().CfAwait();
            HConsole.WriteLine(this, &quot;Dispose Heartbeat&quot;);
            await _heartbeat.DisposeAsync().CfAwait();

            // these elements below *will* talk to the cluster when shutting down,
            // as they will want to unsubscribe in order to shutdown as nicely
            // as possible

            // ClusterMessaging has nothing to dispose

            // ClusterEvents need to shutdown
            // - the events scheduler (always running)
            // - the task that ensures there is a cluster events connection (if it&#39;s running)
            // - the task that deals with ghost subscriptions (if it&#39;s running)
            // - the two ObjectLifeCycle and PartitionLost subscriptions
            HConsole.WriteLine(this, &quot;Dispose Events&quot;);
            await Events.DisposeAsync().CfAwait();

            // for all it matters, we are now down - the final state change to
            // &#39;Shutdown&#39; will be performed by Connections when the last connection
            // goes down

            // now it&#39;s time to dispose the connections, ie close all of them
            // and shutdown
            // - the reconnect task (if it&#39;s running)
            // - the task that connects members (always running)
            HConsole.WriteLine(this, &quot;Dispose Connections&quot;);
            await Connections.DisposeAsync().CfAwait();

            // connections are gone, we are down
            HConsole.WriteLine(this, &quot;Connections disposed, down&quot;);
            await State.ChangeStateAndWait(ClientState.Shutdown).CfAwait();

            // at that point we can get rid of members
            HConsole.WriteLine(this, &quot;Dispose Members&quot;);
            await Members.DisposeAsync().CfAwait();

            // and finally, of the state itself
            // which will shutdown
            // - the state changed queue (always running)
            //   (after it has been drained, so last &#39;Shutdown&#39; even is processed)
            HConsole.WriteLine(this, &quot;Dispose State&quot;);
            await State.DisposeAsync().CfAwait();
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[29,9,29,88,1],[42,9,42,121,1],[44,13,44,33,1],[44,34,44,83,0],[45,13,45,46,1],[45,47,45,109,0],[46,13,46,39,1],[46,40,46,95,0],[48,13,50,38,1],[52,13,52,108,1],[54,13,54,106,1],[55,13,60,17,1],[60,17,60,49,1],[60,49,61,13,1],[61,13,61,14,1],[61,14,61,15,1],[64,13,64,77,1],[65,13,65,72,1],[66,13,66,62,1],[67,13,67,90,1],[68,13,68,88,1],[69,13,69,100,1],[72,13,72,30,1],[75,9,75,10,1],[82,13,82,93,1],[82,93,82,135,1],[82,135,82,136,1],[82,136,82,151,1],[82,151,82,154,1],[83,13,83,61,1],[83,61,83,113,1],[83,113,83,114,1],[83,114,83,115,1],[83,115,83,116,1],[89,13,89,73,1],[90,13,90,71,1],[91,13,91,71,1],[94,13,94,93,1],[94,93,94,124,1],[94,124,94,125,1],[94,125,94,140,1],[94,140,94,143,1],[95,13,95,55,1],[95,55,95,89,1],[95,89,95,90,1],[95,90,95,105,1],[95,105,95,108,1],[96,9,96,10,1],[101,37,101,41,1],[106,37,106,53,0],[111,33,111,47,1],[116,31,116,48,0],[121,58,121,79,0],[126,49,126,53,1],[131,45,131,49,1],[136,41,136,45,1],[141,39,141,43,1],[155,39,155,59,1],[160,36,160,53,1],[165,33,165,47,1],[170,43,170,60,1],[180,13,180,115,1],[181,13,181,26,1],[182,17,182,81,0],[185,13,185,73,1],[186,9,186,10,1],[191,13,191,71,1],[192,17,192,24,1],[200,13,200,80,1],[212,13,212,66,1],[214,13,214,55,1],[228,13,228,51,1],[239,13,239,56,1],[243,13,243,76,1],[247,13,247,52,1],[254,13,254,50,1],[255,9,255,10,1]]);
    </script>
  </body>
</html>