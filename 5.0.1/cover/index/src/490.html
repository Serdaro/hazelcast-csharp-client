<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\NearCaching\NearCache.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Hazelcast.Clustering;
using Hazelcast.Core;
using Hazelcast.Models;
using Hazelcast.Protocol.Codecs;
using Hazelcast.Serialization;
using Microsoft.Extensions.Logging;

namespace Hazelcast.NearCaching
{
    /// &lt;summary&gt;
    /// Represents a Near Cache.
    /// &lt;/summary&gt;
    internal class NearCache : NearCacheBase
    {
        private readonly int _maxToleratedMissCount;
        private Guid _subscriptionId;

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;NearCache&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;name&quot;&gt;The name of the cache.&lt;/param&gt;
        /// &lt;param name=&quot;cluster&quot;&gt;The cluster.&lt;/param&gt;
        /// &lt;param name=&quot;serializationService&quot;&gt;The localization service.&lt;/param&gt;
        /// &lt;param name=&quot;loggerFactory&quot;&gt;A logger factory.&lt;/param&gt;
        /// &lt;param name=&quot;nearCacheOptions&quot;&gt;NearCache options.&lt;/param&gt;
        /// &lt;param name=&quot;maxToleratedMissCount&quot;&gt;&lt;/param&gt;
        public NearCache(string name, Cluster cluster, SerializationService serializationService, ILoggerFactory loggerFactory, NearCacheOptions nearCacheOptions, int maxToleratedMissCount)
            : base(name, cluster, serializationService, loggerFactory, nearCacheOptions)
        {
            _maxToleratedMissCount = maxToleratedMissCount;
        }

        /// &lt;summary&gt;
        /// Gets or sets the repairing handler.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;The repairing handler is used by the &lt;see cref=&quot;NearCacheManager&quot;/&gt;.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public RepairingHandler RepairingHandler { get; private set; }

        /// &lt;inheritdoc /&gt;
        public override async ValueTask InitializeAsync()
        {
            if (Options.InvalidateOnChange)
            {
                try
                {
                    _subscriptionId = await SubscribeToInvalidationEventsAsync().CfAwait();
                    RepairingHandler = new RepairingHandler(Cluster.ClientId, this, _maxToleratedMissCount, Cluster.Partitioner, SerializationService, LoggerFactory);
                    IsInvalidating = true;
                }
                catch (Exception e)
                {
                    LoggerFactory.CreateLogger&lt;NearCache&gt;().LogCritical(e, &quot;-----------------\n Near Cache is not initialized!!! \n-----------------&quot;);
                    IsInvalidating = false;
                }
            }
        }

        /// &lt;inheritdoc /&gt;
        protected override async ValueTask DisposeAsyncCore()
        {
            if (_subscriptionId != default)
                await Cluster.Events.RemoveSubscriptionAsync(_subscriptionId, CancellationToken.None).CfAwait();
        }

        /// &lt;inheritdoc /&gt;
        protected override NearCacheEntry CreateCacheEntry(IData keyData, object value)
        {
            var entry = base.CreateCacheEntry(keyData, value);
            if (entry == null) return null;

            // do not manage invalidation, just return the entry
            if (!IsInvalidating) return entry;

            // otherwise, populate the entry with repairing meta data
            var partitionHash = entry.KeyData.PartitionHash;
            var partitionId = Cluster.Partitioner.GetPartitionId(partitionHash);
            var metadata = RepairingHandler.GetMetadata(partitionId);
            entry.PartitionId = partitionId;
            entry.Sequence = metadata.Sequence;
            entry.Guid = metadata.Guid;

            return entry;
        }

        /// &lt;inheritdoc /&gt;
        protected override bool IsStaleRead(NearCacheEntry entry)
        {
            // do not manage invalidation = cannot be stale
            if (!IsInvalidating) return false;

            // otherwise, check meta data
            var metadata = RepairingHandler.GetMetadata(entry.PartitionId);

            return entry.Guid != metadata.Guid || entry.Sequence &lt; metadata.StaleSequence;
        }

        /// &lt;summary&gt;
        /// Whether the cache is invalidating.
        /// &lt;/summary&gt;
        public bool IsInvalidating { get; private set; }

        /// &lt;summary&gt;
        /// Subscribes to invalidation events.
        /// &lt;/summary&gt;
        private async ValueTask&lt;Guid&gt; SubscribeToInvalidationEventsAsync()
        {
            var subscription = new ClusterSubscription(
                MapAddNearCacheInvalidationListenerCodec.EncodeRequest(Name, (int) MapEventTypes.Invalidated, false),
                (message, state) =&gt; MapAddNearCacheInvalidationListenerCodec.DecodeResponse(message).Response,
                (id, state) =&gt; MapRemoveEntryListenerCodec.EncodeRequest(((EventState) state).Name, id),
                (message, state) =&gt; MapRemoveEntryListenerCodec.DecodeResponse(message).Response,
                (message, state) =&gt; MapAddNearCacheInvalidationListenerCodec.HandleEventAsync(message, HandleCodecSingleEvent, HandleCodecBatchEvent, null, LoggerFactory),
                new EventState { Name = Name });

            await Cluster.Events.AddSubscriptionAsync(subscription, CancellationToken.None).CfAwait();
            return subscription.Id;
        }

        /// &lt;summary&gt;
        /// Represents the invalidation events state.
        /// &lt;/summary&gt;
        private class EventState
        {
            public string Name { get; set; }
        }

        /// &lt;summary&gt;
        /// Handle batch invalidation events.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;keys&quot;&gt;The invalidated keys.&lt;/param&gt;
        /// &lt;param name=&quot;sourceuuids&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;partitionuuids&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;sequences&quot;&gt;&lt;/param&gt;
        private ValueTask HandleCodecBatchEvent(IEnumerable&lt;IData&gt; keys, IEnumerable&lt;Guid&gt; sourceuuids, IEnumerable&lt;Guid&gt; partitionuuids, IEnumerable&lt;long&gt; sequences, object state)
        {
            RepairingHandler.Handle(keys, sourceuuids, partitionuuids, sequences);
            return default;
        }

        /// &lt;summary&gt;
        /// Handle invalidation events.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;key&quot;&gt;The invalidated key.&lt;/param&gt;
        /// &lt;param name=&quot;sourceUuid&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;partitionUuid&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;sequence&quot;&gt;&lt;/param&gt;
        private ValueTask HandleCodecSingleEvent(IData key, Guid sourceUuid, Guid partitionUuid, long sequence, object state)
        {
            RepairingHandler.Handle(key, sourceUuid, partitionUuid, sequence);
            return default;
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[46,15,46,89,1],[48,13,48,60,1],[49,9,49,10,1],[57,52,57,56,1],[57,57,57,69,1],[62,13,62,44,1],[66,21,66,92,1],[67,21,67,167,1],[68,21,68,43,1],[69,17,69,18,1],[70,17,70,36,0],[72,21,72,152,0],[73,21,73,44,0],[74,17,74,18,0],[76,9,76,10,1],[81,13,81,44,1],[82,17,82,113,1],[83,9,83,10,1],[88,13,88,63,1],[89,13,89,31,1],[89,32,89,44,1],[92,13,92,33,1],[92,34,92,47,1],[95,13,95,61,1],[96,13,96,81,1],[97,13,97,70,1],[98,13,98,45,1],[99,13,99,48,1],[100,13,100,40,1],[102,13,102,26,1],[109,13,109,33,1],[109,34,109,47,1],[112,13,112,76,1],[114,13,114,91,1],[120,38,120,42,1],[120,43,120,55,1],[127,13,129,37,1],[129,37,129,110,1],[129,110,130,32,1],[130,32,130,104,1],[130,104,131,37,1],[131,37,131,97,1],[131,97,132,37,1],[132,37,132,171,1],[132,171,133,49,1],[135,13,135,103,1],[136,13,136,36,1],[137,9,137,10,1],[144,34,144,38,1],[144,39,144,43,1],[156,13,156,83,0],[157,13,157,28,0],[169,13,169,79,1],[170,13,170,28,1]]);
    </script>
  </body>
</html>