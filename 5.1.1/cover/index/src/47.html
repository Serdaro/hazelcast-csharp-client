<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Sql\SqlServiceExtensions.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Hazelcast.Core;
using Hazelcast.DistributedObjects;
using Hazelcast.Serialization;

namespace Hazelcast.Sql
{
    public static class SqlServiceExtensions
    {
        // NOTE: these are convenient extension methods, and the C# compiler is clever enough to figure
        // things out between the various overloads, including the &#39;params object[]&#39; overload.

        /// &lt;summary&gt;
        /// Executes a SQL query.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;service&quot;&gt;The &lt;see cref=&quot;ISqlService&quot;/&gt; which executes the query.&lt;/param&gt;
        /// &lt;param name=&quot;sql&quot;&gt;The SQL query text to execute.&lt;/param&gt;
        /// &lt;param name=&quot;parameters&quot;&gt;Parameters for the SQL query.&lt;/param&gt;
        /// &lt;returns&gt;An &lt;see cref=&quot;ISqlQueryResult&quot;/&gt; instance that represents the result of the query.&lt;/returns&gt;
        public static Task&lt;ISqlQueryResult&gt; ExecuteQueryAsync(this ISqlService service, string sql, params object[] parameters)
            =&gt; service?.ExecuteQueryAsync(sql, parameters) ?? throw new ArgumentNullException(nameof(service));

        /// &lt;summary&gt;
        /// Executes a SQL query.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;service&quot;&gt;The &lt;see cref=&quot;ISqlService&quot;/&gt; which executes the query.&lt;/param&gt;
        /// &lt;param name=&quot;sql&quot;&gt;The SQL query text to execute.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;A cancellation token.&lt;/param&gt;
        /// &lt;returns&gt;An &lt;see cref=&quot;ISqlQueryResult&quot;/&gt; instance that represents the result of the query.&lt;/returns&gt;
        public static Task&lt;ISqlQueryResult&gt; ExecuteQueryAsync(this ISqlService service, string sql, CancellationToken cancellationToken)
            =&gt; service?.ExecuteQueryAsync(sql, cancellationToken: cancellationToken) ?? throw new ArgumentNullException(nameof(service));

        /// &lt;summary&gt;
        /// Executes a SQL query.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;service&quot;&gt;The &lt;see cref=&quot;ISqlService&quot;/&gt; which executes the query.&lt;/param&gt;
        /// &lt;param name=&quot;sql&quot;&gt;The SQL query text to execute.&lt;/param&gt;
        /// &lt;param name=&quot;options&quot;&gt;Options for the SQL query.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;A cancellation token.&lt;/param&gt;
        /// &lt;returns&gt;An &lt;see cref=&quot;ISqlQueryResult&quot;/&gt; instance that represents the result of the query.&lt;/returns&gt;
        public static Task&lt;ISqlQueryResult&gt; ExecuteQueryAsync(this ISqlService service, string sql, SqlStatementOptions options, CancellationToken cancellationToken = default)
            =&gt; service?.ExecuteQueryAsync(sql, options: options, cancellationToken: cancellationToken) ?? throw new ArgumentNullException(nameof(service));

        /// &lt;summary&gt;
        /// Executes an SQL command.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;service&quot;&gt;The &lt;see cref=&quot;ISqlService&quot;/&gt; which executes the command.&lt;/param&gt;
        /// &lt;param name=&quot;sql&quot;&gt;The SQL command text to execute.&lt;/param&gt;
        /// &lt;param name=&quot;parameters&quot;&gt;Parameters for the SQL command.&lt;/param&gt;
        /// &lt;returns&gt;The number of rows affected byt the command.&lt;/returns&gt;
        public static Task&lt;long&gt; ExecuteCommandAsync(this ISqlService service, string sql, params object[] parameters)
            =&gt; service?.ExecuteCommandAsync(sql, parameters) ?? throw new ArgumentNullException(nameof(service));

        /// &lt;summary&gt;
        /// Executes an SQL command.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;service&quot;&gt;The &lt;see cref=&quot;ISqlService&quot;/&gt; which executes the command.&lt;/param&gt;
        /// &lt;param name=&quot;sql&quot;&gt;The SQL command text to execute.&lt;/param&gt;
        /// &lt;param name=&quot;options&quot;&gt;Options for the SQL command.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;A cancellation token.&lt;/param&gt;
        /// &lt;returns&gt;The number of rows affected byt the command.&lt;/returns&gt;
        public static Task&lt;long&gt; ExecuteCommandAsync(this ISqlService service, string sql, SqlStatementOptions options, CancellationToken cancellationToken = default)
            =&gt; service?.ExecuteCommandAsync(sql, options: options, cancellationToken: cancellationToken) ?? throw new ArgumentNullException(nameof(service));

        // TODO: finalize these methods and make them public (when doing Linq?)
        // https://docs.hazelcast.com/hazelcast/latest/sql/mapping-to-maps.html

        private static string GetMapping&lt;T&gt;(string name)
        {
            var type = typeof(T);
            string mapping;

            // portable objects
            if (typeof(IPortable).IsAssignableFrom(type))
            {
                try
                {
                    var p = Activator.CreateInstance&lt;T&gt;() as IPortable;
                    mapping = $&quot;&#39;{name}Format&#39; = &#39;portable&#39;, &#39;{name}PortableFactoryId&#39; = &#39;{p.FactoryId}&#39;, &#39;{name}PortableClassId&#39; = &#39;{p.ClassId}&#39;&quot;;
                    // optional: &quot;&#39;{name}PortableVersion&#39; = &#39;0&#39;&quot;;
                }
                catch
                {
                    throw new NotSupportedException($&quot;Failed to map C# type {type} (which is IPortable) to a Java type.&quot;);
                }
            }

            // TODO: compact? json?

            // Java objects
            else
            {
                mapping = $&quot;&#39;{name}Format&#39; = &#39;java&#39;, &#39;{name}JavaClass&#39; = &#39;{TypesMap.ToJava&lt;T&gt;()}&#39;&quot;;
            }

            return mapping;
        }

        /// &lt;summary&gt;
        /// Creates an &lt;see cref=&quot;IHMap{TKey,TValue}&quot;/&gt; mapping.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;TKey&quot;&gt;The type of the keys.&lt;/typeparam&gt;
        /// &lt;typeparam name=&quot;TValue&quot;&gt;The type of the values.&lt;/typeparam&gt;
        /// &lt;param name=&quot;sql&quot;&gt;The SQL service.&lt;/param&gt;
        /// &lt;param name=&quot;map&quot;&gt;The map.&lt;/param&gt;
        /// &lt;param name=&quot;columns&quot;&gt;Expressions specifying the columns to map.&lt;/param&gt;
        /// &lt;returns&gt;A &lt;see cref=&quot;Task&quot;/&gt; that will complete when the mapping has been created.&lt;/returns&gt;
        internal static Task CreateMapping&lt;TKey, TValue&gt;(this ISqlService sql, IHMap&lt;TKey, TValue&gt; map, params Expression&lt;Func&lt;TValue, object&gt;&gt;[] columns)
        {
            if (sql == null) throw new ArgumentNullException(nameof(sql));
            if (map == null) throw new ArgumentNullException(nameof(map));

            var keyMapping = GetMapping&lt;TKey&gt;(&quot;key&quot;);
            var valueMapping = GetMapping&lt;TValue&gt;(&quot;value&quot;);

            var command = new StringBuilder();
            command.Append(&quot;CREATE MAPPING \&quot;&quot;);
            command.Append(map.Name);
            command.Append(&quot;\&quot; EXTERNAL NAME \&quot;&quot;);
            command.Append(map.Name);
            command.Append(&quot;\&quot; &quot;);
            if (columns != null &amp;&amp; columns.Length &gt; 0)
            {
                command.Append(&#39;(&#39;);
                var first = true;
                foreach (var expression in columns)
                {
                    var member = expression.Body as MemberExpression;
                    if (member == null)
                    {
                        if (expression.Body is UnaryExpression unary)
                            member = unary.Operand as MemberExpression;
                        if (member == null) throw new InvalidOperationException(&quot;Failed to parse expression.&quot;);
                    }
                    var propertyInfo = member.Member as PropertyInfo;
                    if (propertyInfo == null) throw new InvalidOperationException(&quot;Failed to parse expression (not a property?).&quot;);
                    var name = propertyInfo.Name;
                    var type = propertyInfo.PropertyType;

                    if (first) first = false;
                    else command.Append(&quot;, &quot;);

                    command.Append(name);
                    command.Append(&#39; &#39;);
                    command.Append(TypesMap.ToSql(type));
                }
                command.Append(&quot;) &quot;);
            }
            command.Append(&quot;TYPE IMAP OPTIONS(&quot;);
            command.Append(keyMapping);
            command.Append(&quot;, &quot;);
            command.Append(valueMapping);
            command.Append(&#39;)&#39;);

            return sql.ExecuteCommandAsync(command.ToString());
        }

        /// &lt;summary&gt;
        /// Drops an &lt;see cref=&quot;IHMap{TKey,TValue}&quot;/&gt; mapping.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;TKey&quot;&gt;The type of the keys.&lt;/typeparam&gt;
        /// &lt;typeparam name=&quot;TValue&quot;&gt;The type of the values.&lt;/typeparam&gt;
        /// &lt;param name=&quot;sql&quot;&gt;The SQL service.&lt;/param&gt;
        /// &lt;param name=&quot;map&quot;&gt;The map.&lt;/param&gt;
        /// &lt;returns&gt;A &lt;see cref=&quot;Task&quot;/&gt; that will complete when the mapping has been dropped.&lt;/returns&gt;
        internal static Task DropMapping&lt;TKey, TValue&gt;(this ISqlService sql, IHMap&lt;TKey, TValue&gt; map)
        {
            if (sql == null) throw new ArgumentNullException(nameof(sql));
            if (map == null) throw new ArgumentNullException(nameof(map));

            var command = @$&quot;DROP MAPPING &quot;&quot;{map.Name}&quot;&quot;&quot;;
            return sql.ExecuteCommandAsync(command);
        }

        /// &lt;summary&gt;
        /// Gets the existing mappings.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;sql&quot;&gt;The SQL service.&lt;/param&gt;
        /// &lt;returns&gt;A list of existing mappings names.&lt;/returns&gt;
        internal static async Task&lt;IReadOnlyList&lt;string&gt;&gt; ShowMappings(this ISqlService sql)
        {
            if (sql == null) throw new ArgumentNullException(nameof(sql));

            // gets 1 column named &#39;name&#39; containing the name of the mapping as Varchar
            var queryResult = await sql.ExecuteQueryAsync(&quot;SHOW MAPPINGS&quot;).CfAwait();

            var mappings = new List&lt;string&gt;();
            await foreach (var row in queryResult)
                mappings.Add(row.GetColumn&lt;string&gt;(0));
            return mappings;
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[41,16,41,111,1],[51,16,51,137,0],[62,16,62,155,1],[72,16,72,113,1],[83,16,83,157,0],[90,13,90,34,1],[94,13,94,58,1],[98,21,98,72,1],[99,21,99,148,1],[101,17,101,18,1],[102,17,102,22,0],[104,21,104,123,0],[113,17,113,100,1],[116,13,116,28,1],[130,13,130,29,1],[130,30,130,75,0],[131,13,131,29,1],[131,30,131,75,0],[133,13,133,54,1],[134,13,134,60,1],[136,13,136,47,1],[137,13,137,49,1],[138,13,138,38,1],[139,13,139,51,1],[140,13,140,38,1],[141,13,141,35,1],[142,13,142,55,1],[144,17,144,37,1],[145,17,145,34,1],[146,26,146,40,1],[146,41,146,43,1],[146,44,146,51,1],[148,21,148,70,1],[149,21,149,40,1],[151,25,151,70,1],[152,29,152,72,1],[153,25,153,44,1],[153,45,153,112,0],[155,21,155,70,1],[156,21,156,46,1],[156,47,156,132,0],[157,21,157,50,1],[158,21,158,58,1],[160,21,160,31,1],[160,32,160,46,1],[161,26,161,47,1],[163,21,163,42,1],[164,21,164,41,1],[165,21,165,58,1],[167,17,167,38,1],[169,13,169,50,1],[170,13,170,40,1],[171,13,171,34,1],[172,13,172,42,1],[173,13,173,33,1],[175,13,175,64,1],[188,13,188,29,1],[188,30,188,75,0],[189,13,189,29,1],[189,30,189,75,0],[191,13,191,59,1],[192,13,192,53,1],[202,13,202,29,1],[202,30,202,75,0],[205,13,205,86,1],[207,13,207,47,1],[208,28,208,35,1],[208,36,208,38,1],[208,39,208,50,1],[209,17,209,56,1],[210,13,210,29,1],[211,9,211,10,1]]);
    </script>
  </body>
</html>