<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Metrics\MetricsCompressor.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using System.IO;
using Hazelcast.Core;
using Ionic.Zlib;

namespace Hazelcast.Metrics
{
    // compresses metrics, closely following the MetricsCompressor.java code to ensure interoperability
    internal class MetricsCompressor : IDisposable
    {
        private const int InitialStringsBufferSize = 2 &lt;&lt; 10; // 2kB
        private const int InitialMetricsBufferSize = 2 &lt;&lt; 11; // 4kB
        private const int InitialTempBufferSize = 2 &lt;&lt; 8; // 512B

        // about compression
        // read https://stackoverflow.com/questions/6522778/java-util-zip-deflater-equivalent-in-c-sharp
        // System.IO.Compression.DeflateStream is *not* Java-compatible!
        // now using ZlibStream from DotNetZip, would be worth benchmarking against SharpZipLib

        // output streams for the blob containing the strings
        private MemoryStream _stringsBuffer;
        private ZlibStream _stringsCompressStream;
        private DataOutputStream _stringsOutput;

        // output streams for the blob containing the metrics
        private MemoryStream _metricsBuffer;
        private ZlibStream _metricsCompressStream;
        private DataOutputStream _metricsOutput;

        // temporary buffer to avoid fragmented writes to the compressed streams, when
        // when writing primitive fields - TODO: is this needed in C#?
        private readonly MemoryStream _tempBuffer;
        private readonly DataOutputStream _tempOutput;

        private SortedDictionary&lt;string, int&gt; _strings = new SortedDictionary&lt;string, int&gt;();
        private int _count;
        private IMetricDescriptor _lastDescriptor;
        private bool _disposed, _closed;

        public MetricsCompressor()
        {
            Reset(InitialStringsBufferSize, InitialMetricsBufferSize);

            // that one is never reset
            _tempBuffer = new MemoryStream(InitialTempBufferSize);
            _tempOutput = new DataOutputStream(_tempBuffer);
        }

        private static void Reset(ref MemoryStream buffer, ref ZlibStream compress, ref DataOutputStream output, int size)
        {
            compress?.Dispose();

            // shrink if capacity is more than 50% larger than the estimated size
            if (buffer == null || buffer.Capacity &gt; 3 * size/ 2)
            {
                buffer?.Dispose();
                buffer = new MemoryStream(size);
            }

            buffer.Seek(0, SeekOrigin.Begin);
            compress = new ZlibStream(buffer, CompressionMode.Compress, CompressionLevel.BestSpeed, true);
            output = new DataOutputStream(compress);
        }

        private void Reset(int stringsBufferSize, int metricsBufferSize)
        {
            Reset(ref _stringsBuffer, ref _stringsCompressStream, ref _stringsOutput, stringsBufferSize);
            Reset(ref _metricsBuffer, ref _metricsCompressStream, ref _metricsOutput, metricsBufferSize);

            _strings = new SortedDictionary&lt;string, int&gt;();
            _count = 0;
            _lastDescriptor = null;
            _closed = false;
        }

        public void Dispose()
        {
            if (_disposed) return;
            _disposed = true;

            _tempBuffer?.Dispose();

            _stringsCompressStream?.Dispose();
            _stringsBuffer?.Dispose();

            _metricsCompressStream?.Dispose();
            _metricsBuffer?.Dispose();
        }

        public void Append(Metric metric)
        {
            if (_closed) throw new InvalidOperationException(&quot;Compressor is closed.&quot;);

            // TODO: if we buffered metrics and ordered them by prefix we could save more space?

            if (!(metric is Metric&lt;double&gt;) &amp;&amp;
                !(metric is Metric&lt;long&gt;) &amp;&amp;
                !(metric is Metric&lt;int&gt;))
            {
                // we can only send numeric metrics, everything else is ignored
                return;
            }

            _tempBuffer.Seek(0, SeekOrigin.Begin);
            AppendDescriptor(metric.Descriptor);

            switch (metric)
            {
                case Metric&lt;double&gt; doubleMetric:
                    _tempOutput.WriteByte((byte) MetricValueType.Double);
                    _tempOutput.WriteDouble(doubleMetric.Value);
                    break;
                case Metric&lt;long&gt; longMetric:
                    _tempOutput.WriteByte((byte) MetricValueType.Long);
                    _tempOutput.WriteLong(longMetric.Value);
                    break;
                case Metric&lt;int&gt; intMetric:
                    _tempOutput.WriteByte((byte) MetricValueType.Long);
                    _tempOutput.WriteLong(intMetric.Value);
                    break;
            }

            // protect case
            if (_tempBuffer.Position &gt; int.MaxValue) throw new InvalidOperationException($&quot;Out of range: _tempBuffer.Position ({_tempBuffer.Position}).&quot;);

            _metricsOutput.Write(_tempBuffer.GetBuffer(), 0, (int) _tempBuffer.Position);
        }

        private void AppendDescriptor(IMetricDescriptor descriptor)
        {
            var mask = GetMask(descriptor);
            _tempOutput.WriteByte((byte) mask);

            if (mask.HasNone(DescriptorMask.Prefix))
                _tempOutput.WriteInt(GetStringId(descriptor.Prefix));

            if (mask.HasNone(DescriptorMask.Name))
                _tempOutput.WriteInt(GetStringId(descriptor.Name));

            if (mask.HasNone(DescriptorMask.DiscriminatorName))
                _tempOutput.WriteInt(GetStringId(descriptor.DiscriminatorKey));

            if (mask.HasNone(DescriptorMask.DiscriminatorValue))
                _tempOutput.WriteInt(GetStringId(descriptor.DiscriminatorValue));

            if (mask.HasNone(DescriptorMask.Unit))
                _tempOutput.WriteByte((byte) descriptor.Unit);

            // include excludeTargets for compatibility purposes (but it&#39;s always zero)
            if (mask.HasNone(DescriptorMask.ExcludedTargets))
                _tempOutput.WriteByte(0);

            if (mask.HasNone(DescriptorMask.TagCount))
                _tempOutput.WriteByte((byte) descriptor.Tags.Count);

            // further compression would be possible by writing only the different tags
            foreach (var (tagName, tagValue) in descriptor.Tags)
            {
                _tempOutput.WriteInt(GetStringId(tagName));
                _tempOutput.WriteInt(GetStringId(tagValue));
            }

            _count++;
            _lastDescriptor = descriptor; // TODO: Java clones the descriptor, are we safe?
        }

        private DescriptorMask GetMask(IMetricDescriptor descriptor)
        {
            var mask = DescriptorMask.None;

            // &quot;excluded targets&quot; are not supported, hence always masked
            mask |= DescriptorMask.ExcludedTargets;

            if (_lastDescriptor == null)
                return mask;

            if (descriptor.Prefix == _lastDescriptor.Prefix)
                mask |= DescriptorMask.Prefix;

            if (descriptor.Name == _lastDescriptor.Name)
                mask |= DescriptorMask.Name;

            if (descriptor.DiscriminatorKey == _lastDescriptor.DiscriminatorKey)
                mask |= DescriptorMask.DiscriminatorName;

            if (descriptor.DiscriminatorValue == _lastDescriptor.DiscriminatorValue)
                mask |= DescriptorMask.DiscriminatorValue;

            if (descriptor.Unit == _lastDescriptor.Unit)
                mask |= DescriptorMask.Unit;

            // &quot;excluded targets&quot; are not supported, hence always masked
            //if (Objects.equals(descriptor.excludedTargets(), lastDescriptor.excludedTargets()))
            //    mask |= DescriptorMask.ExcludedTargets;

            if (descriptor.TagCount == _lastDescriptor.TagCount)
                mask |= DescriptorMask.TagCount;

            return mask;
        }

        private int GetStringId(string s)
        {
            if (s == null)
                return -1;

            if (_strings.TryGetValue(s, out var id))
                return id;

            id = _strings.Count;
            _strings[s] = id;
            return id;
        }

        private void AppendStrings()
        {
            _stringsOutput.WriteInt(_strings.Count);
            var prevText = &quot;&quot;;

            // sorted dictionary is ordered by natural order of its keys
            // so that delta-processing is efficient
            foreach (var (stringText, stringId) in _strings)
            {
                // this should have been checked earlier, this is a safety check
                // this protects the length casts to byte below
                if (stringText.Length &gt; byte.MaxValue)
                    throw new InvalidOperationException($&quot;Out of range: stringText.Length (\&quot;{stringText}\&quot;).&quot;);

                // find the span of chars that is common to stringText and prevText
                var maxCommonLen = Math.Min(prevText.Length, stringText.Length);
                var commonLen = 0;
                while (commonLen &lt; maxCommonLen &amp;&amp; stringText[commonLen] == prevText[commonLen])
                    commonLen++;

                // compute the length of remaining, non-common chars
                var diffLen = stringText.Length - commonLen;

                // write through temp buffer
                _tempBuffer.Seek(0, SeekOrigin.Begin);

                // write
                _tempOutput.WriteInt(stringId);
                _tempOutput.WriteByte((byte) commonLen);
                _tempOutput.WriteByte((byte) diffLen);
                _tempOutput.WriteString(stringText, commonLen, diffLen);

                // protect case
                if (_tempBuffer.Position &gt; int.MaxValue) throw new InvalidOperationException($&quot;Out of range: _tempBuffer.Position ({_tempBuffer.Position}).&quot;);

                _stringsOutput.Write(_tempBuffer.GetBuffer(), 0, (int) _tempBuffer.Position);

                prevText = stringText;
            }
        }

        private byte[] GetBytes()
        {
            const int binaryFormatVersion = 1;
            const int sizeVersion = 2;
            const int sizeDictionaryBlob = 4;
            const int sizeCountMetrics = 4;

            const int bitsInByte = 8;
            const int byteMask = 0xff;

            // close the compressor, we&#39;re going to dispose the compressed streams
            _closed = true;

            AppendStrings();

            // got to dispose the compressed streams to flush them all
            _stringsCompressStream.Dispose();
            _stringsCompressStream = null;
            _metricsCompressStream.Dispose();
            _metricsCompressStream = null;

            // version info + dictionary length + dictionary blob + number of metrics + metrics blob
            var completeSize = sizeVersion + sizeDictionaryBlob + _stringsBuffer.Position + sizeCountMetrics + _metricsBuffer.Position;

            // protect casts
            if (completeSize &gt; int.MaxValue) throw new InvalidOperationException($&quot;Out of range: completeSize ({completeSize}).&quot;);
            if (_stringsBuffer.Position &gt; int.MaxValue) throw new InvalidOperationException($&quot;Out of range: _stringsBuffer.Length ({_stringsBuffer.Position}).&quot;);
            if (_metricsBuffer.Position &gt; int.MaxValue) throw new InvalidOperationException($&quot;Out of range: _metricsBuffer.Length ({_metricsBuffer.Position}).&quot;);

            using var buffer = new MemoryStream((int) completeSize);
            var output = new DataOutputStream(buffer);

            // ReSharper disable once ShiftExpressionResultEqualsZero - well, yes
            output.WriteByte((binaryFormatVersion &gt;&gt; bitsInByte) &amp; byteMask);
            output.WriteByte(binaryFormatVersion &amp; byteMask);

            output.WriteInt((int) _stringsBuffer.Position);
            output.Write(_stringsBuffer.GetBuffer(), 0, (int) _stringsBuffer.Position);
            output.WriteInt(_count);
            output.Write(_metricsBuffer.GetBuffer(), 0, (int) _metricsBuffer.Position);

            return buffer.ToArray();
        }

        public byte[] GetBytesAndReset()
        {
            var bytes = GetBytes();

            const int sizeFactoryNumerator = 11;
            const int sizeFactoryDenominator = 10;

            // TODO: use .Length vs .Position vs .Capacity?!
            var dictionaryBufferSize = (int) _stringsBuffer.Length * sizeFactoryNumerator / sizeFactoryDenominator;
            var metricsBufferSize = (int) _metricsBuffer.Length * sizeFactoryNumerator / sizeFactoryDenominator;
            Reset(dictionaryBufferSize, metricsBufferSize);

            return bytes;
        }

        [Flags]
        internal enum DescriptorMask : byte
        {
            None = 0,
            Prefix = 1,
            Name = 1 &lt;&lt; 1,
            DiscriminatorName = 1 &lt;&lt; 2,
            DiscriminatorValue = 1 &lt;&lt; 3,
            Unit = 1 &lt;&lt; 4,
            ExcludedTargets = 1 &lt;&lt; 5,
            TagCount = 1 &lt;&lt; 6
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[50,9,50,94,0],[55,9,55,35,0],[57,13,57,71,0],[60,13,60,67,0],[61,13,61,61,0],[62,9,62,10,0],[66,13,66,33,0],[69,13,69,65,0],[71,17,71,35,0],[72,17,72,49,0],[75,13,75,46,0],[76,13,76,107,0],[77,13,77,53,0],[78,9,78,10,0],[82,13,82,106,0],[83,13,83,106,0],[85,13,85,60,0],[86,13,86,24,0],[87,13,87,36,0],[88,13,88,29,0],[89,9,89,10,0],[93,13,93,27,0],[93,28,93,35,0],[94,13,94,30,0],[96,13,96,36,0],[98,13,98,47,0],[99,13,99,39,0],[101,13,101,47,0],[102,13,102,39,0],[103,9,103,10,0],[107,13,107,25,0],[107,26,107,87,0],[111,13,113,42,0],[116,17,116,24,0],[119,13,119,51,0],[120,13,120,49,0],[125,21,125,74,0],[126,21,126,65,0],[127,21,127,27,0],[129,21,129,72,0],[130,21,130,61,0],[131,21,131,27,0],[133,21,133,72,0],[134,21,134,60,0],[139,13,139,53,0],[139,54,139,155,0],[141,13,141,90,0],[142,9,142,10,0],[146,13,146,44,0],[147,13,147,48,0],[149,13,149,53,0],[150,17,150,70,0],[152,13,152,51,0],[153,17,153,68,0],[155,13,155,64,0],[156,17,156,80,0],[158,13,158,65,0],[159,17,159,82,0],[161,13,161,51,0],[162,17,162,63,0],[165,13,165,62,0],[166,17,166,42,0],[168,13,168,55,0],[169,17,169,69,0],[172,22,172,45,0],[172,46,172,48,0],[172,49,172,64,0],[174,17,174,60,0],[175,17,175,61,0],[178,13,178,22,0],[179,13,179,42,0],[180,9,180,10,0],[184,13,184,44,0],[187,13,187,52,0],[189,13,189,41,0],[190,17,190,29,0],[192,13,192,61,0],[193,17,193,47,0],[195,13,195,57,0],[196,17,196,45,0],[198,13,198,81,0],[199,17,199,58,0],[201,13,201,85,0],[202,17,202,59,0],[204,13,204,57,0],[205,17,205,45,0],[211,13,211,65,0],[212,17,212,49,0],[214,13,214,25,0],[219,13,219,27,0],[220,17,220,27,0],[222,13,222,53,0],[223,17,223,27,0],[225,13,225,33,0],[226,13,226,30,0],[227,13,227,23,0],[232,13,232,53,0],[233,13,233,31,0],[237,22,237,48,0],[237,49,237,51,0],[237,52,237,60,0],[241,17,241,55,0],[242,21,242,113,0],[245,17,245,81,0],[246,17,246,35,0],[247,17,247,97,0],[248,21,248,33,0],[251,17,251,61,0],[254,17,254,55,0],[257,17,257,48,0],[258,17,258,57,0],[259,17,259,55,0],[260,17,260,73,0],[263,17,263,57,0],[263,58,263,159,0],[265,17,265,94,0],[267,17,267,39,0],[269,9,269,10,0],[282,13,282,28,0],[284,13,284,29,0],[287,13,287,46,0],[288,13,288,43,0],[289,13,289,46,0],[290,13,290,43,0],[293,13,293,136,0],[296,13,296,45,0],[296,46,296,131,0],[297,13,297,56,0],[297,57,297,162,0],[298,13,298,56,0],[298,57,298,162,0],[300,13,300,69,0],[301,13,301,55,0],[304,13,304,78,0],[305,13,305,62,0],[307,13,307,60,0],[308,13,308,88,0],[309,13,309,37,0],[310,13,310,88,0],[312,13,312,37,0],[313,9,313,10,0],[317,13,317,36,0],[323,13,323,116,0],[324,13,324,113,0],[325,13,325,60,0],[327,13,327,26,0]]);
    </script>
  </body>
</html>