<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Clustering\ClusterMembers.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Hazelcast.Clustering.LoadBalancing;
using Hazelcast.Core;
using Hazelcast.Events;
using Hazelcast.Exceptions;
using Hazelcast.Models;
using Hazelcast.Networking;
using Microsoft.Extensions.Logging;

namespace Hazelcast.Clustering
{
    /// &lt;summary&gt;
    /// Provides the members management services of a cluster.
    /// &lt;/summary&gt;
    internal class ClusterMembers : IAsyncDisposable
    {
        private const int SqlConnectionRandomAttempts = 10;

        private readonly object _mutex = new object();
        private readonly ClusterState _clusterState;
        private readonly ILogger _logger;
        private readonly ILoadBalancer _loadBalancer;

        private readonly TerminateConnections _terminateConnections;
        private readonly MemberConnectionQueue _memberConnectionQueue;

        private MemberTable _members;
        private bool _connected;
        private bool _usePublicAddresses;

        // flag + semaphore to wait for the first &quot;partitions view&quot; event
        //private volatile int _firstPartitionsViewed;
        //private SemaphoreSlim _firstPartitionsView = new SemaphoreSlim(0, 1);

        // member id -&gt; connection
        // not concurrent, always managed through the mutex
        private readonly Dictionary&lt;Guid, MemberConnection&gt; _connections = new Dictionary&lt;Guid, MemberConnection&gt;();

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;ClusterMembers&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;clusterState&quot;&gt;The cluster state.&lt;/param&gt;
        /// &lt;param name=&quot;terminateConnections&quot;&gt;The terminate connections task.&lt;/param&gt;
        public ClusterMembers(ClusterState clusterState, TerminateConnections terminateConnections)
        {
            HConsole.Configure(x =&gt; x.Configure&lt;ClusterMembers&gt;().SetPrefix(&quot;CLUST.MBRS&quot;));

            _clusterState = clusterState;
            _terminateConnections = terminateConnections;
            _loadBalancer = clusterState.Options.LoadBalancer.Service ?? new RandomLoadBalancer();

            _logger = _clusterState.LoggerFactory.CreateLogger&lt;ClusterMembers&gt;();

            _members = new MemberTable();

            // members to connect
            if (clusterState.IsSmartRouting)
            {
                // initialize the queue of members to connect
                // and the handler to re-queue members that have failed, *if* they are still members
                _memberConnectionQueue = new MemberConnectionQueue(clusterState.LoggerFactory);
                _memberConnectionQueue.ConnectionFailed += (_, request) =&gt;
                {
                    lock (_mutex)
                    {
                        if (_members.ContainsMember(request.Member.Id))
                            _memberConnectionQueue.AddAgain(request);
                    }
                };
            }
        }

        // NOTES
        //
        // - we cannot have two connections to the same member ID at the same time, the AddConnection
        //   method makes sure that a second connection to the same member ID is either rejected, or
        //   replaces the existing one (depending on conditions).
        //
        // - a member can be associated with 3 addresses:
        //  - the address that we connected to
        //  - the address that was reported by the member when we connected to it
        //  - the address that was associated with the member in the members list
        //
        // we have always ignored the second address (as Java does) - we used to ignore the third
        // address too (as Java does) BUT this means that if we connect to a cluster via a load-
        // balancer, as is proposed in some k8s examples, traffic keeps going through the load-
        // balancer - and this is not ideal - so we implemented the following logic:
        //
        // - each member exposes a ConnectAddress which derives from the members list, and is the
        //   address that we assume the member wants us to connect to
        // - when we connect to a member at an address, and then later on receive a member list
        //   proposing a *different* address for the member, we terminate the original connection,
        //   triggering the reconnection mechanism to the member&#39;s ConnectAddress
        //
        // however, this breaks non-smart routing, as the reconnection mechanism does NOT activate
        // when routing is not smart : when the original connection is terminated, the client remains
        // disconnected.
        //
        // a general discussion is needed as to which address to use for members, in all clients.
        // however, in the short term, we need to fix non-smart routing, with two possible choices:
        // - run the reconnection mechanism for non-smart routing
        // - make the address-switching logic optional &amp; disabled for non-smart routing
        //
        // the first option may have unintended consequences, whereas the second &quot;just&quot; brings back
        // the old logic for non-smart routing -&gt; we choose the second option and implement a
        // switch feature in MatchMemberAddress

        // see notes above, determines whether to match members addresses
        // - we want to match for smart routing
        // - and also for Cloud?
        private bool MatchMemberAddress
            =&gt; _clusterState.Options.Networking.SmartRouting || _clusterState.Options.Networking.Cloud.Enabled;

        // see notes above, if matching then addresses must match, else anything matches
        private bool IsMemberAddress(MemberInfo member, NetworkAddress address)
            =&gt; !MatchMemberAddress || member.ConnectAddress == address;

        // determines whether a member is connected.
        private bool IsMemberConnected(MemberInfo member)
        {
            // a member is connected when it is registered, and has a connection
            return _members.ContainsMember(member.Id) &amp;&amp;
                   HasConnectionForMember(member);
        }

        // determines whether at least one member is connected.
        private bool IsAnyMemberConnected()
        {
            lock (_mutex) return _members.Members.Any(HasConnectionForMemberLocked);
        }

        private bool HasConnectionForMemberLocked(MemberInfo member)
            =&gt; _connections.TryGetValue(member.Id, out var connection) &amp;&amp; 
               IsMemberAddress(member, connection.Address);

        // determines whether we have a connection for a member
        private bool HasConnectionForMember(MemberInfo member)
        {
            lock (_mutex) return HasConnectionForMemberLocked(member);
        }

        // registers a connection for termination
        public void TerminateConnection(MemberConnection connection)
            =&gt; _terminateConnections.Add(connection);

        #region Event Handlers

        /// &lt;summary&gt;
        /// Adds a connection.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;connection&quot;&gt;The connection.&lt;/param&gt;
        /// &lt;param name=&quot;isNewCluster&quot;&gt;Whether the connection is the first connection to a new cluster.&lt;/param&gt;
        public void AddConnection(MemberConnection connection, bool isNewCluster)
        {
            // accept every connection, regardless of whether there is a known corresponding member,
            // since the first connection is going to come before we get the first members view.

            lock (_mutex)
            {
                // don&#39;t add the connection if it is not active - if it *is* active, it still
                // could turn not-active anytime, but thanks to _mutex that will only happen
                // after the connection has been added
                if (!connection.Active) return;

                var contains = _connections.TryGetValue(connection.MemberId, out var existingConnection);

                if (contains)
                {
                    if (MatchMemberAddress &amp;&amp; existingConnection.Address != connection.Address)
                    {
                        _terminateConnections.Add(existingConnection);
                    }
                    else
                    {
                        // we cannot accept this connection, it&#39;s a duplicate (internal error?)
                        _logger.IfWarning()?.LogWarning(&quot;Cannot add connection {ConnectionId} to member {MemberId} at {Address}, a connection to that member at that address already exists.&quot;, connection.Id.ToShortString(), connection.MemberId.ToShortString(), connection.Address);
                        _terminateConnections.Add(connection); // kill.kill.kill
                        return;
                    }
                }

                // add the connection
                _connections[connection.MemberId] = connection;

                if (isNewCluster)
                {
                    // reset members
                    // this is safe because... isNewCluster means that this is the very first connection and there are
                    // no other connections yet and therefore we should not receive events and therefore no one
                    // should invoke SetMembers.
                    _members = new MemberTable();
                }

                // if this is a true member connection
                if (_members.TryGetMember(connection.MemberId, out var member) &amp;&amp; IsMemberAddress(member, connection.Address))
                {
                    // if this is the first connection to an actual member, change state &amp; trigger event
                    if (!_connected)
                    {
                        // change Started | Disconnected -&gt; Connected, ignore otherwise, it could be ShuttingDown or Shutdown
                        _logger.IfDebug()?.LogDebug(&quot;Added connection {ConnectionId} to member {MemberId} at {Address}, now connected.&quot;, connection.Id.ToShortString(), connection.MemberId.ToShortString(), connection.Address);

                        if (_clusterState.Failover.IsChangingCluster)
                        {
                            // Started | Disconnected -&gt; connected BUT changing cluster, trigger ClusterChanged then Connected
                            _clusterState.ChangeState(ClientState.ClusterChanged, ClientState.Started, ClientState.Disconnected);
                            _clusterState.ChangeState(ClientState.Connected, ClientState.ClusterChanged);
                        }
                        else
                        {
                            // Started | Disconnected -&gt; connected NOT changing cluster, directly trigger Connected
                            _clusterState.ChangeState(ClientState.Connected, ClientState.Started, ClientState.Disconnected);
                        }

                        _connected = true;
                    }
                    else if (_logger.IsEnabled(LogLevel.Debug))
                    {
                        var msg = $&quot;Added connection {connection.Id.ToShortString()} to member {connection.MemberId.ToShortString()} at {connection.Address}&quot;;
                        msg += existingConnection == null
                            ? &quot;.&quot;
                            : $&quot;, replacing connection {existingConnection.Id.ToShortString()} at {existingConnection.Address}.&quot;;
                        _logger.IfDebug()?.LogDebug(msg);
                    }
                }
                else
                {
                    _logger.IfDebug()?.LogDebug(&quot;Added orphan connection {ConnectionId} at {Address} (member {MemberId}).&quot;, connection.Id.ToShortString(), connection.Address, connection.MemberId.ToShortString());
                }
            }
        }

        /// &lt;summary&gt;
        /// Removes a connection.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;connection&quot;&gt;The connection.&lt;/param&gt;
        public async Task RemoveConnectionAsync(MemberConnection connection)
        {
            lock (_mutex)
            {
                // ignore unknown connections that were not added in the first place,
                // or that have been replaced with another connection to the same member
                if (!_connections.TryGetValue(connection.MemberId, out var c) || connection.Id != c.Id)
                {
                    _logger.IfDebug()?.LogDebug(&quot;Removed orphan connection {ConnectionId}.&quot;, connection.Id.ToShortString());
                    return;
                }

                // remove the connection and check whether we are potentially disconnecting
                // ie whether we were connected, and either we don&#39;t have connections any more, or no member
                // is connected (has a matching connection)
                _connections.Remove(connection.MemberId);
                var disconnecting = _connected &amp;&amp; (_connections.Count == 0 || !IsAnyMemberConnected());

                // if we are not disconnecting, we can return - we are done
                if (!disconnecting)
                {
                    _logger.IfDebug()?.LogDebug($&quot;Removed connection {connection.Id.ToShortString()} to member {connection.MemberId.ToShortString()}, remain {(_connected ? &quot;&quot; : &quot;dis&quot;)}connected.&quot;);

                    // if we are connected,
                    // and the disconnected member is still a member, queue it for reconnection
                    if (_connected &amp;&amp; _members.TryGetMember(connection.MemberId, out var member))
                        _memberConnectionQueue?.Add(member);
                    return;
                }
            }

            // otherwise, we might be disconnecting

            // but, the connection queue was running and might have added a new connection
            // we *need* a stable state in order to figure out whether we are disconnecting or not,
            // and if we are, we *need* to drain the queue (stop connecting more members) - and
            // the only way to achieve this is to suspend the queue
            if (_memberConnectionQueue != null) await _memberConnectionQueue.SuspendAsync().CfAwait();

            // note: multiple connections can close an once = multiple calls can reach this point

            var drain = false;
            try
            {
                lock (_mutex) // but we deal with calls one by one
                {
                    if (_connected) // and only disconnect once
                    {
                        // if we have connections, and at least one member is connected (has a matching connection),
                        // then the queue has added a new connection indeed and we are finally not disconnecting - we
                        // can return - we are done
                        if (_connections.Count &gt; 0 &amp;&amp; _members.Members.Any(x =&gt; _connections.ContainsKey(x.Id)))
                        {
                            // if the disconnected member is still a member, queue it for reconnection
                            if (_members.TryGetMember(connection.MemberId, out var member))
                                _memberConnectionQueue?.Add(member);
                            _logger.IfDebug()?.LogDebug(&quot;Removed connection {ConnectionId} to member {MemberId}, remain connected.&quot;, connection.Id.ToShortString(), connection.MemberId.ToShortString());
                            return;
                        }

                        // otherwise, we&#39;re really disconnecting: flip _connected, and change the state
                        _connected = false;
                        _logger.IfDebug()?.LogDebug(&quot;Removed connection {ConnectionId} to member {MemberId}, disconnecting.&quot;, connection.Id.ToShortString(), connection.MemberId.ToShortString());
                        // FIXME ClusterChanged CANNOT go back to DISCONNECTED it WILL go to CONNECTED no matter what
                        _clusterState.ChangeState(ClientState.Disconnected, ClientState.Connected, ClientState.ClusterChanged);

                        // and drain the queue: stop connecting members, we need to fully reconnect
                        drain = true;
                    }
                    else
                    {
                        _logger.IfDebug()?.LogDebug(&quot;Removed connection {ConnectionId} to member {MemberId}, already disconnected (?).&quot;, connection.Id.ToShortString(), connection.MemberId.ToShortString());
                    }
                }
            }
            finally
            {
                // don&#39;t forget to resume the queue
                _memberConnectionQueue?.Resume(drain);
            }
        }

        private void LogDiffs(MemberTable table, Dictionary&lt;MemberInfo, int&gt; diff)
        {
            var countOfUnchanged = 0;
            var msg = new StringBuilder();
            msg.Append(&quot;Members [&quot;);
            msg.Append(table.Count);
            msg.AppendLine(&quot;] {&quot;);
            foreach (var (m, d) in diff)
            {
                msg.Append(&quot;    &quot;);
                msg.Append(m.ToShortString(true));
                string status;
                switch (d)
                {
                    case 1:
                        status = &quot;Removing&quot;;
                        break;
                    case 2:
                        status = &quot;Adding&quot;;
                        break;
                    case 3:
                        status = &quot;Unchanged&quot;;
                        countOfUnchanged++;
                        break;
                    default:
                        status = &quot;&quot;;
                        break;
                }

                msg.Append(&#39; &#39;);
                msg.Append(status);
                msg.AppendLine();
            }
            msg.Append(&#39;}&#39;);

            //Print only if there is a change
            if (countOfUnchanged != diff.Count)
                _logger.LogInformation(msg.ToString());
        }

        /// &lt;summary&gt;
        /// Set the members.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;version&quot;&gt;The version.&lt;/param&gt;
        /// &lt;param name=&quot;members&quot;&gt;The members.&lt;/param&gt;
        /// &lt;returns&gt;The corresponding event arguments, if members were updated; otherwise &lt;c&gt;null&lt;/c&gt;.&lt;/returns&gt;
        public async Task&lt;MembersUpdatedEventArgs&gt; SetMembersAsync(int version, ICollection&lt;MemberInfo&gt; members)
        {
            // skip old sets
            if (version &lt; _members.Version)
                return null;

            // note: members are compared by member.Id and member.ConnectAddress
            // as that is what makes a difference, really - the actual Address and
            // PublicAddress don&#39;t matter much for what we do

            // replace the table
            var previous = _members;
            var table = new MemberTable(version, members);
            lock (_mutex) _members = table;

            // notify the load balancer of the new list of members
            // (the load balancer can always return a member that is not a member
            // anymore, see note in GetMember)
            _loadBalancer.SetMembers(members.Select(x =&gt; x.Id));

            // members provided through the members view event always provide their own internal address,
            // and may (e.g. for Kubernetes clusters) also provide their public address - but in a Cloud
            // setup for instance, members are not aware of their public address. so, we try to &quot;fix&quot;
            // the members using the AddressProvider map, if any.
            if (_clusterState.AddressProvider.HasMap)
            {
                foreach (var member in members.Where(x =&gt; !x.HasPublicAddress))
                    member.PublicAddress = _clusterState.AddressProvider.Map(member.Address);
            }

            // and then we need to determine whether to connect to members through their internal address
            // or their public address - this is the role of the ConnectAddressResolver - it can be forced
            // through configuration options, or determined through rules:
            // - if one member responds on its internal address, assume internal addresses are OK
            // - if enough (sample size) members respond only on their public address, use public addresses
            // for performance reasons (and this is what the Java client does) we determine this
            // once when getting the first members view, and don&#39;t change our mind later on, ever.
            if (previous.Count == 0) // first members view
            {
                var resolver = new ConnectAddressResolver(_clusterState.Options.Networking, _clusterState.LoggerFactory);
                if (!(members is IReadOnlyCollection&lt;MemberInfo&gt; mro)) throw new HazelcastException(&quot;panic&quot;); // TODO: not exactly pretty
                _usePublicAddresses = await resolver.DetermineUsePublicAddresses(mro).CfAwaitNoThrow(false);
            }

            // update members
            foreach (var member in members) member.UsePublicAddress = _usePublicAddresses;

            // compute changes
            // count 1 for old members, 2 for new members, and then the result is
            // 1=removed, 2=added, 3=unchanged
            // MemberInfo overrides GetHashCode and can be used as a key here
            var diff = new Dictionary&lt;MemberInfo, int&gt;();
            if (previous == null)
            {
                foreach (var m in members)
                    diff[m] = 2;
            }
            else
            {
                foreach (var m in previous.Members)
                    diff[m] = 1;

                foreach (var m in members)
                    if (diff.ContainsKey(m)) diff[m] += 2;
                    else diff[m] = 2;
            }

            // log
            if (_logger.IsEnabled(LogLevel.Information))
                LogDiffs(table, diff);

            // process changes, gather events
            var added = new List&lt;MemberInfo&gt;();
            var removed = new List&lt;MemberInfo&gt;();
            foreach (var (member, status) in diff) // all members, old and new
            {
                switch (status)
                {
                    case 1: // old but not new = removed
                        HConsole.WriteLine(this, $&quot;Removed {member}&quot;);
                        removed.Add(member);

                        // dequeue the member
                        _memberConnectionQueue?.Remove(member.Id);

                        break;

                    case 2: // new but not old = added
                        HConsole.WriteLine(this, $&quot;Added {member}&quot;);
                        added.Add(member);

                        // queue the member for connection
                        _memberConnectionQueue?.Add(member);

                        break;

                    case 3: // old and new = no change
                        break;

                    default:
                        throw new NotSupportedException();
                }
            }

            var maybeDisconnected = false;
            lock (_mutex)
            {
                // removed members need to have their connection removed and terminated
                foreach (var member in removed)
                {
                    if (_connections.TryGetValue(member.Id, out var c))
                    {
                        _logger.IfDebug()?.LogDebug(&quot;Set members: remove obsolete connection {ConnectionId} to {MemberId} at {Address}.&quot;, c.Id.ToShortString(), c.MemberId.ToShortString(), c.Address);
                        _connections.Remove(member.Id);
                        _terminateConnections.Add(c);
                    }
                }

                // remove connections that don&#39;t match a member
                var d = members.ToDictionary(x =&gt; x.Id, x =&gt; x);
                List&lt;MemberConnection&gt; toRemove = null;
                foreach (var c in _connections.Values)
                {
                    if (!d.TryGetValue(c.MemberId, out var m) || !IsMemberAddress(m, c.Address))
                        (toRemove ??= new List&lt;MemberConnection&gt;()).Add(c);
                }

                if (toRemove != null)
                {
                    foreach (var c in toRemove)
                    {
                        _connections.Remove(c.Id);
                        _logger.IfDebug()?.LogDebug(&quot;Set members: remove orphaned connection {ConnectionId} to {MemberId} at {Address}.&quot;, c.Id.ToShortString(), c.MemberId.ToShortString(), c.Address);
                        _terminateConnections.Add(c);
                    }
                }

                var isAnyMemberConnected = IsAnyMemberConnected();

                if (!_connected)
                {
                    if (isAnyMemberConnected)
                    {
                        // if we were not connected and now one member happens to be connected then we are now connected
                        // we hold the mutex so nothing bad can happen
                        _logger.IfDebug()?.LogDebug(&quot;Set members: {RemovedCount} removed, {AddedCount} added, {MembersCount} total and at least one is connected, now connected.&quot;, removed.Count, added.Count, members.Count);

                        if (_clusterState.Failover.IsChangingCluster)
                        {
                            // Started | Disconnected -&gt; connected BUT changing cluster, trigger ClusterChanged then Connected
                            _clusterState.ChangeState(ClientState.ClusterChanged, ClientState.Started, ClientState.Disconnected);
                            _clusterState.ChangeState(ClientState.Connected, ClientState.ClusterChanged);
                        }
                        else
                        {
                            // Started | Disconnected -&gt; connected NOT changing cluster, directly trigger Connected
                            _clusterState.ChangeState(ClientState.Connected, ClientState.Started, ClientState.Disconnected);
                        }

                        _connected = true;
                    }
                    else
                    {
                        // remain disconnected
                        _logger.IfDebug()?.LogDebug(&quot;Set members: {RemovedCount} removed, {AddedCount} added, {MembersCount} total and none is connected, remain disconnected.&quot;, removed.Count, added.Count, members.Count);
                    }
                }
                else
                {
                    if (isAnyMemberConnected)
                    {
                        // remain connected
                        _logger.IfDebug()?.LogDebug(&quot;Set members: {RemovedCount} removed, {AddedCount} added, {MembersCount} total and at least one is connected, remain connected.&quot;, removed.Count, added.Count, members.Count);
                    }
                    else
                    {
                        // we probably are disconnected now
                        // but the connection queue is running and might have re-added a member
                        maybeDisconnected = true;
                    }
                }
            }

            // if we cannot be disconnected, we can return immediately
            if (!maybeDisconnected) return new MembersUpdatedEventArgs(added, removed, members.ToList());

            // else, suspend the queue - we need stable connections before we can make a decision
            if (_memberConnectionQueue != null) await _memberConnectionQueue.SuspendAsync().CfAwait();

            var disconnected = false;
            try
            {
                lock (_mutex)
                {
                    var isAnyMemberConnected = IsAnyMemberConnected();
                    if (!isAnyMemberConnected)
                    {
                        // no more connected member, we are now disconnected
                        _logger.IfDebug()?.LogDebug(&quot;Set members: {RemovedCount} removed, {AddedCount} added, {MembersCount} total and none connected, disconnecting.&quot;, removed.Count, added.Count, members.Count);
                        // FIXME ClusterChanged CANNOT go back to DISCONNECTED it WILL go to CONNECTED no matter what
                        _clusterState.ChangeState(ClientState.Disconnected, ClientState.Connected, ClientState.ClusterChanged);
                        _connected = false;
                        disconnected = true;
                    }
                    else
                    {
                        _logger.IfDebug()?.LogDebug(&quot;Set members: {RemovedCount} removed, {AddedCount} added, {MembersCount} total and at least one is connected, remain connected.&quot;, removed.Count, added.Count, members.Count);
                    }
                }
            }
            finally
            {
                // if we are now disconnected, make sure to drain the queue
                _memberConnectionQueue?.Resume(drain: disconnected);
            }

            return new MembersUpdatedEventArgs(added, removed, members.ToList());
        }

        #endregion


        /// &lt;summary&gt;
        /// Enumerates the members to connect.
        /// &lt;/summary&gt;
        public IAsyncEnumerable&lt;MemberConnectionRequest&gt; MemberConnectionRequests
            =&gt; _memberConnectionQueue;

        /// &lt;summary&gt;
        /// Gets a connection to a random member.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;A random client connection if available; otherwise &lt;c&gt;null&lt;/c&gt;.&lt;/returns&gt;
        /// &lt;para&gt;The connection should be active, but there is no guarantee it will not become immediately inactive.&lt;/para&gt;
        public MemberConnection GetRandomConnection()
        {
            MemberConnection connection;

            // In &quot;smart routing&quot; mode the clients connect to each member of the cluster. Since each
            // data partition uses the well known and consistent hashing algorithm, each client
            // can send an operation to the relevant cluster member, which increases the
            // overall throughput and efficiency. Smart mode is the default mode.
            //
            // In &quot;uni-socket&quot; mode the clients is required to connect to a single member, which
            // then behaves as a gateway for the other members. Firewalls, security, or some
            // custom networking issues can be the reason for these cases.

            if (_clusterState.IsSmartRouting)
            {
                // &quot;smart&quot; mode

                // limit the number of tries to the amount of known members, but
                // it is ok to try more than once, order to return a connection
                // that has a reasonable chance of being usable
                var count = _loadBalancer.Count;

                for (var i = 0; i &lt; count; i++)
                {
                    var memberId = _loadBalancer.GetMember();

                    // if the load balancer does not have members, break
                    if (memberId == Guid.Empty)
                        break;

                    // we cannot guarantee that the connection we&#39;ll return will not correspond to
                    // a member... that is not a member by the time it is used... but at least we
                    // can make sure it *still* is a member now
                    if (!_members.ContainsMember(memberId))
                        continue;

                    lock (_mutex)
                    {
                        if (_connections.TryGetValue(memberId, out connection))
                            return connection;
                    }
                }
            }

            // either &quot;smart&quot; mode but the load balancer did not return a member,
            // or &quot;uni-socket&quot; mode where there should only be once connection
            lock (_mutex) connection = _connections.Values.FirstOrDefault();

            // may be null
            return connection;
        }

        /// &lt;summary&gt;
        /// Gets connection to execute SQL queries/statements.
        /// &lt;/summary&gt;
        public MemberConnection GetConnectionForSql()
        {
            if (_clusterState.IsSmartRouting)
            {
                // There might be a race - the chosen member might be just connected or disconnected - try a
                // couple of times, the memberOfLargerSameVersionGroup returns a random connection,
                // we might be lucky...
                for (var i = 0; i &lt; SqlConnectionRandomAttempts; i++)
                {
                    var member = GetMemberForSql();
                    if (member == null) break;

                    if (TryGetConnection(member.Id, out var memberConnection))
                        return memberConnection;
                }
            }

            // Otherwise iterate over connections and return the first one that&#39;s not to a lite member
            MemberConnection firstConnection = null;

            lock (_mutex)
            {
                foreach (var (memberId, connection) in _connections)
                {
                    firstConnection ??= connection;

                    if (_members.TryGetMember(memberId, out var member) &amp;&amp; !member.IsLiteMember)
                        return connection;
                }
            }

            // Failed to get a connection to a data member, return first lite member instead
            // Lite members support DDL but note DML statements
            // https://docs.hazelcast.com/hazelcast/5.0-SNAPSHOT/sql/sql-statements.html
            return firstConnection;
        }

        /// &lt;summary&gt;
        /// Finds a larger same-version group of data members from a collection of members.
        /// Otherwise returns a random member from the group. If the same-version
        /// groups have the same size, returns a member from the newer group.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;see cref=&quot;MemberInfo&quot;/&gt; if one is found or &lt;c&gt;null&lt;/c&gt; otherwise.&lt;/returns&gt;
        /// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;If there are more than 2 distinct member versions found.&lt;/exception&gt;
        public MemberInfo GetMemberForSql()
        {
            (MemberVersion version0, MemberVersion version1) = (null, null);
            var (count0, count1) = (0, 0);

            foreach (var member in _members.Members)
            {
                if (member.IsLiteMember)
                    continue;

                var memberVersion = member.Version;

                if (version0 == null || version0.Equals(memberVersion, ignorePatchVersion: true))
                {
                    version0 = memberVersion;
                    count0++;
                }
                else if (version1 == null || version1.Equals(memberVersion, ignorePatchVersion: true))
                {
                    version1 = memberVersion;
                    count1++;
                }
                else
                {
                    var strVersion0 = version0.ToString(ignorePatchVersion: true);
                    var strVersion1 = version1.ToString(ignorePatchVersion: true);
                    var strVersion = memberVersion.ToString(ignorePatchVersion: true);

                    throw new InvalidOperationException(
                        $&quot;More than 2 distinct member versions found: {strVersion0}, {strVersion1}, {strVersion}&quot;
                    );
                }
            }

            // no data members
            if (count0 == 0)
                return null;

            int count;
            MemberVersion version;

            if (count0 &gt; count1 || (count0 == count1 &amp;&amp; version0 &gt; version1))
                (count, version) = (count0, version0);
            else
                (count, version) = (count1, version1);

            // otherwise return a random member from the larger group
            var randomIndex = RandomProvider.Next(count);
            foreach (var member in _members.Members)
            {
                if (!member.IsLiteMember &amp;&amp; member.Version.Equals(version, ignorePatchVersion: true))
                {
                    randomIndex--;
                    if (randomIndex &lt; 0)
                        return member;
                }
            }

            // should never get here
            throw new HazelcastException($&quot;Reached unexpected state in {nameof(GetMemberForSql)}.&quot;);
        }

        /// &lt;summary&gt;
        /// Gets the oldest active connection.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;The oldest active connection, or &lt;c&gt;null&lt;/c&gt; if no connection is active.&lt;/returns&gt;
        public MemberConnection GetOldestConnection()
        {
            lock (_mutex) return _connections.Values
                .Where(x =&gt; x.Active)
                .OrderBy(x =&gt; x.ConnectTime)
                .FirstOrDefault();
        }

        /// &lt;summary&gt;
        /// Tries to get a connection for a member.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;memberId&quot;&gt;The identifier of the member.&lt;/param&gt;
        /// &lt;param name=&quot;connection&quot;&gt;The connection.&lt;/param&gt;
        /// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt; if a connection to the specified member was found; otherwise &lt;c&gt;false&lt;/c&gt;.&lt;/returns&gt;
        /// &lt;para&gt;The connection should be active, but there is no guarantee it will not become immediately inactive.&lt;/para&gt;
        public bool TryGetConnection(Guid memberId, out MemberConnection connection)
        {
            lock (_mutex) return _connections.TryGetValue(memberId, out connection);
        }

        /// &lt;summary&gt;
        /// Gets information about each member.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;liteOnly&quot;&gt;Whether to only return lite members.&lt;/param&gt;
        /// &lt;returns&gt;The current members.&lt;/returns&gt;
        public IEnumerable&lt;MemberInfoState&gt; GetMembersAndState(bool liteOnly = false)
        {
            IEnumerable&lt;MemberInfo&gt; members = _members.Members;
            if (liteOnly) members = members.Where(x =&gt; x.IsLiteMember);

            lock (_mutex) return members.Select(x =&gt; new MemberInfoState(x, HasConnectionForMemberLocked(x))).ToList();
        }

        /// &lt;summary&gt;
        /// Gets information about each member.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;liteOnly&quot;&gt;Whether to only return lite members.&lt;/param&gt;
        /// &lt;returns&gt;The current members.&lt;/returns&gt;
        public IEnumerable&lt;MemberInfo&gt; GetMembers(bool liteOnly = false)
        {
            IEnumerable&lt;MemberInfo&gt; members = _members.Members;
            return liteOnly ? members.Where(x =&gt; x.IsLiteMember).ToList() : members;
        }

        /// &lt;summary&gt;
        /// Gets information about a member.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;memberId&quot;&gt;The identifier of the member.&lt;/param&gt;
        /// &lt;returns&gt;Information about the specified member, or &lt;c&gt;null&lt;/c&gt; if no member with the specified identifier was found.&lt;/returns&gt;
        public MemberInfo GetMember(Guid memberId)
        {
            return _members.TryGetMember(memberId, out var memberInfo)
                ? memberInfo
                : null;
        }

        /// &lt;inheritdoc /&gt;
        public async ValueTask DisposeAsync()
        {
            // no connection queue is assigned in unisocket mode
            if (_memberConnectionQueue != null)
                await _memberConnectionQueue.DisposeAsync().CfAwait();
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[37,9,37,55,1],[55,9,55,117,1],[62,9,62,100,1],[66,13,66,42,1],[67,13,67,58,1],[68,13,68,99,1],[70,13,70,82,1],[72,13,72,42,1],[75,13,75,45,1],[79,17,79,96,1],[80,17,82,21,1],[82,21,82,34,1],[82,34,84,25,1],[84,25,84,72,1],[84,72,85,29,1],[85,29,85,70,0],[85,70,86,21,1],[86,21,86,22,1],[86,22,87,17,1],[87,17,87,18,1],[87,18,87,19,1],[89,9,89,10,1],[130,16,130,111,1],[134,16,134,71,1],[140,13,141,51,0],[147,13,147,26,1],[147,27,147,85,1],[148,9,148,10,1],[151,16,152,59,1],[157,13,157,26,0],[157,27,157,71,0],[158,9,158,10,0],[162,16,162,53,0],[176,13,176,26,1],[181,17,181,40,1],[181,41,181,48,0],[183,17,183,106,1],[185,17,185,30,1],[187,21,187,96,0],[189,25,189,71,0],[194,25,194,280,0],[195,25,195,63,0],[196,25,196,32,0],[201,17,201,64,1],[203,17,203,34,1],[209,21,209,50,1],[213,17,213,127,1],[216,21,216,37,1],[219,25,219,226,1],[221,25,221,70,1],[224,29,224,130,0],[225,29,225,106,0],[230,29,230,125,1],[233,25,233,43,1],[235,26,235,64,1],[237,25,237,159,0],[238,25,240,130,0],[241,25,241,58,0],[246,21,246,213,1],[248,13,248,14,1],[249,9,249,10,1],[257,13,257,26,1],[261,17,261,104,1],[263,21,263,125,0],[264,21,264,28,0],[270,17,270,58,1],[271,17,271,104,1],[274,17,274,36,1],[276,21,276,198,1],[280,21,280,98,1],[281,25,281,61,1],[282,21,282,28,1],[284,13,284,14,1],[292,13,292,48,1],[292,49,292,103,1],[296,13,296,31,1],[299,17,299,30,1],[301,21,301,36,1],[306,25,306,113,1],[306,81,306,111,0],[309,29,309,92,0],[310,33,310,69,0],[311,29,311,202,0],[312,29,312,36,0],[316,25,316,44,1],[317,25,317,195,1],[319,25,319,128,1],[322,25,322,38,1],[326,25,326,206,0],[328,17,328,18,1],[329,13,329,14,1],[333,17,333,55,1],[335,9,335,10,1],[339,13,339,38,1],[340,13,340,43,1],[341,13,341,37,1],[342,13,342,37,1],[343,13,343,35,1],[344,22,344,32,1],[344,33,344,35,1],[344,36,344,40,1],[346,17,346,36,1],[347,17,347,51,1],[352,25,352,45,1],[353,25,353,31,1],[355,25,355,43,1],[356,25,356,31,1],[358,25,358,46,1],[359,25,359,44,1],[360,25,360,31,1],[362,25,362,37,0],[366,17,366,33,1],[367,17,367,36,1],[368,17,368,34,1],[370,13,370,29,1],[373,13,373,48,1],[374,17,374,56,1],[375,9,375,10,1],[386,13,386,44,1],[387,17,387,29,0],[394,13,394,37,1],[395,13,395,59,1],[396,13,396,26,1],[396,27,396,44,1],[401,13,401,58,1],[401,58,401,62,1],[401,62,401,65,1],[407,13,407,54,1],[409,26,409,36,0],[409,37,409,39,0],[409,40,409,59,0],[409,59,409,78,0],[409,78,409,79,0],[410,21,410,94,0],[420,13,420,37,1],[422,17,422,122,1],[423,17,423,71,1],[423,72,423,110,0],[424,17,424,109,1],[428,22,428,32,1],[428,33,428,35,1],[428,36,428,43,1],[428,45,428,91,1],[434,13,434,58,1],[435,13,435,34,1],[437,26,437,31,0],[437,32,437,34,0],[437,35,437,42,0],[438,21,438,33,0],[442,26,442,31,1],[442,32,442,34,1],[442,35,442,51,1],[443,21,443,33,1],[445,26,445,31,1],[445,32,445,34,1],[445,35,445,42,1],[446,21,446,45,1],[446,46,446,59,1],[447,26,447,38,1],[451,13,451,57,1],[452,17,452,39,1],[455,13,455,48,1],[456,13,456,50,1],[457,22,457,42,1],[457,43,457,45,1],[457,46,457,50,1],[463,25,463,45,1],[466,25,466,67,1],[468,25,468,31,1],[472,25,472,43,1],[475,25,475,61,1],[477,25,477,31,1],[483,25,483,59,0],[487,13,487,43,1],[488,13,488,26,1],[491,26,491,36,1],[491,37,491,39,1],[491,40,491,47,1],[493,21,493,72,1],[495,25,495,200,1],[496,25,496,56,1],[497,25,497,54,1],[502,17,502,51,1],[502,51,502,55,1],[502,55,502,62,1],[502,62,502,63,1],[502,63,502,65,1],[503,17,503,56,1],[504,26,504,31,1],[504,32,504,34,1],[504,35,504,54,1],[506,21,506,97,1],[507,25,507,76,0],[510,17,510,38,1],[512,30,512,35,0],[512,36,512,38,0],[512,39,512,47,0],[514,25,514,51,0],[515,25,515,200,0],[516,25,516,54,0],[520,17,520,67,1],[522,17,522,33,1],[524,21,524,46,1],[528,25,528,223,1],[530,25,530,70,1],[533,29,533,130,1],[534,29,534,106,1],[539,29,539,125,1],[542,25,542,43,1],[547,25,547,221,1],[552,21,552,46,1],[555,25,555,226,1],[561,25,561,50,0],[564,13,564,14,1],[567,13,567,36,1],[567,37,567,106,1],[570,13,570,48,0],[570,49,570,103,0],[572,13,572,38,0],[575,17,575,30,0],[577,21,577,71,0],[578,21,578,47,0],[581,25,581,212,0],[583,25,583,128,0],[584,25,584,44,0],[585,25,585,45,0],[589,25,589,226,0],[591,17,591,18,0],[592,13,592,14,0],[596,17,596,69,0],[599,13,599,82,0],[600,9,600,10,1],[609,16,609,38,1],[629,13,629,46,1],[636,17,636,49,1],[638,22,638,31,1],[638,33,638,42,1],[638,44,638,47,1],[640,21,640,62,1],[643,21,643,48,1],[649,21,649,60,1],[652,21,652,34,1],[654,25,654,80,1],[655,29,655,47,1],[656,21,656,22,1],[662,13,662,26,1],[662,27,662,77,1],[665,13,665,31,1],[666,9,666,10,1],[673,13,673,46,1],[678,22,678,31,1],[678,33,678,64,1],[678,66,678,69,0],[680,21,680,52,1],[681,21,681,40,1],[683,21,683,79,1],[684,25,684,49,1],[689,13,689,53,1],[691,13,691,26,1],[693,26,693,52,1],[693,53,693,55,1],[693,56,693,68,1],[695,21,695,52,1],[697,21,697,97,1],[698,25,698,43,1],[705,13,705,36,1],[706,9,706,10,1],[717,13,717,77,1],[718,13,718,43,1],[720,22,720,32,1],[720,33,720,35,1],[720,36,720,52,1],[722,17,722,41,1],[725,17,725,52,1],[727,17,727,98,1],[729,21,729,46,1],[730,21,730,30,1],[732,22,732,103,0],[734,21,734,46,0],[735,21,735,30,0],[739,21,739,83,0],[740,21,740,83,0],[741,21,741,87,0],[743,21,745,23,0],[750,13,750,29,1],[751,17,751,29,1],[756,13,756,78,1],[757,17,757,55,1],[759,17,759,55,0],[762,13,762,58,1],[763,22,763,32,1],[763,33,763,35,1],[763,36,763,52,1],[765,17,765,102,1],[767,21,767,35,1],[768,21,768,41,1],[769,25,769,39,1],[774,13,774,101,0],[775,9,775,10,1],[783,13,783,26,0],[783,27,784,29,0],[784,29,784,37,0],[784,37,785,31,0],[785,31,785,44,0],[785,44,786,35,0],[787,9,787,10,0],[798,13,798,26,1],[798,27,798,85,1],[799,9,799,10,1],[808,13,808,64,1],[809,13,809,26,1],[809,27,809,56,0],[809,56,809,70,0],[809,70,809,72,0],[811,13,811,26,1],[811,27,811,54,1],[811,54,811,109,1],[811,109,811,120,1],[812,9,812,10,1],[821,13,821,64,1],[822,13,822,50,1],[822,50,822,64,1],[822,64,822,85,1],[832,13,834,24,1],[841,13,841,48,1],[842,17,842,71,1],[843,9,843,10,1]]);
    </script>
  </body>
</html>