<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\DistributedObjects\DistributedObjectBase.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Hazelcast.Clustering;
using Hazelcast.Core;
using Hazelcast.Exceptions;
using Hazelcast.Partitioning.Strategies;
using Hazelcast.Serialization;
using Microsoft.Extensions.Logging;

namespace Hazelcast.DistributedObjects
{
    /// &lt;summary&gt;
    /// Provides a base class to distributed objects.
    /// &lt;/summary&gt;
    internal abstract class DistributedObjectBase : IDistributedObject
    {
        private readonly DistributedObjectFactory _factory;
        private bool _readonlyProperties; // whether some properties (_onXxx) are readonly
        private Action&lt;DistributedObjectBase&gt; _objectDisposed;
        private string _partitionKey;
        private IData _partitionKeyData;
        private int? _partitionId;

        private volatile int _disposed;

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;DistributedObjectBase&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;serviceName&quot;&gt;The name of the service managing this object.&lt;/param&gt;
        /// &lt;param name=&quot;name&quot;&gt;The unique name of the object.&lt;/param&gt;
        /// &lt;param name=&quot;factory&quot;&gt;The distributed object factory.&lt;/param&gt;
        /// &lt;param name=&quot;cluster&quot;&gt;A cluster.&lt;/param&gt;
        /// &lt;param name=&quot;serializationService&quot;&gt;A serialization service.&lt;/param&gt;
        /// &lt;param name=&quot;loggerFactory&quot;&gt;A logger factory.&lt;/param&gt;
        protected DistributedObjectBase(string serviceName, string name, DistributedObjectFactory factory, Cluster cluster, SerializationService serializationService, ILoggerFactory loggerFactory)
        {
            if (string.IsNullOrWhiteSpace(serviceName)) throw new ArgumentException(ExceptionMessages.NullOrEmpty, nameof(serviceName));
            ServiceName = serviceName;

            if (string.IsNullOrWhiteSpace(name)) throw new ArgumentException(ExceptionMessages.NullOrEmpty, nameof(name));
            Name = name;

            _factory = factory ?? throw new ArgumentNullException(nameof(factory));
            Cluster = cluster ?? throw new ArgumentNullException(nameof(cluster));
            SerializationService = serializationService ?? throw new ArgumentNullException(nameof(serializationService));
            LoggerFactory = loggerFactory ?? throw new ArgumentNullException(nameof(loggerFactory));
        }

        /// &lt;summary&gt;
        /// Gets or sets an action that will be executed when the object disposes.
        /// &lt;/summary&gt;
        public Action&lt;DistributedObjectBase&gt; ObjectDisposed
        {
            get =&gt; _objectDisposed;
            set
            {
                if (_readonlyProperties)
                    throw new InvalidOperationException(ExceptionMessages.PropertyIsNowReadOnly);
                _objectDisposed = value;
            }
        }

        /// &lt;inheritdoc /&gt;
        public string ServiceName { get; }

        /// &lt;inheritdoc /&gt;
        public string Name { get; }

        /// &lt;inheritdoc /&gt;
        public string PartitionKey =&gt; _partitionKey ??= StringPartitioningStrategy.GetPartitionKey(Name);

        /// &lt;summary&gt;
        /// Get the partition key data of this object.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;The partition key data is the &lt;see cref=&quot;IData&quot;/&gt; conversion of &lt;see cref=&quot;PartitionKey&quot;/&gt;.&lt;/para&gt;
        /// &lt;para&gt;This value makes sense only for distributed objects that access a single partition.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public IData PartitionKeyData =&gt; _partitionKeyData ??= ToData(PartitionKey);

        /// &lt;summary&gt;
        /// Gets the partition identifier of this object.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;The partition identifier derives from the &lt;see cref=&quot;PartitionKeyData&quot;/&gt;.&lt;/para&gt;
        /// &lt;para&gt;This value makes sense only for distributed objects that access a single partition.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public int PartitionId =&gt; _partitionId ??
                                  (_partitionId = Cluster.Partitioner.GetPartitionId(PartitionKeyData.PartitionHash)).Value;

        /// &lt;summary&gt;
        /// Gets the current context identifier.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// Hazelcast APIs call this the thread identified and maintain locks &quot;per threads&quot;,
        /// so we are keeping the name here internally, but in reality this is not a thread
        /// identifier anymore - it is attached to the async context so it can flow with
        /// async operations.
        /// &lt;/remarks&gt;
        protected static long ContextId =&gt; AsyncContext.Current.Id;

        /// &lt;summary&gt;
        /// Gets the serialization service.
        /// &lt;/summary&gt;
        protected SerializationService SerializationService { get; }

        /// &lt;summary&gt;
        /// Gets the cluster.
        /// &lt;/summary&gt;
        protected Cluster Cluster { get; }

        /// &lt;summary&gt;
        /// Gets the logger factory.
        /// &lt;/summary&gt;
        protected ILoggerFactory LoggerFactory { get; }

        /// &lt;inheritdoc /&gt;
        public async ValueTask DestroyAsync()
            =&gt; await _factory.DestroyAsync(this).CfAwait();

        /// &lt;summary&gt;
        /// Performs required operations when destroying an object (but before it is destroyed).
        /// &lt;/summary&gt;
        /// &lt;returns&gt;A task that will complete when done.&lt;/returns&gt;
        protected internal virtual ValueTask DestroyingAsync() =&gt; default;

        /// &lt;summary&gt;
        /// Serializes an object to &lt;see cref=&quot;IData&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;o&quot;&gt;The object.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;IData&quot;/&gt; serialized object.&lt;/returns&gt;
        protected virtual IData ToData(object o)
            =&gt; SerializationService.ToData(o);

        /// &lt;summary&gt;
        /// Serializes a non-null object to &lt;see cref=&quot;IData&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;o1&quot;&gt;The object.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;IData&quot;/&gt; serialized object.&lt;/returns&gt;
        /// &lt;exception cref=&quot;ArgumentNullException&quot;&gt;Occurs when the object is null.&lt;/exception&gt;
        protected IData ToSafeData(object o1)
        {
            if (o1 == null) throw new ArgumentNullException(nameof(o1));

            var data1 = ToData(o1);

            return data1;
        }

        /// &lt;summary&gt;
        /// Serializes non-null objects to &lt;see cref=&quot;IData&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The type of the objects.&lt;/typeparam&gt;
        /// &lt;param name=&quot;collection&quot;&gt;The collection of objects.&lt;/param&gt;
        /// &lt;returns&gt;The collection of &lt;see cref=&quot;IData&quot;/&gt; serialized objects.&lt;/returns&gt;
        /// &lt;exception cref=&quot;ArgumentNullException&quot;&gt;Occurs when the collection, or an object in the collection, is null.&lt;/exception&gt;
        protected ICollection&lt;IData&gt; ToSafeData&lt;T&gt;(ICollection&lt;T&gt; collection)
        {
            if (collection == null) throw new ArgumentNullException(nameof(collection));

            var data = new List&lt;IData&gt;(collection.Count);
            foreach (var item in collection) data.Add(ToData(item));
            return data;
        }

        /// &lt;summary&gt;
        /// Serializes non-null objects to &lt;see cref=&quot;IData&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;o1&quot;&gt;The first object.&lt;/param&gt;
        /// &lt;param name=&quot;o2&quot;&gt;The second objects.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;IData&quot;/&gt; serialized objects.&lt;/returns&gt;
        /// &lt;exception cref=&quot;ArgumentNullException&quot;&gt;Occurs when any of the objects is null.&lt;/exception&gt;
        protected (IData, IData) ToSafeData(object o1, object o2)
        {
            if (o1 == null) throw new ArgumentNullException(nameof(o1));
            if (o2 == null) throw new ArgumentNullException(nameof(o2));

            var data1 = ToData(o1);
            var data2 = ToData(o2);

            return (data1, data2);
        }

        /// &lt;summary&gt;
        /// Serializes non-null objects to &lt;see cref=&quot;IData&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;o1&quot;&gt;The first object.&lt;/param&gt;
        /// &lt;param name=&quot;o2&quot;&gt;The second objects.&lt;/param&gt;
        /// &lt;param name=&quot;o3&quot;&gt;The third objects.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;IData&quot;/&gt; serialized objects.&lt;/returns&gt;
        /// &lt;exception cref=&quot;ArgumentNullException&quot;&gt;Occurs when any of the objects is null.&lt;/exception&gt;
        protected (IData, IData, IData) ToSafeData(object o1, object o2, object o3)
        {
            if (o1 == null) throw new ArgumentNullException(nameof(o1));
            if (o2 == null) throw new ArgumentNullException(nameof(o2));
            if (o3 == null) throw new ArgumentNullException(nameof(o3));

            var data1 = ToData(o1);
            var data2 = ToData(o2);
            var data3 = ToData(o3);

            return (data1, data2, data3);
        }

        /// &lt;summary&gt;
        /// Deserializes an &lt;see cref=&quot;IData&quot;/&gt; serialized instance into an object.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;TObject&quot;&gt;The type of the object.&lt;/typeparam&gt;
        /// &lt;param name=&quot;data&quot;&gt;The &lt;see cref=&quot;IData&quot;/&gt; serialized instance.&lt;/param&gt;
        /// &lt;returns&gt;The deserialized object.&lt;/returns&gt;
        protected virtual TObject ToObject&lt;TObject&gt;(IData data)
            =&gt; SerializationService.ToObject&lt;TObject&gt;(data);

        /// &lt;summary&gt;
        /// Creates a lazy argument.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;TArg&quot;&gt;The type of the argument.&lt;/typeparam&gt;
        /// &lt;param name=&quot;source&quot;&gt;The source value.&lt;/param&gt;
        /// &lt;returns&gt;The lazy argument.&lt;/returns&gt;
        protected Lazy&lt;TArg&gt; LazyArg&lt;TArg&gt;(IData source)
            =&gt; source == null
                ? null
                : new Lazy&lt;TArg&gt;(() =&gt; ToObject&lt;TArg&gt;(source));

        /// &lt;summary&gt;
        /// Represents subscription state data.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;TEventHandlers&quot;&gt;The type of the event handlers.&lt;/typeparam&gt;
        protected class SubscriptionState&lt;TEventHandlers&gt;
        {
            /// &lt;summary&gt;
            /// Initializes a new instance of the &lt;see cref=&quot;SubscriptionState{TEventHandlers}&quot;/&gt; class.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;name&quot;&gt;The unique name of the distributed object.&lt;/param&gt;
            /// &lt;param name=&quot;handlers&quot;&gt;The event handlers.&lt;/param&gt;
            /// &lt;param name=&quot;handlerState&quot;&gt;A state object which is passed to handlers.&lt;/param&gt;
            public SubscriptionState(string name, TEventHandlers handlers, object handlerState)
            {
                Name = name;
                Handlers = handlers;
                HandlerState = handlerState;
            }

            /// &lt;summary&gt;
            /// Gets the unique name of the distributed object.
            /// &lt;/summary&gt;
            public string Name { get; }

            /// &lt;summary&gt;
            /// Gets the event handlers.
            /// &lt;/summary&gt;
            public TEventHandlers Handlers { get; }

            /// &lt;summary&gt;
            /// Gets the handler state.
            /// &lt;/summary&gt;
            public object HandlerState { get; }
        }

        /// &lt;summary&gt;
        /// Casts a subscription state, or throw.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The expected type.&lt;/typeparam&gt;
        /// &lt;param name=&quot;state&quot;&gt;The state object.&lt;/param&gt;
        /// &lt;returns&gt;The state object.&lt;/returns&gt;
        protected static T ToSafeState&lt;T&gt;(object state)
        {
            return state switch
            {
                null =&gt; default,
                T sstate =&gt; sstate,
                _ =&gt; throw new InvalidCastException(&quot;Invalid subscription state type.&quot;)
            };
        }

        /// &lt;summary&gt;
        /// Unsubscribe from events.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;subscriptionId&quot;&gt;The unique identifier of the subscription.&lt;/param&gt;
        /// &lt;returns&gt;Whether the operation completed successfully.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;Once this method has been invoked, and whatever its result, the subscription is
        /// de-activated, which means that no events will trigger anymore, even if the client
        /// receives event messages from the servers.&lt;/para&gt;
        /// &lt;para&gt;If this method returns &lt;c&gt;false&lt;/c&gt;, then one or more client connection has not
        /// been able to get its server to remove the subscription. Even though no events will
        /// trigger anymore, the server may keep sending (ignored) event messages. It is therefore
        /// recommended to retry unsubscribing until it is successful.&lt;/para&gt;
        /// &lt;/remarks&gt;
        protected
#if !HZ_OPTIMIZE_ASYNC
            async
#endif
        ValueTask&lt;bool&gt; UnsubscribeBaseAsync(Guid subscriptionId)
        {
            var task = Cluster.Events.RemoveSubscriptionAsync(subscriptionId, CancellationToken.None);

#if HZ_OPTIMIZE_ASYNC
            return task;
#else
            return await task.CfAwait();
#endif
        }

        public virtual void OnInitialized()
        {
            _readonlyProperties = true;
        }

        /// &lt;inheritdoc /&gt;
        public ValueTask DisposeAsync()
        {
            if (Interlocked.CompareExchange(ref _disposed, 1, 0) == 1)
                return default;

            _objectDisposed(this);

            return DisposeAsyncCore();
        }

        /// &lt;summary&gt;
        /// Disposes resources.
        /// &lt;/summary&gt;
        protected virtual ValueTask DisposeAsyncCore() =&gt; default;

        public override string ToString()
        {
            return $&quot;ServiceName = &#39;{ServiceName}&#39;, Name = &#39;{Name}&#39;, Type = &#39;{GetType().ToCsString()}&#39;&quot;;
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[51,9,51,197,0],[53,13,53,56,0],[53,57,53,137,0],[54,13,54,39,0],[56,13,56,49,0],[56,50,56,123,0],[57,13,57,25,0],[59,13,59,84,0],[60,13,60,83,0],[61,13,61,122,0],[62,13,62,101,0],[63,9,63,10,0],[70,20,70,35,0],[73,17,73,41,0],[74,21,74,98,0],[75,17,75,41,0],[76,13,76,14,0],[80,37,80,41,0],[83,30,83,34,0],[86,39,86,105,0],[95,42,95,84,0],[104,35,105,124,0],[116,44,116,67,0],[121,63,121,67,0],[126,37,126,41,0],[131,50,131,54,0],[135,16,135,59,0],[141,67,141,74,0],[149,16,149,46,0],[159,13,159,28,0],[159,29,159,73,0],[161,13,161,36,0],[163,13,163,26,0],[175,13,175,36,0],[175,37,175,89,0],[177,13,177,58,0],[178,22,178,30,0],[178,31,178,33,0],[178,34,178,44,0],[178,46,178,69,0],[179,13,179,25,0],[191,13,191,28,0],[191,29,191,73,0],[192,13,192,28,0],[192,29,192,73,0],[194,13,194,36,0],[195,13,195,36,0],[197,13,197,35,0],[210,13,210,28,0],[210,29,210,73,0],[211,13,211,28,0],[211,29,211,73,0],[212,13,212,28,0],[212,29,212,73,0],[214,13,214,36,0],[215,13,215,36,0],[216,13,216,36,0],[218,13,218,42,0],[228,16,228,60,0],[237,16,239,40,0],[239,40,239,62,0],[239,62,239,63,0],[253,13,253,96,0],[255,17,255,29,0],[256,17,256,37,0],[257,17,257,45,0],[258,13,258,14,0],[263,34,263,38,0],[268,46,268,50,0],[273,42,273,46,0],[284,13,286,25,0],[286,25,286,32,0],[286,32,287,29,0],[287,29,287,35,0],[287,35,288,22,0],[288,22,288,88,0],[288,88,289,15,0],[312,13,312,103,0],[317,13,317,41,0],[319,9,319,10,0],[323,13,323,40,0],[324,9,324,10,0],[329,13,329,71,0],[330,17,330,32,0],[332,13,332,35,0],[334,13,334,39,0],[340,59,340,66,0],[344,13,344,105,0]]);
    </script>
  </body>
</html>