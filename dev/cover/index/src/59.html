<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Serialization\SerializationService.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Reflection;
using System.Threading;
using Hazelcast.Core;
using Hazelcast.Partitioning.Strategies;
using Microsoft.Extensions.Logging;

namespace Hazelcast.Serialization
{
    internal class SerializationService : IDisposable
    {
        public const byte SerializerVersion = 1;
        private const int ConstantSerializersSize = SerializationConstants.ConstantSerializersArraySize;

        private static readonly IPartitioningStrategy TheEmptyPartitioningStrategy = new EmptyPartitioningStrategy();
        private readonly ILogger _logger;

        private readonly ISerializerAdapter[] _constantTypeIds = new ISerializerAdapter[ConstantSerializersSize];

        private readonly Dictionary&lt;Type, ISerializerAdapter&gt; _constantTypesMap =
            new Dictionary&lt;Type, ISerializerAdapter&gt;(ConstantSerializersSize);

        private readonly ISerializerAdapter _dataSerializerAdapter;
        private volatile ISerializerAdapter _global;

        private readonly ConcurrentDictionary&lt;int, ISerializerAdapter&gt; _idMap =
            new ConcurrentDictionary&lt;int, ISerializerAdapter&gt;();

        // private readonly IInputOutputFactory _inputOutputFactory;
        private readonly ISerializerAdapter _nullSerializerAdapter;
        private readonly int _initialOutputBufferSize;
        private readonly PortableContext _portableContext;
        private readonly PortableSerializer _portableSerializer;
        private readonly ISerializerAdapter _portableSerializerAdapter;
        private readonly ISerializerAdapter _serializableSerializerAdapter;

        private readonly ConcurrentDictionary&lt;Type, ISerializerAdapter&gt; _typeMap =
            new ConcurrentDictionary&lt;Type, ISerializerAdapter&gt;();

        protected internal readonly IPartitioningStrategy GlobalPartitioningStrategy;

        private bool _overrideClrSerialization;

        internal SerializationService(Endianness endianness, int version,
            IDictionary&lt;int, IDataSerializableFactory&gt; dataSerializableFactories,
            IDictionary&lt;int, IPortableFactory&gt; portableFactories, ICollection&lt;IClassDefinition&gt; classDefinitions,
            SerializerHooks hooks,
            IEnumerable&lt;ISerializerDefinitions&gt; definitions,
            bool checkClassDefErrors, IPartitioningStrategy partitioningStrategy, int initialOutputBufferSize,
            ILoggerFactory loggerFactory)
        {
            _logger = loggerFactory.CreateLogger&lt;SerializationService&gt;();
            Endianness = endianness;
            GlobalPartitioningStrategy = partitioningStrategy;
            _initialOutputBufferSize = initialOutputBufferSize;
            _portableContext = new PortableContext(this, version);

            // create data serializer (will be added as constant)
            var dataSerializer = new DataSerializer(hooks, dataSerializableFactories, loggerFactory);
            _dataSerializerAdapter = CreateSerializerAdapter&lt;IIdentifiedDataSerializable&gt;(dataSerializer);

            // create portable serializer (will be added as constant)
            _portableSerializer = new PortableSerializer(_portableContext, portableFactories);
            _portableSerializerAdapter = CreateSerializerAdapter&lt;IPortable&gt;(_portableSerializer);

            // create the serializer of null objects (will be added as constant)
            _nullSerializerAdapter = CreateSerializerAdapter&lt;object&gt;(new NullSerializer());

            // create the serializable adapter (will be added as constant)
            _serializableSerializerAdapter = CreateSerializerAdapter&lt;object&gt;(new SerializableSerializer());

            // add defined serializers
            foreach (var definition in definitions)
                definition.AddSerializers(this);

            // add constant serializers
            AddMoreSerializers();

            // add class definitions
            RegisterClassDefinitions(classDefinitions, checkClassDefErrors);
        }

#pragma warning disable CA1822 // Mark members as static - might not remain constant forever
        public byte GetVersion() =&gt; SerializerVersion;
#pragma warning restore CA1822

        public virtual IPortableContext GetPortableContext() =&gt; _portableContext;

        public Endianness Endianness { get; }

        #region DataOutput / DataInput

        private ObjectDataOutput GetDataOutput()
        {
            //TODO pooling
            return CreateObjectDataOutput();
        }

        private static void ReturnDataOutput(ObjectDataOutput output)
        {
            //TODO pooling
            output.Dispose();
        }

        private ObjectDataInput GetDataInput(IData data)
        {
            //TODO pooling
            return new ObjectDataInput(data.ToByteArray(), this, Endianness, HeapData.DataOffset);
        }

        private static void ReturnDataInput(ObjectDataInput input)
        {
            //TODO pooling
            input.Dispose();
        }

        #endregion

        #region ToData, WriteObject, ToObject, ReadObject

        public IData ToData(object o)
            =&gt; ToData(o, GlobalPartitioningStrategy);

        public IData ToData(object o, IPartitioningStrategy strategy)
        {
            if (o is null) return null;
            if (o is IData data) return data;

            var output = GetDataOutput();

            try
            {
                var serializer = SerializerFor(o);
                var partitionHash = CalculatePartitionHash(o, strategy);
                output.WriteIntBigEndian(partitionHash);
                output.WriteIntBigEndian(serializer.TypeId);
                serializer.Write(output, o);
                return new HeapData(output.ToByteArray());
            }
            catch (Exception e) when (!(e is OutOfMemoryException) &amp;&amp; !(e is SerializationException))
            {
                throw new SerializationException(e);
            }
            finally
            {
                ReturnDataOutput(output);
            }
        }

        public T ToObject&lt;T&gt;(object o)
        {
            var oo = ToObject(o);
            return oo switch
            {
                null =&gt; default,
                T ot =&gt; ot,
                _ =&gt; throw new InvalidCastException($&quot;Deserialized object is of type {oo.GetType()}, not {typeof(T)}.&quot;)
            };
        }

        public object ToObject(object o)
        {
            if (!(o is IData data))
                return o;

            // TODO: but, if returned, why is it disposable in the first place?
            var input = GetDataInput(data);
            try
            {
                var typeId = data.TypeId;
                var serializer = SerializerFor(typeId);
                if (serializer == null) ThrowMissingSerializer(typeId);
                return serializer.Read(input);
            }
            catch (Exception e) when (!(e is OutOfMemoryException) &amp;&amp; !(e is SerializationException))
            {
                throw new SerializationException(e);
            }
            finally
            {
                ReturnDataInput(input);
            }
        }

        public void WriteObject(IObjectDataOutput output, object o)
        {
            if (output == null) throw new ArgumentNullException(nameof(output));
            if (o is IData) throw new SerializationException(&quot;Cannot write IData. Use WriteData instead.&quot;);

            try
            {
                var serializer = SerializerFor(o);
                output.WriteInt(serializer.TypeId);
                serializer.Write(output, o);
            }
            catch (Exception e) when (!(e is OutOfMemoryException) &amp;&amp; !(e is SerializationException))
            {
                throw new SerializationException(e);
            }
        }

        private static bool CanBeNull&lt;T&gt;()
        {
            var typeOfT = typeof(T);

            var isValueType = typeOfT.IsValueType;
            if (!isValueType) return true;

#pragma warning disable CA1508 // Avoid dead conditional code
            // false positive, https://github.com/dotnet/roslyn-analyzers/issues/4763
            var isNullableType = typeOfT.IsNullableType();
#pragma warning restore CA1508
            if (isNullableType) return true;

            return false;
        }

        public T ReadObject&lt;T&gt;(IObjectDataInput input)
        {
            if (input == null) throw new ArgumentNullException(nameof(input));

            try
            {
                var typeId = input.ReadInt();
                var serializer = SerializerFor(typeId);
                if (serializer == null)
                    ThrowMissingSerializer(typeId);

                var o = serializer.Read(input);
                if (o is T ot) return ot;

                if (o is null)
                {
                    if (CanBeNull&lt;T&gt;()) return default;
                    throw new SerializationException($&quot;Deserialized null value cannot be of value type {typeof(T)}.&quot;);
                }

                throw new InvalidCastException($&quot;Deserialized object is of type {o.GetType()}, not {typeof(T)}.&quot;);
            }
            catch (Exception e) when (!(e is OutOfMemoryException) &amp;&amp; !(e is SerializationException))
            {
                throw new SerializationException(e);
            }
        }

        [DoesNotReturn]
        private static void ThrowMissingSerializer(int typeId)
        {
            throw new SerializationException($&quot;Could not find a serializer for type {typeId}.&quot;);
        }

        [DoesNotReturn]
        private static void ThrowMissingSerializer(Type type)
        {
            throw new SerializationException($&quot;Could not find a serializer for type {type}.&quot;);
        }

        #endregion

        #region Create object data input/output

        public ObjectDataInput CreateObjectDataInput(byte[] data)
            =&gt; new ObjectDataInput(data, this, Endianness);

        public ObjectDataInput CreateObjectDataInput(IData data)
            =&gt; new ObjectDataInput(data.ToByteArray(), this, Endianness, HeapData.DataOffset);

        public ObjectDataOutput CreateObjectDataOutput(int size)
            =&gt; new ObjectDataOutput(size, this, Endianness);

        public ObjectDataOutput CreateObjectDataOutput()
            =&gt; new ObjectDataOutput(_initialOutputBufferSize, this, Endianness);

        #endregion

        #region Register constant serializers (cannot be overriden)

        private void AddMoreSerializers()
        {
            AddConstantSerializer(null, _nullSerializerAdapter); // TODO: why add it?
            AddConstantSerializer&lt;IIdentifiedDataSerializable&gt;(_dataSerializerAdapter); // TODO: why add it?
            AddConstantSerializer&lt;IPortable&gt;(_portableSerializerAdapter); // TODO: why add it?
            _idMap.TryAdd(_serializableSerializerAdapter.TypeId, _serializableSerializerAdapter); // TODO: why add it?
        }

        private void AddConstantSerializer(Type type, ISerializerAdapter adapter)
        {
            if (adapter == null) throw new ArgumentNullException(nameof(adapter));

            if (type != null)
                _constantTypesMap.Add(type, adapter);

            _constantTypeIds[IndexForDefaultType(adapter.TypeId)] = adapter;
        }

        private void AddConstantSerializer(Type type, ISerializer serializer)
            =&gt; AddConstantSerializer(type, CreateSerializerAdapter(type, serializer));

        public void AddConstantSerializer&lt;TSerialized&gt;(ISerializerAdapter adapter)
            =&gt; AddConstantSerializer(typeof(TSerialized), adapter);

        public void AddConstantSerializer&lt;TSerialized&gt;(ISerializer serializer)
            =&gt; AddConstantSerializer&lt;TSerialized&gt;(CreateSerializerAdapter&lt;TSerialized&gt;(serializer));

        private static MethodInfo _createSerializerAdapter;

        private ISerializerAdapter CreateSerializerAdapter(Type type, ISerializer serializer)
        {
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (serializer == null) throw new ArgumentNullException(nameof(serializer));

            if (_createSerializerAdapter == null)
            {
                var method = typeof(SerializationService).GetMethods(BindingFlags.Static | BindingFlags.NonPublic)
                    .FirstOrDefault(x =&gt; x.Name == nameof(CreateSerializerAdapter) &amp;&amp; x.IsGenericMethod);
                if (method == null)
                    throw new ServiceFactoryException(&quot;Internal error (failed to get CreateSerializerAdapter method).&quot;);
                _createSerializerAdapter = method.GetGenericMethodDefinition();
            }

            var createSerializerAdapter = _createSerializerAdapter.MakeGenericMethod(type);
            return (ISerializerAdapter) createSerializerAdapter.Invoke(this, new object[] {serializer});
        }

        private static ISerializerAdapter CreateSerializerAdapter&lt;T&gt;(ISerializer serializer)
        {
            return serializer switch
            {
                IStreamSerializer&lt;T&gt; streamSerializer =&gt; new StreamSerializerAdapter&lt;T&gt;(streamSerializer),
                IByteArraySerializer&lt;T&gt; arraySerializer =&gt; new ByteArraySerializerAdapter&lt;T&gt;(arraySerializer),
                _ =&gt; throw new ArgumentException(&quot;Serializer must be instance of either StreamSerializer or ByteArraySerializer.&quot;)
            };
        }

        #endregion

        #region Register configured serializers (cannot override constants)

        public void AddConfiguredSerializer(Type type, ISerializer serializer)
        {
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (serializer == null) throw new ArgumentNullException(nameof(serializer));
            if (serializer.TypeId &lt;= 0)
                throw new ArgumentException($&quot;Serializer {serializer} has invalid id {serializer.TypeId}&quot;, nameof(serializer));

            AddSerializer(type, CreateSerializerAdapter(type, serializer));
        }

        private bool AddSerializer(Type type, ISerializerAdapter adapter)
        {
            if (_constantTypesMap.ContainsKey(type))
                throw new ArgumentException($&quot;Type {type} is a constant type and its serializer cannot be overridden.&quot;,
                    nameof(type));

            var added = true;

            if (!_typeMap.TryAdd(type, adapter))
            {
                added = false;
                var existing = _typeMap[type];
                if (existing.Serializer.GetType() != adapter.Serializer.GetType())
                    throw new InvalidOperationException(
                        $&quot;Serializer {existing.Serializer} has already been registered for type {type}.&quot;);
            }

            if (!_idMap.TryAdd(adapter.TypeId, adapter))
            {
                added = false;
                var existing = _idMap[adapter.TypeId];
                if (existing.Serializer.GetType() != adapter.Serializer.GetType())
                    throw new InvalidOperationException(
                        $&quot;Serializer {existing.Serializer} has already been registered for type id {adapter.TypeId}.&quot;);
            }

            return added;
        }

        private void AddSerializer(Type type, ISerializer serializer)
        {
            AddSerializer(type, CreateSerializerAdapter(type, serializer));
        }

        public void SetGlobalSerializer(ISerializer serializer, bool overrideClrSerialization)
        {
            if (serializer == null) throw new ArgumentNullException(nameof(serializer));

            var adapter = CreateSerializerAdapter&lt;object&gt;(serializer);
            if (Interlocked.CompareExchange(ref _global, adapter, null) != null)
                throw new InvalidOperationException(&quot;Global serializer is already registered!&quot;);

            _overrideClrSerialization = overrideClrSerialization;
            if (!_idMap.TryAdd(serializer.TypeId, adapter))
            {
                var existing = _idMap[serializer.TypeId];
                if (existing.Serializer.GetType() != adapter.Serializer.GetType())
                {
                    Interlocked.CompareExchange(ref _global, null, adapter);
                    _overrideClrSerialization = false;
                    throw new InvalidOperationException(
                        $&quot;Serializer {existing.Serializer} has already been registered for type id {adapter.TypeId}.&quot;);
                }
            }
        }

        #endregion

        #region Get serializers

        /// &lt;summary&gt;
        /// (internal for tests only)
        /// Gets the portable serializer.
        /// &lt;/summary&gt;
        internal PortableSerializer PortableSerializer =&gt; _portableSerializer;

        private ISerializerAdapter SerializerFor(object obj)
        {
            // try
            // - null serializer if object is null
            // - default
            // - custom
            // - clr
            // - global

            if (obj == null) return _nullSerializerAdapter;

            var type = obj.GetType();

            var serializer = LookupDefaultSerializer(type) ??
                             LookupCustomSerializer(type) ??
                             (_overrideClrSerialization ? null : LookupSerializableSerializer(type)) ??
                             LookupGlobalSerializer(type);

            if (serializer == null) ThrowMissingSerializer(type);
            return serializer;
        }

        protected internal ISerializerAdapter SerializerFor(int typeId)
        {
            if (typeId &lt;= 0)
            {
                var index = IndexForDefaultType(typeId);
                if (index &lt; ConstantSerializersSize &amp;&amp;
                    index != IndexForDefaultType(SerializationConstants.CsharpClrSerializationType))
                {
                    return _constantTypeIds[index];
                }
            }

            return _idMap.TryGetValue(typeId, out var result) ? result : default;
        }

        // lookup default serializer
        // - data serializable
        // - portable
        // - constant types
        private ISerializerAdapter LookupDefaultSerializer(Type type)
        {
            // fast path for data serializable
            if (typeof(IIdentifiedDataSerializable).IsAssignableFrom(type))
                return _dataSerializerAdapter;

            // fast path for portable serialization
            if (typeof(IPortable).IsAssignableFrom(type))
                return _portableSerializerAdapter;

            // else, look for constant serializer
            if (!_constantTypesMap.TryGetValue(type, out var serializer))
                return null;

            if (serializer == null) throw new SerializationException($&quot;Failed to find default serializer for type {type}.&quot;);
            return serializer;
        }

        private ISerializerAdapter LookupCustomSerializer(Type type)
        {
            _typeMap.TryGetValue(type, out var serializer);
            if (serializer == null)
            {
                // look for super classes
                var typeSuperclass = type.BaseType;
                ICollection&lt;Type&gt; interfaces = new HashSet&lt;Type&gt;(); //new Type[5]);
                GetInterfaces(type, interfaces);
                while (typeSuperclass != null)
                {
                    serializer = RegisterFromSuperType(type, typeSuperclass);
                    if (serializer != null)
                    {
                        break;
                    }

                    GetInterfaces(typeSuperclass, interfaces);
                    typeSuperclass = typeSuperclass.BaseType;
                }

                if (serializer == null)
                {
                    // look for interfaces
                    foreach (var typeInterface in interfaces)
                    {
                        serializer = RegisterFromSuperType(type, typeInterface);
                        if (serializer != null)
                        {
                            break;
                        }
                    }
                }
            }

            return serializer;
        }

        // lookup for CLR serialization (IsSerializable type)
        private ISerializerAdapter LookupSerializableSerializer(Type type)
        {
            if (!type.IsSerializable) return null;

            // register so we find it faster next time
            if (AddSerializer(type, _serializableSerializerAdapter))
            {
                _logger.LogWarning(&quot;Performance hint: Serialization service will use the CLR serialization &quot; +
                                   $&quot;for type {type}. Please consider using a faster serialization option such as &quot; +
                                   &quot;IIdentifiedDataSerializable.&quot;);
            }

            return _serializableSerializerAdapter;
        }

        // fallback to global serializer
        private ISerializerAdapter LookupGlobalSerializer(Type type)
        {
            var serializer = _global;

            // register so we find it faster next time
            if (serializer != null)
                AddSerializer(type, serializer);

            return serializer;
        }

        #endregion

        public virtual void DisposeData(IData data)
        {
        }

        /// &lt;exception cref=&quot;System.IO.IOException&quot;&gt;&lt;/exception&gt;
        public IPortableReader CreatePortableReader(IData data)
        {
            if (!data.IsPortable)
            {
                throw new ArgumentException(&quot;Given data is not Portable! -&gt; &quot; + data.TypeId);
            }

            ObjectDataInput input = null;
            IPortableReader reader;
            try
            {
                input = CreateObjectDataInput(data);
                reader = _portableSerializer.CreateReader(input);
                input = null;
            }
            finally
            {
#pragma warning disable CA1508 // Avoid dead conditional code - false positive
                input?.Dispose();
#pragma warning restore CA1508
            }

            return reader;
        }

        public virtual void Dispose()
        {
            foreach (var serializer in _typeMap.Values)
            {
                serializer.Dispose();
            }

            _typeMap.Clear();
            _idMap.Clear();
            Interlocked.Exchange(ref _global, null);
            _constantTypesMap.Clear();

            _portableSerializer.Dispose();

            _nullSerializerAdapter.Dispose();
            _portableSerializerAdapter.Dispose();
            _dataSerializerAdapter.Dispose();
            _serializableSerializerAdapter.Dispose();
        }

        protected internal int CalculatePartitionHash(object obj, IPartitioningStrategy strategy)
        {
            var partitionHash = 0;
            var partitioningStrategy = strategy ?? GlobalPartitioningStrategy;
            var pk = partitioningStrategy?.GetPartitionKey(obj);
            if (pk != null &amp;&amp; pk != obj)
            {
                var partitionKey = ToData(pk, TheEmptyPartitioningStrategy);
                partitionHash = partitionKey?.PartitionHash ?? 0;
            }

            return partitionHash;
        }

        internal static bool IsNullData(IData data)
        {
            return data.DataSize == 0 &amp;&amp; data.TypeId == SerializationConstants.ConstantTypeNull;
        }

        private static void GetInterfaces(Type type, ICollection&lt;Type&gt; interfaces)
        {
            var types = type.GetInterfaces();
            if (types.Length &gt; 0)
            {
                foreach (var t in types)
                {
                    interfaces.Add(t);
                }

                foreach (var cl in types)
                {
                    GetInterfaces(cl, interfaces);
                }
            }
        }

        private static int IndexForDefaultType(int typeId)
        {
            return -typeId;
        }


        private void RegisterClassDefinition(IClassDefinition cd, IDictionary&lt;int, IClassDefinition&gt; classDefMap,
            bool checkClassDefErrors)
        {
            for (var i = 0; i &lt; cd.GetFieldCount(); i++)
            {
                var fd = cd.GetField(i);
                if (fd.FieldType == FieldType.Portable || fd.FieldType == FieldType.PortableArray)
                {
                    var classId = fd.ClassId;
                    classDefMap.TryGetValue(classId, out var nestedCd);
                    if (nestedCd != null)
                    {
                        RegisterClassDefinition(nestedCd, classDefMap, checkClassDefErrors);
                        _portableContext.RegisterClassDefinition(nestedCd);
                    }
                    else
                    {
                        if (checkClassDefErrors)
                        {
                            throw new SerializationException(
                                &quot;Could not find registered ClassDefinition for class-id: &quot; + classId);
                        }
                    }
                }
            }

            _portableContext.RegisterClassDefinition(cd);
        }

        private void RegisterClassDefinitions(ICollection&lt;IClassDefinition&gt; classDefinitions, bool checkClassDefErrors)
        {
            IDictionary&lt;int, IClassDefinition&gt; classDefMap =
                new Dictionary&lt;int, IClassDefinition&gt;(classDefinitions.Count);
            foreach (var cd in classDefinitions)
            {
                if (classDefMap.ContainsKey(cd.ClassId))
                {
                    throw new SerializationException(&quot;Duplicate registration found for class-id[&quot; +
                                                     cd.ClassId + &quot;]!&quot;);
                }

                classDefMap.Add(cd.ClassId, cd);
            }

            foreach (var classDefinition in classDefinitions)
            {
                RegisterClassDefinition(classDefinition, classDefMap, checkClassDefErrors);
            }
        }

        private ISerializerAdapter RegisterFromSuperType(Type type, Type superType)
        {
            _typeMap.TryGetValue(superType, out var serializer);
            if (serializer != null)
            {
                AddSerializer(type, serializer);
            }

            return serializer;
        }

        private sealed class EmptyPartitioningStrategy : IPartitioningStrategy
        {
            public object GetPartitionKey(object key)
            {
                return null;
            }
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[33,9,33,118,0],[36,9,36,114,0],[38,9,39,79,0],[44,9,45,65,0],[55,9,56,66,0],[62,9,68,42,0],[70,13,70,74,0],[71,13,71,37,0],[72,13,72,63,0],[73,13,73,64,0],[74,13,74,67,0],[77,13,77,102,0],[78,13,78,107,0],[81,13,81,95,0],[82,13,82,98,0],[85,13,85,92,0],[88,13,88,108,0],[91,22,91,36,0],[91,37,91,39,0],[91,40,91,51,0],[92,17,92,49,0],[95,13,95,34,0],[98,13,98,77,0],[99,9,99,10,0],[102,37,102,54,0],[105,65,105,81,0],[107,40,107,44,0],[114,13,114,45,0],[120,13,120,30,0],[121,9,121,10,0],[126,13,126,99,0],[132,13,132,29,0],[133,9,133,10,0],[140,16,140,53,0],[144,13,144,27,0],[144,28,144,40,0],[145,13,145,33,0],[145,34,145,46,0],[147,13,147,42,0],[151,17,151,51,0],[152,17,152,73,0],[153,17,153,57,0],[154,17,154,61,0],[155,17,155,45,0],[156,17,156,59,0],[158,33,158,102,0],[160,17,160,53,0],[164,17,164,42,0],[165,13,165,14,0],[166,9,166,10,0],[170,13,170,34,0],[171,13,173,25,0],[173,25,173,32,0],[173,32,174,25,0],[174,25,174,27,0],[174,27,175,22,0],[175,22,175,120,0],[175,120,176,15,0],[181,13,181,36,0],[182,17,182,26,0],[185,13,185,44,0],[188,17,188,42,0],[189,17,189,56,0],[190,17,190,40,0],[190,41,190,72,0],[191,17,191,47,0],[193,33,193,102,0],[195,17,195,53,0],[199,17,199,40,0],[200,13,200,14,0],[201,9,201,10,0],[205,13,205,32,0],[205,33,205,81,0],[206,13,206,28,0],[206,29,206,108,0],[210,17,210,51,0],[211,17,211,52,0],[212,17,212,45,0],[213,13,213,14,0],[214,33,214,102,0],[216,17,216,53,0],[218,9,218,10,0],[222,13,222,37,0],[224,13,224,51,0],[225,13,225,30,0],[225,31,225,43,0],[229,13,229,59,0],[231,13,231,32,0],[231,33,231,45,0],[233,13,233,26,0],[238,13,238,31,0],[238,32,238,79,0],[242,17,242,46,0],[243,17,243,56,0],[244,17,244,40,0],[245,21,245,52,0],[247,17,247,48,0],[248,17,248,31,0],[248,32,248,42,0],[250,17,250,31,0],[252,21,252,40,0],[252,41,252,56,0],[253,21,253,119,0],[256,17,256,115,0],[258,33,258,102,0],[260,17,260,53,0],[262,9,262,10,0],[267,13,267,97,0],[273,13,273,95,0],[281,16,281,59,0],[284,16,284,94,0],[287,16,287,60,0],[290,16,290,80,0],[298,13,298,65,0],[299,13,299,88,0],[300,13,300,74,0],[301,13,301,98,0],[302,9,302,10,0],[306,13,306,33,0],[306,34,306,83,0],[308,13,308,30,0],[309,17,309,54,0],[311,13,311,77,0],[312,9,312,10,0],[315,16,315,86,0],[318,16,318,67,0],[321,16,321,100,0],[327,13,327,30,0],[327,31,327,77,0],[328,13,328,36,0],[328,37,328,89,0],[330,13,330,50,0],[332,17,333,42,0],[333,42,333,104,0],[333,104,333,106,0],[334,17,334,36,0],[335,21,335,121,0],[336,17,336,80,0],[339,13,339,92,0],[340,13,340,105,0],[345,13,347,58,0],[347,58,347,106,0],[347,106,348,60,0],[348,60,348,110,0],[348,110,349,22,0],[349,22,349,131,0],[349,131,350,15,0],[359,13,359,30,0],[359,31,359,77,0],[360,13,360,36,0],[360,37,360,89,0],[361,13,361,40,0],[362,17,362,128,0],[364,13,364,76,0],[365,9,365,10,0],[369,13,369,53,0],[370,17,371,35,0],[373,13,373,30,0],[375,13,375,49,0],[377,17,377,31,0],[378,17,378,47,0],[379,17,379,83,0],[380,21,381,107,0],[384,13,384,57,0],[386,17,386,31,0],[387,17,387,55,0],[388,17,388,83,0],[389,21,390,120,0],[393,13,393,26,0],[398,13,398,76,0],[399,9,399,10,0],[403,13,403,36,0],[403,37,403,89,0],[405,13,405,71,0],[406,13,406,81,0],[407,17,407,97,0],[409,13,409,66,0],[410,13,410,60,0],[412,17,412,58,0],[413,17,413,83,0],[415,21,415,77,0],[416,21,416,55,0],[417,21,418,120,0],[421,9,421,10,0],[431,59,431,78,0],[442,13,442,29,0],[442,30,442,60,0],[444,13,444,38,0],[446,13,449,59,0],[451,13,451,36,0],[451,37,451,66,0],[452,13,452,31,0],[457,13,457,29,0],[459,17,459,57,0],[460,17,461,101,0],[463,21,463,52,0],[467,13,467,82,0],[477,13,477,76,0],[478,17,478,47,0],[481,13,481,58,0],[482,17,482,51,0],[485,13,485,74,0],[486,17,486,29,0],[488,13,488,36,0],[488,37,488,125,0],[489,13,489,31,0],[494,13,494,60,0],[495,13,495,36,0],[498,17,498,52,0],[499,17,499,68,0],[500,17,500,49,0],[501,17,501,47,0],[503,21,503,78,0],[504,21,504,44,0],[509,21,509,63,0],[510,21,510,62,0],[513,17,513,40,0],[516,30,516,47,0],[516,48,516,50,0],[516,51,516,61,0],[518,25,518,81,0],[519,25,519,48,0],[521,29,521,35,0],[527,13,527,31,0],[533,13,533,38,0],[533,39,533,51,0],[536,13,536,69,0],[538,17,540,68,0],[543,13,543,51,0],[549,13,549,38,0],[552,13,552,36,0],[553,17,553,49,0],[555,13,555,31,0],[562,9,562,10,0],[567,13,567,34,0],[569,17,569,94,0],[572,13,572,42,0],[576,17,576,53,0],[577,17,577,66,0],[578,17,578,30,0],[579,13,579,14,0],[583,17,583,34,0],[585,13,585,14,0],[587,13,587,27,0],[592,22,592,36,0],[592,37,592,39,0],[592,40,592,55,0],[594,17,594,38,0],[597,13,597,30,0],[598,13,598,28,0],[599,13,599,53,0],[600,13,600,39,0],[602,13,602,43,0],[604,13,604,46,0],[605,13,605,50,0],[606,13,606,46,0],[607,13,607,54,0],[608,9,608,10,0],[612,13,612,35,0],[613,13,613,79,0],[614,13,614,65,0],[615,13,615,41,0],[617,17,617,77,0],[618,17,618,66,0],[621,13,621,34,0],[626,13,626,97,0],[631,13,631,46,0],[632,13,632,34,0],[634,26,634,31,0],[634,32,634,34,0],[634,35,634,40,0],[636,21,636,39,0],[639,26,639,32,0],[639,33,639,35,0],[639,36,639,41,0],[641,21,641,51,0],[644,9,644,10,0],[648,13,648,28,0],[655,18,655,27,0],[655,29,655,51,0],[655,53,655,56,0],[657,17,657,41,0],[658,17,658,99,0],[660,21,660,46,0],[661,21,661,72,0],[662,21,662,42,0],[664,25,664,93,0],[665,25,665,76,0],[669,25,669,49,0],[671,29,672,103,0],[678,13,678,58,0],[679,9,679,10,0],[683,13,684,79,0],[685,22,685,28,0],[685,29,685,31,0],[685,32,685,48,0],[687,17,687,57,0],[689,21,690,73,0],[693,17,693,49,0],[696,22,696,41,0],[696,42,696,44,0],[696,45,696,61,0],[698,17,698,92,0],[700,9,700,10,0],[704,13,704,65,0],[705,13,705,36,0],[707,17,707,49,0],[710,13,710,31,0],[717,17,717,29,0]]);
    </script>
  </body>
</html>