<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\HazelcastClient.Events.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Hazelcast.Clustering;
using Hazelcast.Core;
using Microsoft.Extensions.Logging;

namespace Hazelcast
{
    internal partial class HazelcastClient // Events
    {
        // subscription id -&gt; event handlers
        // for cluster client-level events i.e. events that do not directly correspond to an
        // event message received from the cluster, but from things happening in the client
        private readonly ConcurrentDictionary&lt;Guid, HazelcastClientEventHandlers&gt; _handlers
            = new ConcurrentDictionary&lt;Guid, HazelcastClientEventHandlers&gt;();

        /// &lt;inheritdoc /&gt;
        public async Task&lt;Guid&gt; SubscribeAsync(Action&lt;HazelcastClientEventHandlers&gt; events)
        {
            if (events == null) throw new ArgumentNullException(nameof(events));

            var handlers = new HazelcastClientEventHandlers();
            events(handlers);

            foreach (var handler in handlers)
            {
                switch (handler)
                {
                    case DistributedObjectCreatedEventHandler _:
                    case DistributedObjectDestroyedEventHandler _:
                        await Cluster.Events.AddObjectLifecycleSubscription().CfAwait();
                        break;

                    case PartitionLostEventHandler _:
                        await Cluster.Events.AddPartitionLostSubscription().CfAwait();
                        break;

                    case MembersUpdatedEventHandler _ :
                    case PartitionsUpdatedEventHandler _:
                    case ConnectionOpenedEventHandler _:
                    case ConnectionClosedEventHandler _:
                    case StateChangedEventHandler _:
                        // nothing to do (but don&#39;t throw)
                        break;

                    default:
                        throw new NotSupportedException($&quot;Handler of type {handler.GetType()} is not supported here.&quot;);
                }
            }

            var id = Guid.NewGuid();
            _handlers[id] = handlers;
            return id;
        }

        /// &lt;inheritdoc /&gt;
        public async ValueTask&lt;bool&gt; UnsubscribeAsync(Guid subscriptionId)
        {
            if (!_handlers.TryGetValue(subscriptionId, out var clusterHandlers))
                return true;

            var allRemoved = true;
            var removedHandlers = new List&lt;IHazelcastClientEventHandler&gt;();
            foreach (var handler in clusterHandlers)
            {
                var removed = handler switch
                {
                    DistributedObjectCreatedEventHandler _ =&gt; await Cluster.Events.RemoveObjectLifecycleSubscription().CfAwait(),
                    DistributedObjectDestroyedEventHandler _ =&gt; await Cluster.Events.RemoveObjectLifecycleSubscription().CfAwait(),
                    PartitionLostEventHandler _ =&gt; await Cluster.Events.RemovePartitionLostSubscription().CfAwait(),
                    MembersUpdatedEventHandler _ =&gt; true,
                    PartitionsUpdatedEventHandler _ =&gt; true,
                    ConnectionOpenedEventHandler _ =&gt; true,
                    ConnectionClosedEventHandler _ =&gt; true,
                    StateChangedEventHandler _ =&gt; true,
                    _ =&gt; throw new NotSupportedException($&quot;Handler of type {handler.GetType()} is not supported here.&quot;)
                };

                allRemoved &amp;= removed;

                if (removed) removedHandlers.Add(handler);
            }

            foreach (var handler in removedHandlers)
                clusterHandlers.Remove(handler);

            if (allRemoved)
                _handlers.TryRemove(subscriptionId, out _);

            return allRemoved;
        }

        /// &lt;summary&gt;
        /// Triggers handlers.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;THandler&quot;&gt;The type of the handlers.&lt;/typeparam&gt;
        /// &lt;returns&gt;A task that will complete when the handlers have been triggered.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;Each individual handle executes within a try/catch block and exceptions
        /// are caught and logged; this method does not throw.&lt;/para&gt;
        /// &lt;/remarks&gt;
        private ValueTask Trigger&lt;THandler&gt;()
            where THandler : HazelcastClientEventHandlerBase&lt;EventArgs&gt;
        {
            return ForEachHandler&lt;THandler, EventArgs&gt;((handler, sender, a) =&gt;
                handler.HandleAsync(sender, a), EventArgs.Empty);
        }

        /// &lt;summary&gt;
        /// Triggers handlers.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;THandler&quot;&gt;The type of the handlers.&lt;/typeparam&gt;
        /// &lt;typeparam name=&quot;TArgs&quot;&gt;The type of the event arguments.&lt;/typeparam&gt;
        /// &lt;returns&gt;A task that will complete when the handlers have been triggered.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;Each individual handle executes within a try/catch block and exceptions
        /// are caught and logged; this method does not throw.&lt;/para&gt;
        /// &lt;/remarks&gt;
        private ValueTask Trigger&lt;THandler, TArgs&gt;(TArgs args)
            where THandler : HazelcastClientEventHandlerBase&lt;TArgs&gt;
        {
            return ForEachHandler&lt;THandler, TArgs&gt;((handler, sender, a) =&gt;
                handler.HandleAsync(sender, a), args);
        }

        /// &lt;summary&gt;
        /// Triggers events.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;THandler&quot;&gt;The type of the handlers to trigger.&lt;/typeparam&gt;
        /// &lt;typeparam name=&quot;TArgs&quot;&gt;The type of the event data.&lt;/typeparam&gt;
        /// &lt;param name=&quot;action&quot;&gt;The trigger action.&lt;/param&gt;
        /// &lt;param name=&quot;args&quot;&gt;Event data.&lt;/param&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;Each individual handle executes within a try/catch block and exceptions
        /// are caught and logged; this method does not throw.&lt;/para&gt;
        /// &lt;/remarks&gt;
        private async ValueTask ForEachHandler&lt;THandler, TArgs&gt;(Func&lt;THandler, IHazelcastClient, TArgs, ValueTask&gt; action, TArgs args)
        {
            // TODO: consider running on background threads + limiting concurrency

            foreach (var (_, clusterEvents) in _handlers)
            foreach (var handler in clusterEvents.OfType&lt;THandler&gt;())
            {
                try
                {
                    await action(handler, this, args).CfAwait();
                }
                catch (Exception e)
                {
                    // TODO: refactor instrumentation
                    Cluster.Instrumentation.CountExceptionInEventHandler(e);
                    _logger.LogError(e, &quot;Caught exception in event handler.&quot;);
                }
            }
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[31,9,32,78,0],[37,13,37,32,0],[37,33,37,81,0],[39,13,39,63,0],[40,13,40,30,0],[42,22,42,33,0],[42,34,42,36,0],[42,37,42,45,0],[48,25,48,89,0],[49,25,49,31,0],[52,25,52,87,0],[53,25,53,31,0],[64,25,64,120,0],[68,13,68,37,0],[69,13,69,38,0],[70,13,70,23,0],[71,9,71,10,0],[76,13,76,81,0],[77,17,77,29,0],[79,13,79,35,0],[80,13,80,76,0],[81,22,81,33,0],[81,34,81,36,0],[81,37,81,52,0],[83,17,85,63,0],[85,63,85,129,0],[85,129,86,65,0],[86,65,86,131,0],[86,131,87,52,0],[87,52,87,116,0],[87,116,88,53,0],[88,53,88,57,0],[88,57,89,56,0],[89,56,89,60,0],[89,60,90,55,0],[90,55,90,59,0],[90,59,91,55,0],[91,55,91,59,0],[91,59,92,51,0],[92,51,92,55,0],[92,55,93,26,0],[93,26,93,120,0],[93,120,94,19,0],[96,17,96,39,0],[98,17,98,29,0],[98,30,98,59,0],[99,13,99,14,0],[101,22,101,33,0],[101,34,101,36,0],[101,37,101,52,0],[102,17,102,49,0],[104,13,104,28,0],[105,17,105,60,0],[107,13,107,31,0],[108,9,108,10,0],[122,13,123,17,0],[123,17,123,47,0],[123,47,123,66,0],[139,13,140,17,0],[140,17,140,47,0],[140,47,140,55,0],[158,22,158,44,0],[158,45,158,47,0],[158,48,158,57,0],[159,22,159,33,0],[159,34,159,36,0],[159,37,159,69,0],[163,21,163,65,0],[164,17,164,18,0],[165,17,165,36,0],[168,21,168,77,0],[169,21,169,79,0],[170,17,170,18,0],[172,9,172,10,0]]);
    </script>
  </body>
</html>