<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Serialization\ObjectDataInput.api.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Text;
using Hazelcast.Core;

namespace Hazelcast.Serialization
{
    internal partial class ObjectDataInput //public api
    {
        public Endianness Endianness { get; }

        public bool ReadBoolean()
        {
            CheckAvailable(Position, BytesExtensions.SizeOfBool);
            var value = _buffer.ReadBool(Position);
            Position += BytesExtensions.SizeOfBool;
            return value;
        }

        public byte ReadByte()
        {
            CheckAvailable(Position, BytesExtensions.SizeOfByte);
            var value = _buffer.ReadByte(Position);
            Position += BytesExtensions.SizeOfByte;
            return value;
        }

        public sbyte ReadSByte()
        {
            CheckAvailable(Position, BytesExtensions.SizeOfByte);
            var value = _buffer.ReadSByte(Position);
            Position += BytesExtensions.SizeOfByte;
            return (sbyte) value;
        }

        public char ReadChar()
        {
            CheckAvailable(Position, BytesExtensions.SizeOfChar);
            var value = _buffer.ReadChar(Position, Endianness);
            Position += BytesExtensions.SizeOfChar;
            return value;
        }

        public short ReadShort()
        {
            CheckAvailable(Position, BytesExtensions.SizeOfShort);
            var value = _buffer.ReadShort(Position, Endianness);
            Position += BytesExtensions.SizeOfShort;
            return value;
        }

        public ushort ReadUShort()
        {
            CheckAvailable(Position, BytesExtensions.SizeOfUnsignedShort);
            var value = _buffer.ReadUShort(Position, Endianness);
            Position += BytesExtensions.SizeOfUnsignedShort;
            return value;
        }

        public int ReadInt()
        {
            CheckAvailable(Position, BytesExtensions.SizeOfInt);
            var value = _buffer.ReadInt(Position, Endianness);
            Position += BytesExtensions.SizeOfInt;
            return value;
        }

        public long ReadLong()
        {
            CheckAvailable(Position, BytesExtensions.SizeOfLong);
            var value = _buffer.ReadLong(Position, Endianness);
            Position += BytesExtensions.SizeOfLong;
            return value;
        }

        public float ReadFloat()
        {
            CheckAvailable(Position, BytesExtensions.SizeOfFloat);
            var value = _buffer.ReadFloat(Position, Endianness);
            Position += BytesExtensions.SizeOfFloat;
            return value;
        }

        public double ReadDouble()
        {
            CheckAvailable(Position, BytesExtensions.SizeOfDouble);
            var value = _buffer.ReadDouble(Position, Endianness);
            Position += BytesExtensions.SizeOfDouble;
            return value;
        }

        public string ReadString()
        {
            var numberOfBytes = ReadInt();
            if (numberOfBytes == BytesExtensions.SizeOfNullArray) return null;

            var result = Encoding.UTF8.GetString(_buffer, Position, numberOfBytes);
            Position += numberOfBytes;
            return result;
        }

        public bool[] ReadBooleanArray()
        {
            var length = ReadInt();
            if (length == BytesExtensions.SizeOfNullArray) return null;
            if (length &lt;= 0) return Array.Empty&lt;bool&gt;();

            CheckAvailable(Position, length * BytesExtensions.SizeOfBool);

            var values = new bool[length];
            for (var i = 0; i &lt; length; i++)
            {
                values[i] = _buffer.ReadBool(Position);
                Position += BytesExtensions.SizeOfBool;
            }

            return values;
        }

        public byte[] ReadByteArray()
        {
            var length = ReadInt();
            if (length == BytesExtensions.SizeOfNullArray) return null;
            if (length &lt;= 0) return Array.Empty&lt;byte&gt;();

            var values = new byte[length];
            Read(values);
            return values;
        }

        public char[] ReadCharArray()
        {
            var length = ReadInt();
            if (length == BytesExtensions.SizeOfNullArray) return null;
            if (length &lt;= 0) return Array.Empty&lt;char&gt;();

            CheckAvailable(Position, length * BytesExtensions.SizeOfChar);

            var values = new char[length];
            for (var i = 0; i &lt; length; i++)
            {
                values[i] = _buffer.ReadChar(Position, Endianness);
                Position += BytesExtensions.SizeOfChar;
            }

            return values;
        }

        public short[] ReadShortArray()
        {
            var length = ReadInt();
            if (length == BytesExtensions.SizeOfNullArray) return null;
            if (length &lt;= 0) return Array.Empty&lt;short&gt;();

            CheckAvailable(Position, length * BytesExtensions.SizeOfShort);

            var values = new short[length];
            for (var i = 0; i &lt; length; i++)
            {
                values[i] = _buffer.ReadShort(Position, Endianness);
                Position += BytesExtensions.SizeOfShort;
            }

            return values;
        }

        public int[] ReadIntArray()
        {
            var length = ReadInt();
            if (length == BytesExtensions.SizeOfNullArray) return null;
            if (length &lt;= 0) return Array.Empty&lt;int&gt;();

            CheckAvailable(Position, length * BytesExtensions.SizeOfInt);

            var values = new int[length];
            for (var i = 0; i &lt; length; i++)
            {
                values[i] = _buffer.ReadInt(Position, Endianness);
                Position += BytesExtensions.SizeOfInt;
            }

            return values;
        }

        public long[] ReadLongArray()
        {
            var length = ReadInt();
            if (length == BytesExtensions.SizeOfNullArray) return null;
            if (length &lt;= 0) return Array.Empty&lt;long&gt;();

            CheckAvailable(Position, length * BytesExtensions.SizeOfLong);

            var values = new long[length];
            for (var i = 0; i &lt; length; i++)
            {
                values[i] = _buffer.ReadLong(Position, Endianness);
                Position += BytesExtensions.SizeOfLong;
            }

            return values;
        }

        public float[] ReadFloatArray()
        {
            var length = ReadInt();
            if (length == BytesExtensions.SizeOfNullArray) return null;
            if (length &lt;= 0) return Array.Empty&lt;float&gt;();

            CheckAvailable(Position, length * BytesExtensions.SizeOfFloat);

            var values = new float[length];
            for (var i = 0; i &lt; length; i++)
            {
                values[i] = _buffer.ReadFloat(Position, Endianness);
                Position += BytesExtensions.SizeOfFloat;
            }

            return values;
        }

        public double[] ReadDoubleArray()
        {
            var length = ReadInt();
            if (length == BytesExtensions.SizeOfNullArray) return null;
            if (length &lt;= 0) return Array.Empty&lt;double&gt;();

            CheckAvailable(Position, length * BytesExtensions.SizeOfDouble);

            var values = new double[length];
            for (var i = 0; i &lt; length; i++)
            {
                values[i] = _buffer.ReadDouble(Position, Endianness);
                Position += BytesExtensions.SizeOfDouble;
            }

            return values;
        }

        public string[] ReadStringArray()
        {
            var length = ReadInt();
            if (length == BytesExtensions.SizeOfNullArray) return null;
            if (length &lt;= 0) return Array.Empty&lt;string&gt;();

            CheckAvailable(Position, length * BytesExtensions.SizeOfDouble);

            var values = new string[length];
            for (var i = 0; i &lt; length; i++)
            {
                values[i] = ReadString();
            }

            return values;
        }

        public T ReadObject&lt;T&gt;() =&gt; _serializationService.ReadObject&lt;T&gt;(this);

        public int Read(byte[] bytes)
        {
            return Read(bytes, 0, bytes.Length);
        }

        public int Read(byte[] bytes, int offset, int count)
        {
            if (bytes == null) throw new ArgumentNullException(nameof(bytes));
            if (offset &lt; 0 || offset &gt;= bytes.Length) throw new ArgumentOutOfRangeException(nameof(offset));
            if (count &lt; 0 || offset + count &gt; bytes.Length) throw new ArgumentOutOfRangeException(nameof(count));

            if (count == 0) return 0;
            if (Position &gt;= _length) return -1;

            count = Math.Min(count, _length - Position);

            System.Buffer.BlockCopy(_buffer, Position, bytes, offset, count);
            Position += count;
            return count;
        }

        public int SkipBytes(int count)
        {
            if (count &lt;= 0) return 0;

            count = Math.Min(count, _length - Position);
            Position += count;
            return count;
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[23,40,23,44,0],[27,13,27,66,0],[28,13,28,52,0],[29,13,29,52,0],[30,13,30,26,0],[35,13,35,66,0],[36,13,36,52,0],[37,13,37,52,0],[38,13,38,26,0],[43,13,43,66,0],[44,13,44,53,0],[45,13,45,52,0],[46,13,46,34,0],[51,13,51,66,0],[52,13,52,64,0],[53,13,53,52,0],[54,13,54,26,0],[59,13,59,67,0],[60,13,60,65,0],[61,13,61,53,0],[62,13,62,26,0],[67,13,67,75,0],[68,13,68,66,0],[69,13,69,61,0],[70,13,70,26,0],[75,13,75,65,0],[76,13,76,63,0],[77,13,77,51,0],[78,13,78,26,0],[83,13,83,66,0],[84,13,84,64,0],[85,13,85,52,0],[86,13,86,26,0],[91,13,91,67,0],[92,13,92,65,0],[93,13,93,53,0],[94,13,94,26,0],[99,13,99,68,0],[100,13,100,66,0],[101,13,101,54,0],[102,13,102,26,0],[107,13,107,43,0],[108,13,108,66,0],[108,67,108,79,0],[110,13,110,84,0],[111,13,111,39,0],[112,13,112,27,0],[117,13,117,36,0],[118,13,118,59,0],[118,60,118,72,0],[119,13,119,29,0],[119,30,119,57,0],[121,13,121,75,0],[123,13,123,43,0],[124,18,124,27,0],[124,29,124,39,0],[124,41,124,44,0],[126,17,126,56,0],[127,17,127,56,0],[130,13,130,27,0],[135,13,135,36,0],[136,13,136,59,0],[136,60,136,72,0],[137,13,137,29,0],[137,30,137,57,0],[139,13,139,43,0],[140,13,140,26,0],[141,13,141,27,0],[146,13,146,36,0],[147,13,147,59,0],[147,60,147,72,0],[148,13,148,29,0],[148,30,148,57,0],[150,13,150,75,0],[152,13,152,43,0],[153,18,153,27,0],[153,29,153,39,0],[153,41,153,44,0],[155,17,155,68,0],[156,17,156,56,0],[159,13,159,27,0],[164,13,164,36,0],[165,13,165,59,0],[165,60,165,72,0],[166,13,166,29,0],[166,30,166,58,0],[168,13,168,76,0],[170,13,170,44,0],[171,18,171,27,0],[171,29,171,39,0],[171,41,171,44,0],[173,17,173,69,0],[174,17,174,57,0],[177,13,177,27,0],[182,13,182,36,0],[183,13,183,59,0],[183,60,183,72,0],[184,13,184,29,0],[184,30,184,56,0],[186,13,186,74,0],[188,13,188,42,0],[189,18,189,27,0],[189,29,189,39,0],[189,41,189,44,0],[191,17,191,67,0],[192,17,192,55,0],[195,13,195,27,0],[200,13,200,36,0],[201,13,201,59,0],[201,60,201,72,0],[202,13,202,29,0],[202,30,202,57,0],[204,13,204,75,0],[206,13,206,43,0],[207,18,207,27,0],[207,29,207,39,0],[207,41,207,44,0],[209,17,209,68,0],[210,17,210,56,0],[213,13,213,27,0],[218,13,218,36,0],[219,13,219,59,0],[219,60,219,72,0],[220,13,220,29,0],[220,30,220,58,0],[222,13,222,76,0],[224,13,224,44,0],[225,18,225,27,0],[225,29,225,39,0],[225,41,225,44,0],[227,17,227,69,0],[228,17,228,57,0],[231,13,231,27,0],[236,13,236,36,0],[237,13,237,59,0],[237,60,237,72,0],[238,13,238,29,0],[238,30,238,59,0],[240,13,240,77,0],[242,13,242,45,0],[243,18,243,27,0],[243,29,243,39,0],[243,41,243,44,0],[245,17,245,70,0],[246,17,246,58,0],[249,13,249,27,0],[254,13,254,36,0],[255,13,255,59,0],[255,60,255,72,0],[256,13,256,29,0],[256,30,256,59,0],[258,13,258,77,0],[260,13,260,45,0],[261,18,261,27,0],[261,29,261,39,0],[261,41,261,44,0],[263,17,263,42,0],[266,13,266,27,0],[269,37,269,78,0],[273,13,273,49,0],[278,13,278,31,0],[278,32,278,79,0],[279,13,279,54,0],[279,55,279,109,0],[280,13,280,60,0],[280,61,280,114,0],[282,13,282,28,0],[282,29,282,38,0],[283,13,283,37,0],[283,38,283,48,0],[285,13,285,57,0],[287,13,287,78,0],[288,13,288,31,0],[289,13,289,26,0],[294,13,294,28,0],[294,29,294,38,0],[296,13,296,57,0],[297,13,297,31,0],[298,13,298,26,0]]);
    </script>
  </body>
</html>