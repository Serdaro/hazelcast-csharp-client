<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\CP\CPSubsystem.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Threading.Tasks;
using Hazelcast.Clustering;
using Hazelcast.Core;
using Hazelcast.Exceptions;
using Hazelcast.Protocol.Codecs;
using Hazelcast.Serialization;

namespace Hazelcast.CP
{
    /// &lt;summary&gt;
    /// Provides the &lt;see cref=&quot;ICPSubsystem&quot;/&gt; implementation.
    /// &lt;/summary&gt;
    internal class CPSubsystem : ICPSubsystem
    {
        private readonly Cluster _cluster;
        private readonly SerializationService _serializationService;

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;CPSubsystem&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;cluster&quot;&gt;The cluster.&lt;/param&gt;
        /// &lt;param name=&quot;serializationService&quot;&gt;The serialization service.&lt;/param&gt;
        public CPSubsystem(Cluster cluster, SerializationService serializationService)
        {
            _cluster = cluster;
            _serializationService = serializationService;
        }

        // NOTES
        //
        // Java CP objects are managed by CPSubsystemImpl and created through ClientRaftProxyFactory
        // which is a simplified factory, which does not cache AtomicLong, AtomicRef, and CountDownLatch,
        // and sort-of caches (?) FencedLock and Semaphore.
        //
        // These objects are therefore IDistributedObject but *not* DistributedObjectBase, and *not*
        // managed by the DistributedObjectFactory.
        //
        // The are destroyed via ClientProxy.destroy, which is getContext().getProxyManager().destroyProxy(this),
        // which means they are destroyed by ProxyManager aka DistributedObjectFactory, which would try to
        // remove them from cache (always missing) and end up doing proxy.destroyLocally() which eventually
        // calls into the object&#39;s onDestroy() method.
        //
        // But... this is convoluted? For now, our objects inherit from CPObjectBase which is simpler than
        // DistributedObjectBase, they do not hit DistributedObjectFactory at all, and implement their
        // own destroy method.

        /// &lt;inheritdoc /&gt;
        public async Task&lt;IAtomicLong&gt; GetAtomicLongAsync(string name)
        {
            var (groupName, objectName) = ParseName(name);
            var groupId = await GetGroupIdAsync(groupName).CfAwait();

            return new AtomicLong(objectName, groupId, _cluster);
        }

        public async Task&lt;IAtomicReference&lt;T&gt;&gt; GetAtomicReferenceAsync&lt;T&gt;(string name)
        {
            var (groupName, objectName) = ParseName(name);
            var groupId = await GetGroupIdAsync(groupName).CfAwait();

            return new AtomicReference&lt;T&gt;(objectName, groupId, _cluster, _serializationService);
        }

        // see: ClientRaftProxyFactory.java

        private async Task&lt;CPGroupId&gt; GetGroupIdAsync(string proxyName)
        {
            var requestMessage = CPGroupCreateCPGroupCodec.EncodeRequest(proxyName);
            var responseMessage = await _cluster.Messaging.SendAsync(requestMessage).CfAwait();
            var response = CPGroupCreateCPGroupCodec.DecodeResponse(responseMessage).GroupId;
            return response;
        }

        // see: RaftService.java

        internal const string DefaultGroupName = &quot;default&quot;;
        internal const string MetaDataGroupName = &quot;METADATA&quot;;

        public static (string groupName, string objectName) ParseName(string name)
        {
            if (string.IsNullOrWhiteSpace(name)) throw new ArgumentException(ExceptionMessages.NullOrEmpty);

            name = name.Trim();
            var pos = name.IndexOf(&#39;@&#39;, StringComparison.OrdinalIgnoreCase);

            string groupName;
            if (pos &lt; 0)
            {
                groupName = DefaultGroupName;
            }
            else
            {
                groupName = name[(pos + 1)..].Trim();
                if (groupName.Equals(DefaultGroupName, StringComparison.OrdinalIgnoreCase))
                    groupName = DefaultGroupName;
            }

            if (groupName.Length == 0)
                throw new ArgumentException(&quot;CP group name cannot be an empty string.&quot;, nameof(name));

            if (groupName.Contains(&quot;@&quot;, StringComparison.OrdinalIgnoreCase))
                throw new ArgumentException(&quot;CP group name must be specified at most once.&quot;, nameof(name));

            if (groupName.Equals(MetaDataGroupName, StringComparison.OrdinalIgnoreCase))
                throw new NotSupportedException(&quot;CP data structures cannot run on the METADATA CP group.&quot;);

            var objectName = pos &lt; 0 ? name : name.Substring(0, pos).Trim();

            if (objectName.Length == 0)
                throw new ArgumentException(&quot;Object name cannot be empty string.&quot;, nameof(name));

            return (groupName, objectName);
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[38,9,38,87,0],[40,13,40,32,0],[41,13,41,58,0],[42,9,42,10,0],[65,13,65,59,0],[66,13,66,70,0],[68,13,68,66,0],[69,9,69,10,0],[73,13,73,59,0],[74,13,74,70,0],[76,13,76,97,0],[77,9,77,10,0],[83,13,83,85,0],[84,13,84,96,0],[85,13,85,94,0],[86,13,86,29,0],[87,9,87,10,0],[96,13,96,49,0],[96,50,96,109,0],[98,13,98,32,0],[99,13,99,77,0],[102,13,102,25,0],[104,17,104,46,0],[108,17,108,54,0],[109,17,109,92,0],[110,21,110,50,0],[113,13,113,39,0],[114,17,114,103,0],[116,13,116,77,0],[117,17,117,108,0],[119,13,119,89,0],[120,17,120,108,0],[122,13,122,77,0],[124,13,124,40,0],[125,17,125,98,0],[127,13,127,44,0]]);
    </script>
  </body>
</html>