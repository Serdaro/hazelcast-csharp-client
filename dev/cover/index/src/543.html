<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\DistributedObjects\Impl\HMap.Events.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Threading;
using System.Threading.Tasks;
using Hazelcast.Clustering;
using Hazelcast.Core;
using Hazelcast.Messaging;
using Hazelcast.Models;
using Hazelcast.Protocol.Codecs;
using Hazelcast.Query;
using Hazelcast.Serialization;

namespace Hazelcast.DistributedObjects.Impl
{
    internal partial class HMap&lt;TKey, TValue&gt; // Events
    {
        private async Task&lt;Guid&gt; SubscribeAsync(Action&lt;MapEventHandlers&lt;TKey, TValue&gt;&gt; events, Maybe&lt;TKey&gt; key, IPredicate predicate, bool includeValues, object state, CancellationToken cancellationToken)
        {
            if (events == null) throw new ArgumentNullException(nameof(events));

            var handlers = new MapEventHandlers&lt;TKey, TValue&gt;();
            events(handlers);

            var flags = default (MapEventTypes);
            foreach (var handler in handlers)
                flags |= handler.EventType;

            // 0: no entryKey, no predicate
            // 1: entryKey, no predicate
            // 2: no entryKey, predicate
            // 3: entryKey, predicate
            var mode = key.Match(1, 0) + (predicate != null ? 2 : 0);
            var keyv = key.ValueOrDefault();

            var subscribeRequest = mode switch
            {
                0 =&gt; MapAddEntryListenerCodec.EncodeRequest(Name, includeValues, (int) flags, Cluster.IsSmartRouting),
                1 =&gt; MapAddEntryListenerToKeyCodec.EncodeRequest(Name, ToData(keyv), includeValues, (int) flags, Cluster.IsSmartRouting),
                2 =&gt; MapAddEntryListenerWithPredicateCodec.EncodeRequest(Name, ToData(predicate), includeValues, (int) flags, Cluster.IsSmartRouting),
                3 =&gt; MapAddEntryListenerToKeyWithPredicateCodec.EncodeRequest(Name, ToData(keyv), ToData(predicate), includeValues, (int) flags, Cluster.IsSmartRouting),
                _ =&gt; throw new NotSupportedException()
            };

            var subscription = new ClusterSubscription(
                subscribeRequest,
                ReadSubscribeResponse,
                CreateUnsubscribeRequest,
                ReadUnsubscribeResponse,
                HandleEventAsync,
                new MapSubscriptionState(mode, Name, handlers, state));

            await Cluster.Events.AddSubscriptionAsync(subscription, cancellationToken).CfAwait();

            return subscription.Id;
        }

        public Task&lt;Guid&gt; SubscribeAsync(Action&lt;MapEventHandlers&lt;TKey, TValue&gt;&gt; events, bool includeValues = true, object state = null)
            =&gt; SubscribeAsync(events, Maybe.None, null, includeValues, state, CancellationToken.None);

        public Task&lt;Guid&gt; SubscribeAsync(Action&lt;MapEventHandlers&lt;TKey, TValue&gt;&gt; events, TKey key, bool includeValues = true, object state = null)
            =&gt; SubscribeAsync(events, Maybe.Some(key), null, includeValues, state, CancellationToken.None);

        public Task&lt;Guid&gt; SubscribeAsync(Action&lt;MapEventHandlers&lt;TKey, TValue&gt;&gt; events, IPredicate predicate, bool includeValues = true, object state = null)
            =&gt; SubscribeAsync(events, Maybe.None, predicate, includeValues, state, CancellationToken.None);

        public Task&lt;Guid&gt; SubscribeAsync(Action&lt;MapEventHandlers&lt;TKey, TValue&gt;&gt; events, TKey key, IPredicate predicate, bool includeValues = true, object state = null)
            =&gt; SubscribeAsync(events, Maybe.Some(key), predicate, includeValues, state, CancellationToken.None);

        private class MapSubscriptionState : SubscriptionState&lt;MapEventHandlers&lt;TKey, TValue&gt;&gt;
        {
            public MapSubscriptionState(int mode, string name, MapEventHandlers&lt;TKey, TValue&gt; handlers, object state)
                : base(name, handlers, state)
            {
                Mode = mode;
            }

            public int Mode { get; }
        }

        private ValueTask HandleEventAsync(ClientMessage eventMessage, object state)
        {
            var sstate = ToSafeState&lt;MapSubscriptionState&gt;(state);

            return sstate.Mode switch
            {
                0 =&gt; MapAddEntryListenerCodec.HandleEventAsync(eventMessage, HandleEntryEvent, state, LoggerFactory),
                1 =&gt; MapAddEntryListenerToKeyCodec.HandleEventAsync(eventMessage, HandleEntryEvent, state, LoggerFactory),
                2 =&gt; MapAddEntryListenerWithPredicateCodec.HandleEventAsync(eventMessage, HandleEntryEvent, state, LoggerFactory),
                3 =&gt; MapAddEntryListenerToKeyWithPredicateCodec.HandleEventAsync(eventMessage, HandleEntryEvent, state, LoggerFactory),
                _ =&gt; throw new NotSupportedException()
            };
        }

        private async ValueTask HandleEntryEvent(IData keyData, IData valueData, IData oldValueData, IData mergingValueData, int eventTypeData, Guid memberId, int numberOfAffectedEntries, object state)
        {
            if (eventTypeData == 0) return;
            var eventType = (MapEventTypes) eventTypeData;

            var member = Cluster.Members.GetMember(memberId);
            var key = LazyArg&lt;TKey&gt;(keyData);
            var value = LazyArg&lt;TValue&gt;(valueData);
            var oldValue = LazyArg&lt;TValue&gt;(oldValueData);
            var mergingValue = LazyArg&lt;TValue&gt;(mergingValueData);

            var sstate = ToSafeState&lt;MapSubscriptionState&gt;(state);

            // ReSharper disable once ForeachCanBePartlyConvertedToQueryUsingAnotherGetEnumerator
            foreach (var handler in sstate.Handlers)
            {
                if (handler.EventType.HasAll(eventType))
                {
                    var task = handler switch
                    {
                        IMapEntryEventHandler&lt;TKey, TValue, IHMap&lt;TKey, TValue&gt;&gt; entryHandler =&gt; entryHandler.HandleAsync(this, member, key, value, oldValue, mergingValue, eventType, numberOfAffectedEntries, state),
                        IMapEventHandler&lt;TKey, TValue, IHMap&lt;TKey, TValue&gt;&gt; mapHandler =&gt; mapHandler.HandleAsync(this, member, numberOfAffectedEntries, state),
                        _ =&gt; throw new NotSupportedException()
                    };
                    await task.CfAwait();
                }
            }
        }

        private static ClientMessage CreateUnsubscribeRequest(Guid subscriptionId, object state)
        {
            var sstate = ToSafeState&lt;MapSubscriptionState&gt;(state);
            return MapRemoveEntryListenerCodec.EncodeRequest(sstate.Name, subscriptionId);
        }

        private static Guid ReadSubscribeResponse(ClientMessage responseMessage, object state)
        {
            var sstate = ToSafeState&lt;MapSubscriptionState&gt;(state);

            return sstate.Mode switch
            {
                0 =&gt; MapAddEntryListenerCodec.DecodeResponse(responseMessage).Response,
                1 =&gt; MapAddEntryListenerToKeyCodec.DecodeResponse(responseMessage).Response,
                2 =&gt; MapAddEntryListenerWithPredicateCodec.DecodeResponse(responseMessage).Response,
                3 =&gt; MapAddEntryListenerToKeyWithPredicateCodec.DecodeResponse(responseMessage).Response,
                _ =&gt; throw new NotSupportedException()
            };
        }

        private static bool ReadUnsubscribeResponse(ClientMessage unsubscribeResponseMessage, object state)
        {
            return MapRemoveEntryListenerCodec.DecodeResponse(unsubscribeResponseMessage).Response;
        }

        public ValueTask&lt;bool&gt; UnsubscribeAsync(Guid subscriptionId)
            =&gt; UnsubscribeBaseAsync(subscriptionId);
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[32,13,32,32,0],[32,33,32,81,0],[34,13,34,65,0],[35,13,35,30,0],[37,13,37,49,0],[38,22,38,33,0],[38,34,38,36,0],[38,37,38,45,0],[39,17,39,44,0],[45,13,45,70,0],[46,13,46,45,0],[48,13,50,22,0],[50,22,50,118,0],[50,118,51,22,0],[51,22,51,137,0],[51,137,52,22,0],[52,22,52,150,0],[52,150,53,22,0],[53,22,53,169,0],[53,169,54,22,0],[54,22,54,55,0],[54,55,55,15,0],[57,13,63,72,0],[65,13,65,98,0],[67,13,67,36,0],[68,9,68,10,0],[71,16,71,102,0],[74,16,74,107,0],[77,16,77,107,0],[80,16,80,112,0],[85,19,85,46,0],[87,17,87,29,0],[88,13,88,14,0],[90,31,90,35,0],[95,13,95,67,0],[97,13,99,22,0],[99,22,99,117,0],[99,117,100,22,0],[100,22,100,122,0],[100,122,101,22,0],[101,22,101,130,0],[101,130,102,22,0],[102,22,102,135,0],[102,135,103,22,0],[103,22,103,55,0],[103,55,104,15,0],[109,13,109,36,0],[109,37,109,44,0],[110,13,110,59,0],[112,13,112,62,0],[113,13,113,46,0],[114,13,114,52,0],[115,13,115,58,0],[116,13,116,66,0],[118,13,118,67,0],[121,22,121,33,0],[121,34,121,36,0],[121,37,121,52,0],[123,17,123,57,0],[125,21,127,98,0],[127,98,127,215,0],[127,215,128,91,0],[128,91,128,159,0],[128,159,129,30,0],[129,30,129,63,0],[129,63,130,23,0],[131,21,131,42,0],[134,9,134,10,0],[138,13,138,67,0],[139,13,139,91,0],[144,13,144,67,0],[146,13,148,22,0],[148,22,148,87,0],[148,87,149,22,0],[149,22,149,92,0],[149,92,150,22,0],[150,22,150,100,0],[150,100,151,22,0],[151,22,151,105,0],[151,105,152,22,0],[152,22,152,55,0],[152,55,153,15,0],[158,13,158,100,0],[162,16,162,52,0]]);
    </script>
  </body>
</html>