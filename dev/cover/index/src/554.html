<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\DistributedObjects\Impl\HMultiMap.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Hazelcast.Clustering;
using Hazelcast.Core;
using Hazelcast.Messaging;
using Hazelcast.Models;
using Hazelcast.Protocol.Codecs;
using Hazelcast.Serialization;
using Hazelcast.Serialization.Collections;
using Microsoft.Extensions.Logging;

namespace Hazelcast.DistributedObjects.Impl
{
    internal class HMultiMap&lt;TKey, TValue&gt; : DistributedObjectBase, IHMultiMap&lt;TKey, TValue&gt;
    {
        private readonly ISequence&lt;long&gt; _lockReferenceIdSequence;

        public HMultiMap(string name, DistributedObjectFactory factory, Cluster cluster, SerializationService serializationService, ISequence&lt;long&gt; lockReferenceIdSequence, ILoggerFactory loggerFactory)
            : base(ServiceNames.MultiMap, name, factory, cluster, serializationService, loggerFactory)
        {
            _lockReferenceIdSequence = lockReferenceIdSequence;
        }

        /// &lt;inheritdoc /&gt;
        public Task&lt;Guid&gt; SubscribeAsync(Action&lt;MultiMapEventHandlers&lt;TKey, TValue&gt;&gt; events, bool includeValues = true, object state = null)
            =&gt; SubscribeAsync(events, Maybe.None, includeValues, state);

        /// &lt;inheritdoc /&gt;
        public Task&lt;Guid&gt; SubscribeAsync(Action&lt;MultiMapEventHandlers&lt;TKey, TValue&gt;&gt; events, TKey key, bool includeValues = true, object state = null)
            =&gt; SubscribeAsync(events, Maybe.Some(key), includeValues, state);

        private async Task&lt;Guid&gt; SubscribeAsync(Action&lt;MultiMapEventHandlers&lt;TKey, TValue&gt;&gt; events, Maybe&lt;TKey&gt; key, bool includeValues, object state)
        {
            if (events == null) throw new ArgumentNullException(nameof(events));

            var handlers = new MultiMapEventHandlers&lt;TKey, TValue&gt;();
            events(handlers);

            // 0: no entryKey
            // 1: entryKey
            var mode = key.Match(1, 0);
            var keyv = key.ValueOrDefault();

            var subscribeRequest = mode switch
            {
                0 =&gt; MultiMapAddEntryListenerCodec.EncodeRequest(Name, includeValues, Cluster.IsSmartRouting),
                1 =&gt; MultiMapAddEntryListenerToKeyCodec.EncodeRequest(Name, ToData(keyv), includeValues, Cluster.IsSmartRouting),
                _ =&gt; throw new NotSupportedException()
            };

            var subscription = new ClusterSubscription(
                subscribeRequest,
                ReadSubscribeResponse,
                CreateUnsubscribeRequest,
                ReadUnsubscribeResponse,
                HandleEventAsync,
                new MapSubscriptionState(mode, Name, handlers, state));

            await Cluster.Events.AddSubscriptionAsync(subscription).CfAwait();

            return subscription.Id;
        }

        private class MapSubscriptionState : SubscriptionState&lt;MultiMapEventHandlers&lt;TKey, TValue&gt;&gt;
        {
            public MapSubscriptionState(int mode, string name, MultiMapEventHandlers&lt;TKey, TValue&gt; handlers, object state)
                : base(name, handlers, state)
            {
                Mode = mode;
            }

            public int Mode { get; }
        }

        private ValueTask HandleEventAsync(ClientMessage eventMessage, object state)
        {
            var sstate = ToSafeState&lt;MapSubscriptionState&gt;(state);

            return sstate.Mode switch
            {
                0 =&gt; MultiMapAddEntryListenerCodec.HandleEventAsync(eventMessage, HandleEntryEventAsync, state, LoggerFactory),
                1 =&gt; MultiMapAddEntryListenerToKeyCodec.HandleEventAsync(eventMessage, HandleEntryEventAsync, state, LoggerFactory),
                _ =&gt; throw new NotSupportedException()
            };
        }

        private async ValueTask HandleEntryEventAsync(IData keyData, IData valueData, IData oldValueData, IData mergingValueData, int eventTypeData, Guid memberId, int numberOfAffectedEntries, object state)
        {
            if (eventTypeData == 0) return;
            var eventType = (MapEventTypes) eventTypeData;

            var member = Cluster.Members.GetMember(memberId);
            var key = LazyArg&lt;TKey&gt;(keyData);
            var value = LazyArg&lt;TValue&gt;(valueData);
            var oldValue = LazyArg&lt;TValue&gt;(oldValueData);
            var mergingValue = LazyArg&lt;TValue&gt;(mergingValueData);

            var sstate = ToSafeState&lt;MapSubscriptionState&gt;(state);

            // ReSharper disable once ForeachCanBePartlyConvertedToQueryUsingAnotherGetEnumerator
            foreach (var handler in sstate.Handlers)
            {
                if (handler.EventType.HasAll(eventType))
                {
                    var task = handler switch
                    {
                        IMapEntryEventHandler&lt;TKey, TValue, IHMultiMap&lt;TKey, TValue&gt;&gt; entryHandler =&gt; entryHandler.HandleAsync(this, member, key, value, oldValue, mergingValue, eventType, numberOfAffectedEntries, sstate.HandlerState),
                        IMapEventHandler&lt;TKey, TValue, IHMultiMap&lt;TKey, TValue&gt;&gt; mapHandler =&gt; mapHandler.HandleAsync(this, member, numberOfAffectedEntries, sstate.HandlerState),
                        _ =&gt; throw new NotSupportedException()
                    };
                    await task.CfAwait();
                }
            }
        }

        private static ClientMessage CreateUnsubscribeRequest(Guid subscriptionId, object state)
        {
            var sstate = ToSafeState&lt;MapSubscriptionState&gt;(state);
            return MultiMapRemoveEntryListenerCodec.EncodeRequest(sstate.Name, subscriptionId);
        }

        private static Guid ReadSubscribeResponse(ClientMessage responseMessage, object state)
        {
            var sstate = ToSafeState&lt;MapSubscriptionState&gt;(state);

            return sstate.Mode switch
            {
                0 =&gt; MultiMapAddEntryListenerCodec.DecodeResponse(responseMessage).Response,
                1 =&gt; MultiMapAddEntryListenerToKeyCodec.DecodeResponse(responseMessage).Response,
                _ =&gt; throw new NotSupportedException()
            };
        }

        private static bool ReadUnsubscribeResponse(ClientMessage unsubscribeResponseMessage, object state)
        {
            return MultiMapRemoveEntryListenerCodec.DecodeResponse(unsubscribeResponseMessage).Response;
        }

        /// &lt;inheritdoc /&gt;
        public ValueTask&lt;bool&gt; UnsubscribeAsync(Guid subscriptionId)
            =&gt; UnsubscribeBaseAsync(subscriptionId);

        /// &lt;inheritdoc /&gt;
        public async Task&lt;bool&gt; PutAsync(TKey key, TValue value)
        {
            var (keyData, valueData) = ToSafeData(key, value);
            var requestMessage = MultiMapPutCodec.EncodeRequest(Name, keyData, valueData, ContextId);
            var responseMessage = await Cluster.Messaging.SendToKeyPartitionOwnerAsync(requestMessage, keyData).CfAwait();
            return MultiMapPutCodec.DecodeResponse(responseMessage).Response;
        }

        /// &lt;inheritdoc /&gt;
        public async Task&lt;IReadOnlyCollection&lt;TValue&gt;&gt; GetAsync(TKey key)
        {
            var keyData = ToSafeData(key);
            var requestMessage = MultiMapGetCodec.EncodeRequest(Name, keyData, ContextId);
            var responseMessage = await Cluster.Messaging.SendToKeyPartitionOwnerAsync(requestMessage, keyData).CfAwait();
            var response = MultiMapGetCodec.DecodeResponse(responseMessage).Response;
            return new ReadOnlyLazyList&lt;TValue&gt;(response, SerializationService);
        }

        /// &lt;inheritdoc /&gt;
        public Task&lt;IReadOnlyCollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt; GetEntriesAsync()
             =&gt; GetEntrySetAsync(CancellationToken.None);

        private async Task&lt;IReadOnlyCollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt; GetEntrySetAsync(CancellationToken cancellationToken)
        {
            var requestMessage = MultiMapEntrySetCodec.EncodeRequest(Name);
            var responseMessage = await Cluster.Messaging.SendAsync(requestMessage, cancellationToken).CfAwait();
            var response = MultiMapEntrySetCodec.DecodeResponse(responseMessage).Response;
            return new ReadOnlyLazyKeyValuePairs&lt;TKey, TValue&gt;(response, SerializationService);
        }

        /// &lt;inheritdoc /&gt;
        public async Task&lt;IReadOnlyCollection&lt;TKey&gt;&gt; GetKeysAsync()
        {
            var requestMessage = MultiMapKeySetCodec.EncodeRequest(Name);
            var responseMessage = await Cluster.Messaging.SendAsync(requestMessage).CfAwait();
            var response = MultiMapKeySetCodec.DecodeResponse(responseMessage).Response;
            return new ReadOnlyLazyList&lt;TKey&gt;(response, SerializationService);
        }

        /// &lt;inheritdoc /&gt;
        public async Task&lt;IReadOnlyCollection&lt;TValue&gt;&gt; GetValuesAsync()
        {
            var requestMessage = MultiMapValuesCodec.EncodeRequest(Name);
            var responseMessage = await Cluster.Messaging.SendAsync(requestMessage).CfAwait();
            var response  = MultiMapValuesCodec.DecodeResponse(responseMessage).Response;
            return new ReadOnlyLazyList&lt;TValue&gt;(response, SerializationService);
        }

        /// &lt;inheritdoc /&gt;
        public async Task&lt;bool&gt; ContainsEntryAsync(TKey key, TValue value)
        {
            var (keyData, valueData) = ToSafeData(key, value);
            var requestMessage = MultiMapContainsEntryCodec.EncodeRequest(Name, keyData, valueData, ContextId);
            var responseMessage = await Cluster.Messaging.SendToKeyPartitionOwnerAsync(requestMessage, keyData).CfAwait();
            return MultiMapContainsEntryCodec.DecodeResponse(responseMessage).Response;
        }

        /// &lt;inheritdoc /&gt;
        public async Task&lt;bool&gt; ContainsKeyAsync(TKey key)
        {
            var keyData = ToSafeData(key);
            var requestMessage = MultiMapContainsKeyCodec.EncodeRequest(Name, keyData, ContextId);
            var responseMessage = await Cluster.Messaging.SendToKeyPartitionOwnerAsync(requestMessage, keyData).CfAwait();
            return MultiMapContainsKeyCodec.DecodeResponse(responseMessage).Response;
        }

        /// &lt;inheritdoc /&gt;
        public async Task&lt;bool&gt; ContainsValueAsync(TValue value)
        {
            var valueData = ToSafeData(value);
            var requestMessage = MultiMapContainsValueCodec.EncodeRequest(Name, valueData);
            var responseMessage = await Cluster.Messaging.SendAsync(requestMessage).CfAwait();
            return MultiMapContainsValueCodec.DecodeResponse(responseMessage).Response;
        }

        /// &lt;inheritdoc /&gt;
        public async Task&lt;int&gt; GetSizeAsync()
        {
            var requestMessage = MultiMapSizeCodec.EncodeRequest(Name);
            var responseMessage = await Cluster.Messaging.SendAsync(requestMessage).CfAwait();
            return MultiMapSizeCodec.DecodeResponse(responseMessage).Response;
        }

        /// &lt;inheritdoc /&gt;
        public async Task&lt;int&gt; GetValueCountAsync(TKey key)
        {
            var keyData = ToSafeData(key);
            var requestMessage = MultiMapValueCountCodec.EncodeRequest(Name, keyData, ContextId);
            var responseMessage = await Cluster.Messaging.SendToKeyPartitionOwnerAsync(requestMessage, keyData).CfAwait();
            return MultiMapValueCountCodec.DecodeResponse(responseMessage).Response;
        }

        /// &lt;inheritdoc /&gt;
        public async Task&lt;bool&gt; RemoveAsync(TKey key, TValue value)
        {
            var (keyData, valueData) = ToSafeData(key, value);

            var requestMessage = MultiMapRemoveEntryCodec.EncodeRequest(Name, keyData, valueData, ContextId);
            var responseMessage = await Cluster.Messaging.SendToKeyPartitionOwnerAsync(requestMessage, keyData).CfAwait();
            return MultiMapRemoveEntryCodec.DecodeResponse(responseMessage).Response;
        }

        /// &lt;inheritdoc /&gt;
        public async Task&lt;IReadOnlyCollection&lt;TValue&gt;&gt; RemoveAsync(TKey key)
        {
            var keyData = ToSafeData(key);

            var requestMessage = MultiMapRemoveCodec.EncodeRequest(Name, keyData, ContextId);
            var responseMessage = await Cluster.Messaging.SendToKeyPartitionOwnerAsync(requestMessage, keyData).CfAwait();
            var response = MultiMapRemoveCodec.DecodeResponse(responseMessage).Response;
            return new ReadOnlyLazyList&lt;TValue&gt;(response, SerializationService);
        }

        /// &lt;inheritdoc /&gt;
        public async Task DeleteAsync(TKey key)
        {
            var keyData = ToSafeData(key);

            var requestMessage = MultiMapDeleteCodec.EncodeRequest(Name, keyData, ContextId);
            await Cluster.Messaging.SendToKeyPartitionOwnerAsync(requestMessage, keyData).CfAwait();
        }

        /// &lt;inheritdoc /&gt;
        public async Task ClearAsync()
        {
            var requestMessage = MultiMapClearCodec.EncodeRequest(Name);
            var responseMessage = await Cluster.Messaging.SendAsync(requestMessage).CfAwait();
            _ = MultiMapClearCodec.DecodeResponse(responseMessage);
        }

        /// &lt;inheritdoc /&gt;
        public Task LockAsync(TKey key)
            =&gt; LockAsync(key, TimeSpanExtensions.MinusOneMillisecond);

        /// &lt;inheritdoc /&gt;
        public Task&lt;bool&gt; TryLockAsync(TKey key)
            =&gt; TryLockAsync(key, TimeSpan.Zero, TimeSpanExtensions.MinusOneMillisecond);

        /// &lt;inheritdoc /&gt;
        public Task&lt;bool&gt; TryLockAsync(TKey key, TimeSpan timeToWait)
            =&gt; TryLockAsync(key, timeToWait, TimeSpanExtensions.MinusOneMillisecond);

        /// &lt;inheritdoc /&gt;
        public async Task&lt;bool&gt; TryLockAsync(TKey key, TimeSpan timeToWait, TimeSpan leaseTime)
        {
            var keyData = ToSafeData(key);
            var leaseTimeMs = leaseTime.RoundedMilliseconds();
            var timeToWaitMs = timeToWait.RoundedMilliseconds();
            var requestMessage = MultiMapTryLockCodec.EncodeRequest(Name, keyData, ContextId, leaseTimeMs, timeToWaitMs, _lockReferenceIdSequence.GetNext());
            var responseMessage = await Cluster.Messaging.SendToKeyPartitionOwnerAsync(requestMessage, keyData).CfAwait();
            return MultiMapTryLockCodec.DecodeResponse(responseMessage).Response;
        }

        /// &lt;inheritdoc /&gt;
        public async Task LockAsync(TKey key, TimeSpan leaseTime)
        {
            var keyData = ToSafeData(key);
            var leaseTimeMs = leaseTime.RoundedMilliseconds();
            var requestMessage = MultiMapLockCodec.EncodeRequest(Name, keyData, ContextId, leaseTimeMs, _lockReferenceIdSequence.GetNext());
            var responseMessage = await Cluster.Messaging.SendToKeyPartitionOwnerAsync(requestMessage, keyData).CfAwait();
            _ = MultiMapLockCodec.DecodeResponse(responseMessage);
        }

        /// &lt;inheritdoc /&gt;
        public async Task&lt;bool&gt; IsLockedAsync(TKey key)
        {
            var keyData = ToSafeData(key);
            var requestMessage = MultiMapIsLockedCodec.EncodeRequest(Name, keyData);
            var responseMessage = await Cluster.Messaging.SendToKeyPartitionOwnerAsync(requestMessage, keyData).CfAwait();
            return MultiMapIsLockedCodec.DecodeResponse(responseMessage).Response;
        }

        /// &lt;inheritdoc /&gt;
        public async Task UnlockAsync(TKey key)
        {
            var keyData = ToSafeData(key);
            var requestMessage = MultiMapUnlockCodec.EncodeRequest(Name, keyData, ContextId, _lockReferenceIdSequence.GetNext());
            var responseMessage = await Cluster.Messaging.SendToKeyPartitionOwnerAsync(requestMessage, keyData).CfAwait();
            _ = MultiMapUnlockCodec.DecodeResponse(responseMessage);
        }

        /// &lt;inheritdoc /&gt;
        public async Task ForceUnlockAsync(TKey key)
        {
            var keyData = ToSafeData(key);
            var requestMessage = MultiMapForceUnlockCodec.EncodeRequest(Name, keyData, _lockReferenceIdSequence.GetNext());
            var responseMessage = await Cluster.Messaging.SendToKeyPartitionOwnerAsync(requestMessage, keyData).CfAwait();
            _ = MultiMapForceUnlockCodec.DecodeResponse(responseMessage);
        }

        /// &lt;inheritdoc /&gt;
        public async IAsyncEnumerator&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; GetAsyncEnumerator(CancellationToken cancellationToken = default)
        {
            // all collections are async enumerable,
            // but by default we load the whole items set at once,
            // then iterate in memory
            var items = await GetEntrySetAsync(cancellationToken).CfAwait();
            foreach (var item in items)
                yield return item;
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[35,15,35,103,0],[37,13,37,64,0],[38,9,38,10,0],[42,16,42,72,0],[46,16,46,77,0],[50,13,50,32,0],[50,33,50,81,0],[52,13,52,70,0],[53,13,53,30,0],[57,13,57,40,0],[58,13,58,45,0],[60,13,62,22,0],[62,22,62,110,0],[62,110,63,22,0],[63,22,63,129,0],[63,129,64,22,0],[64,22,64,55,0],[64,55,65,15,0],[67,13,73,72,0],[75,13,75,79,0],[77,13,77,36,0],[78,9,78,10,0],[83,19,83,46,0],[85,17,85,29,0],[86,13,86,14,0],[88,31,88,35,0],[93,13,93,67,0],[95,13,97,22,0],[97,22,97,127,0],[97,127,98,22,0],[98,22,98,132,0],[98,132,99,22,0],[99,22,99,55,0],[99,55,100,15,0],[105,13,105,36,0],[105,37,105,44,0],[106,13,106,59,0],[108,13,108,62,0],[109,13,109,46,0],[110,13,110,52,0],[111,13,111,58,0],[112,13,112,66,0],[114,13,114,67,0],[117,22,117,33,0],[117,34,117,36,0],[117,37,117,52,0],[119,17,119,57,0],[121,21,123,103,0],[123,103,123,234,0],[123,234,124,96,0],[124,96,124,178,0],[124,178,125,30,0],[125,30,125,63,0],[125,63,126,23,0],[127,21,127,42,0],[130,9,130,10,0],[134,13,134,67,0],[135,13,135,96,0],[140,13,140,67,0],[142,13,144,22,0],[144,22,144,92,0],[144,92,145,22,0],[145,22,145,97,0],[145,97,146,22,0],[146,22,146,55,0],[146,55,147,15,0],[152,13,152,105,0],[157,16,157,52,0],[162,13,162,63,0],[163,13,163,102,0],[164,13,164,123,0],[165,13,165,78,0],[166,9,166,10,0],[171,13,171,43,0],[172,13,172,91,0],[173,13,173,123,0],[174,13,174,86,0],[175,13,175,81,0],[176,9,176,10,0],[180,17,180,57,0],[184,13,184,76,0],[185,13,185,114,0],[186,13,186,91,0],[187,13,187,96,0],[188,9,188,10,0],[193,13,193,74,0],[194,13,194,95,0],[195,13,195,89,0],[196,13,196,79,0],[197,9,197,10,0],[202,13,202,74,0],[203,13,203,95,0],[204,13,204,90,0],[205,13,205,81,0],[206,9,206,10,0],[211,13,211,63,0],[212,13,212,112,0],[213,13,213,123,0],[214,13,214,88,0],[215,9,215,10,0],[220,13,220,43,0],[221,13,221,99,0],[222,13,222,123,0],[223,13,223,86,0],[224,9,224,10,0],[229,13,229,47,0],[230,13,230,92,0],[231,13,231,95,0],[232,13,232,88,0],[233,9,233,10,0],[238,13,238,72,0],[239,13,239,95,0],[240,13,240,79,0],[241,9,241,10,0],[246,13,246,43,0],[247,13,247,98,0],[248,13,248,123,0],[249,13,249,85,0],[250,9,250,10,0],[255,13,255,63,0],[257,13,257,110,0],[258,13,258,123,0],[259,13,259,86,0],[260,9,260,10,0],[265,13,265,43,0],[267,13,267,94,0],[268,13,268,123,0],[269,13,269,89,0],[270,13,270,81,0],[271,9,271,10,0],[276,13,276,43,0],[278,13,278,94,0],[279,13,279,101,0],[280,9,280,10,0],[285,13,285,73,0],[286,13,286,95,0],[287,13,287,68,0],[288,9,288,10,0],[292,16,292,70,0],[296,16,296,88,0],[300,16,300,85,0],[305,13,305,43,0],[306,13,306,63,0],[307,13,307,65,0],[308,13,308,158,0],[309,13,309,123,0],[310,13,310,82,0],[311,9,311,10,0],[316,13,316,43,0],[317,13,317,63,0],[318,13,318,141,0],[319,13,319,123,0],[320,13,320,67,0],[321,9,321,10,0],[326,13,326,43,0],[327,13,327,85,0],[328,13,328,123,0],[329,13,329,83,0],[330,9,330,10,0],[335,13,335,43,0],[336,13,336,130,0],[337,13,337,123,0],[338,13,338,69,0],[339,9,339,10,0],[344,13,344,43,0],[345,13,345,124,0],[346,13,346,123,0],[347,13,347,74,0],[348,9,348,10,0],[356,13,356,77,0],[357,22,357,30,0],[357,31,357,33,0],[357,34,357,39,0],[358,17,358,35,0],[359,9,359,10,0]]);
    </script>
  </body>
</html>