<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Core\TypeExtensions.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using System.Linq;

namespace Hazelcast.Core
{
    /// &lt;summary&gt;
    /// Provides extension methods for the &lt;see cref=&quot;Type&quot;/&gt; class.
    /// &lt;/summary&gt;
    internal static class TypeExtensions
    {
        /// &lt;summary&gt;
        /// Determines whether this type is a nullable type.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;type&quot;&gt;This type.&lt;/param&gt;
        /// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt; if this type is a nullable type; otherwise &lt;c&gt;false&lt;/c&gt;.&lt;/returns&gt;
        public static bool IsNullableType(this Type type)
        {
            if (type == null) throw new ArgumentNullException(nameof(type));

            return type.IsGenericType &amp;&amp; type.GetGenericTypeDefinition() == typeof (Nullable&lt;&gt;);
        }

        /// &lt;summary&gt;
        /// Returns a string representing this type in C# style.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;type&quot;&gt;This type.&lt;/param&gt;
        /// &lt;param name=&quot;fqn&quot;&gt;Whether to keep fully-qualified name or shorten them.&lt;/param&gt;
        /// &lt;returns&gt;A string representing this type in C# style.&lt;/returns&gt;
        public static string ToCsString(this Type type, bool fqn = false)
        {
            if (type == null) throw new ArgumentNullException(nameof(type));

            var s = type.FullName;
            if (s == null) return type.ToString();
            if (!type.IsGenericType) return NonGenericToCsString(s, fqn);

            var p = s.IndexOf(&#39;`&#39;, StringComparison.Ordinal);
            var def = NonGenericToCsString(s.Substring(0, p), fqn);
            var args = type.GetGenericArguments().Select(x =&gt; x.ToCsString(fqn));

            return def + &quot;&lt;&quot; + string.Join(&quot;, &quot;, args) + &quot;&gt;&quot;;
        }

        private static string NonGenericToCsString(string fullname, bool fqn)
        {
            if (TypesMap.TryGetValue(fullname, out var typeName))
                return typeName;

            var name = fullname;
            if (!fqn)
            {
                var pos = name.LastIndexOf(&#39;.&#39;);
                if (pos &gt;= 0) name = name[(pos + 1)..];
            }
            return name.Replace(&#39;+&#39;, &#39;.&#39;);
        }

        private static readonly IDictionary&lt;string, string&gt; TypesMap = new Dictionary&lt;string, string&gt;(StringComparer.OrdinalIgnoreCase)
        {
            { &quot;System.Int16&quot;, &quot;short&quot; },
            { &quot;System.Int32&quot;, &quot;int&quot; },
            { &quot;System.Int64&quot;, &quot;long&quot; },
            { &quot;System.String&quot;, &quot;string&quot; },
            { &quot;System.Object&quot;, &quot;object&quot; },
            { &quot;System.Boolean&quot;, &quot;bool&quot; },
            { &quot;System.Void&quot;, &quot;void&quot; },
            { &quot;System.Char&quot;, &quot;char&quot; },
            { &quot;System.Byte&quot;, &quot;byte&quot; },
            { &quot;System.UInt16&quot;, &quot;ushort&quot; },
            { &quot;System.UInt32&quot;, &quot;uint&quot; },
            { &quot;System.UInt64&quot;, &quot;ulong&quot; },
            { &quot;System.SByte&quot;, &quot;sbyte&quot; },
            { &quot;System.Single&quot;, &quot;float&quot; },
            { &quot;System.Double&quot;, &quot;double&quot; },
            { &quot;System.Decimal&quot;, &quot;decimal&quot; }
        };
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[33,13,33,30,0],[33,31,33,77,0],[35,13,35,97,0],[46,13,46,30,0],[46,31,46,77,0],[48,13,48,35,0],[49,13,49,27,0],[49,28,49,51,0],[50,13,50,37,0],[50,38,50,74,0],[52,13,52,62,0],[53,13,53,68,0],[54,13,54,63,0],[54,63,54,80,0],[54,80,54,82,0],[56,13,56,62,0],[61,13,61,66,0],[62,17,62,33,0],[64,13,64,33,0],[65,13,65,22,0],[67,17,67,49,0],[68,17,68,30,0],[68,31,68,56,0],[70,13,70,43,0],[73,9,91,11,0]]);
    </script>
  </body>
</html>