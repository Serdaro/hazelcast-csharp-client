<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Networking\SocketConnectionBase.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Buffers;
using System.IO;
using System.IO.Pipelines;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using Hazelcast.Core;

namespace Hazelcast.Networking
{
    /// &lt;summary&gt;
    /// Represents a socket connection.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// &lt;para&gt;The socket connection handle message bytes, and manages the network socket.&lt;/para&gt;
    /// &lt;/remarks&gt;
    internal abstract partial class SocketConnectionBase : IAsyncDisposable
    {
        private readonly CancellationTokenSource _streamReadCancellationTokenSource = new CancellationTokenSource();

        private Func&lt;SocketConnectionBase, IBufferReference&lt;ReadOnlySequence&lt;byte&gt;&gt;, bool&gt; _onReceiveMessageBytes;
        private Func&lt;SocketConnectionBase, ReadOnlySequence&lt;byte&gt;, ValueTask&gt; _onReceivePrefixBytes;
        private Func&lt;SocketConnectionBase, ValueTask&gt; _onShutdown;
        private Task _pipeWriting, _pipeReading, _pipeWritingThenShutdown, _pipeReadingThenShutdown;
        private Socket _socket;
        private Stream _stream;
        private Pipe _pipe;
        private int _isActive;
        private int _isShutdown;
        private int _prefixLength;

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;SocketConnectionBase&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;id&quot;&gt;The unique identifier of the connection.&lt;/param&gt;
        /// &lt;param name=&quot;prefixLength&quot;&gt;An optional prefix length.&lt;/param&gt;
        protected SocketConnectionBase(Guid id, int prefixLength = 0)
        {
            Id = id;

            _prefixLength = prefixLength;
        }

        /// &lt;summary&gt;
        /// Gets the unique identifier of the socket.
        /// &lt;/summary&gt;
        public Guid Id { get; }

        /// &lt;summary&gt;
        /// Gets or sets the function that handles message bytes.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;The function must process the content of the bytes sequence before it completes.
        /// The memory associated with the sequence is not guaranteed to remain available after the
        /// function has returned.&lt;/para&gt;
        /// &lt;para&gt;The function must be set before the connection is established.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public Func&lt;SocketConnectionBase, IBufferReference&lt;ReadOnlySequence&lt;byte&gt;&gt;, bool&gt; OnReceiveMessageBytes
        {
            get =&gt; _onReceiveMessageBytes;
            set
            {
                if (_isActive == 1)
                    throw new InvalidOperationException(&quot;Cannot set the property once the connection is active.&quot;);

                _onReceiveMessageBytes = value ?? throw new ArgumentNullException(nameof(value));
            }
        }

        /// &lt;summary&gt;
        /// Gets or sets the function that handles prefix bytes.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;The function must process the content of the bytes sequence before it completes.
        /// The memory associated with the sequence is not guaranteed to remain available after the
        /// function has returned.&lt;/para&gt;
        /// &lt;para&gt;The function must be set before the connection is established.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public Func&lt;SocketConnectionBase, ReadOnlySequence&lt;byte&gt;, ValueTask&gt; OnReceivePrefixBytes
        {
            get =&gt; _onReceivePrefixBytes;
            set
            {
                if (_isActive == 1)
                    throw new InvalidOperationException(&quot;Cannot set the property once the connection is active.&quot;);

                _onReceivePrefixBytes = value ?? throw new ArgumentNullException(nameof(value));
            }
        }

        /// &lt;summary&gt;
        /// Specifies that the connection should expect prefix bytes.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;prefixLength&quot;&gt;The prefix length.&lt;/param&gt;
        /// &lt;param name=&quot;onReceivePrefixBytes&quot;&gt;The function that handles prefix bytes.&lt;/param&gt;
        public void ExpectPrefixBytes(int prefixLength, Func&lt;SocketConnectionBase, ReadOnlySequence&lt;byte&gt;, ValueTask&gt; onReceivePrefixBytes)
        {
            _prefixLength = prefixLength;
            _onReceivePrefixBytes = onReceivePrefixBytes;
        }

        /// &lt;summary&gt;
        /// Gets or sets the function that handle shutdowns.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;The function must be set before the connection is established.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public Func&lt;SocketConnectionBase, ValueTask&gt; OnShutdown
        {
            get =&gt; _onShutdown;
            set
            {
                if (_isActive == 1)
                    throw new InvalidOperationException(&quot;Cannot set the property once the connection is active.&quot;);

                _onShutdown = value ?? throw new ArgumentNullException(nameof(value));
            }
        }

        /// &lt;summary&gt;
        /// Gets a value indicating whether the connection is active.
        /// &lt;/summary&gt;
        public bool IsActive =&gt; _isActive == 1;

        /// &lt;summary&gt;
        /// Gets the date and time when the connection was created.
        /// &lt;/summary&gt;
        public DateTime CreateTime { get; private set; }

        /// &lt;summary&gt;
        /// Gets the date and time when bytes were last written by the connection.
        /// &lt;/summary&gt;
        public DateTime LastWriteTime { get; private set; }

        /// &lt;summary&gt;
        /// Gets the date and time when bytes were last read by the connection.
        /// &lt;/summary&gt;
        public DateTime LastReadTime { get; private set; }

        /// &lt;summary&gt;
        /// Gets the remote endpoint of the connection.
        /// &lt;/summary&gt;
        public IPEndPoint RemoteEndPoint =&gt; _socket?.RemoteEndPoint as IPEndPoint;

        /// &lt;summary&gt;
        /// Gets the local endpoint of the connection.
        /// &lt;/summary&gt;
        public IPEndPoint LocalEndPoint =&gt; _socket?.LocalEndPoint as IPEndPoint;

        /// &lt;summary&gt;
        /// Gets the pipe - for unit tests exclusively.
        /// &lt;/summary&gt;
        // ReSharper disable once ConvertToAutoPropertyWithPrivateSetter
        protected Pipe Pipe =&gt; _pipe;

        /// &lt;summary&gt;
        /// (protected for tests only) Gets the stream read cancellation token source.
        /// &lt;/summary&gt;
        // ReSharper disable once InconsistentNaming
        protected CancellationTokenSource StreamReadCancellationTokenSource =&gt; _streamReadCancellationTokenSource;

        /// &lt;summary&gt;
        /// Ensures that the socket can open the pipe.
        /// &lt;/summary&gt;
        protected void EnsureCanOpenPipe()
        {
            // _onShutdown is not mandatory, but validate _onReceiveMessageBytes
            if (_onReceiveMessageBytes == null)
                throw new InvalidOperationException(&quot;Missing message bytes handler.&quot;);
            if (_prefixLength &gt; 0 &amp;&amp; _onReceivePrefixBytes == null)
                throw new InvalidOperationException(&quot;Missing prefix bytes handler.&quot;);
        }

        /// &lt;summary&gt;
        /// Opens the pipe.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;The &lt;see cref=&quot;OnReceiveMessageBytes&quot;/&gt; function must be set before this function is invoked.&lt;/para&gt;
        /// &lt;/remarks&gt;
        protected void OpenPipe(Socket socket, Stream stream)
        {
            _socket = socket ?? throw new ArgumentNullException(nameof(socket));
            _stream = stream ?? throw new ArgumentNullException(nameof(stream));

            EnsureCanOpenPipe();

            Interlocked.Exchange(ref _isActive, 1);

            CreateTime = DateTime.Now;

            // wire the pipe
            _pipe = new Pipe();
            _pipeWriting = WritePipeAsync(_stream, _pipe.Writer);
            _pipeWritingThenShutdown = _pipeWriting.ContinueWith(ShutdownInternal, TaskScheduler.Current);
            _pipeReading = ReadPipeAsync(_pipe.Reader);
            _pipeReadingThenShutdown = _pipeReading.ContinueWith(ShutdownInternal, TaskScheduler.Current);
        }

        /// &lt;summary&gt;
        /// Shuts the connection down after a task has completed.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;task&quot;&gt;The completed task.&lt;/param&gt;
        /// &lt;returns&gt;A task that will complete when the connection is down.&lt;/returns&gt;
        private async ValueTask ShutdownInternal(Task task)
        {
            // only once
            if (Interlocked.CompareExchange(ref _isShutdown, 1, 0) == 1)
                return;

            HConsole.WriteLine(this, &quot;Bringing connection down&quot;);

            Interlocked.Exchange(ref _isActive, 0);

            // ensure the pipe writing task aborts
            _streamReadCancellationTokenSource.Cancel();

            // ensure everything is down by awaiting the other task
            // FIXME why could this be null ?!
            var otherTask = task == _pipeReading ? _pipeWriting : _pipeReading;
            if (otherTask != null) await otherTask.CfAwait();

            // kill socket and stream
            try
            {
                _stream.Close();
                _socket.Shutdown(SocketShutdown.Both);
                _socket.Close();
            }
            catch { /* ignore */ }

            HConsole.WriteLine(this, &quot;Connection is down&quot;);

            // notify
            await _onShutdown.AwaitEach(this).CfAwaitNoThrow();
        }

        /// &lt;summary&gt;
        /// Sends bytes.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;bytes&quot;&gt;The bytes to send.&lt;/param&gt;
        /// &lt;param name=&quot;length&quot;&gt;The number of bytes to send.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;A cancellation token.&lt;/param&gt;
        /// &lt;returns&gt;A task that will complete when the message bytes have been sent.&lt;/returns&gt;
        // virtual for tests
        public virtual async ValueTask&lt;bool&gt; SendAsync(byte[] bytes, int length, CancellationToken cancellationToken = default)
        {
            if (_isActive == 0)
                return false;

            // send bytes
            try
            {
                await _stream.WriteAsync(bytes, 0, length, cancellationToken).CfAwait();
                LastWriteTime = DateTime.Now;
            }
            catch (Exception e)
            {
                // on error, shutdown and report
                HConsole.WriteLine(this, &quot;SendAsync:ERROR&quot;);
                HConsole.WriteLine(this, e);
                _streamReadCancellationTokenSource.Cancel();
                return false;
            }

            HConsole.WriteLine(this, 2, $&quot;Sent {length} bytes&quot; + HConsole.Lines(this, 1 , bytes.Dump(length)));
            return true;
        }

        /// &lt;summary&gt;
        /// Flushes the connection.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;A task that will complete when the connection is flushed.&lt;/returns&gt;
        // virtual for tests
        public virtual async ValueTask FlushAsync()
        {
            await _stream.FlushAsync().CfAwait();
        }

        /// &lt;summary&gt;
        /// Reads from network, and writes to the pipe.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;stream&quot;&gt;The &lt;see cref=&quot;Stream&quot;/&gt; to read from.&lt;/param&gt;
        /// &lt;param name=&quot;writer&quot;&gt;The &lt;see cref=&quot;PipeWriter&quot;/&gt; to write to.&lt;/param&gt;
        /// &lt;returns&gt;A task representing the write loop, that completes when the stream
        /// is closed, or when an error occurs.&lt;/returns&gt;
        protected async Task WritePipeAsync(Stream stream, PipeWriter writer)
        {
            if (stream == null) throw new ArgumentNullException(nameof(stream));
            if (writer == null) throw new ArgumentNullException(nameof(writer));

            const int minimumBufferSize = 512;

            while (true)
            {
                // allocate at least 512 bytes from the PipeWriter
                var memory = writer.GetMemory(minimumBufferSize);
                int bytesRead;
                try
                {
                    HConsole.WriteLine(this, 2, &quot;Pipe writer waiting for data&quot;);
                    bytesRead = await stream.ReadAsync(memory, _streamReadCancellationTokenSource.Token).CfAwait();

                    if (bytesRead == 0)
                    {
                        HConsole.WriteLine(this, 2, &quot;Pipe writer received no data&quot;);
                        break;
                    }

                    LastReadTime = DateTime.Now;
                }
                catch (OperationCanceledException)
                {
                    // expected - just break
                    HConsole.WriteLine(this, 2, &quot;Pipe writer has been cancelled&quot;);
                    break;
                }
                catch (Exception ex)
                {
                    // on error, shutdown and break, this will complete the reader
                    HConsole.WriteLine(this, &quot;Pipe writer:ERROR&quot;);
                    HConsole.WriteLine(this, ex);
                    break;
                }

                // tell the PipeWriter how much was read from the network
                HConsole.WriteLine(this, 2, $&quot;Pipe writer received {bytesRead} bytes&quot;);
                writer.Advance(bytesRead);

                // make the data available to the PipeReader
                var result = await writer.FlushAsync().CfAwait();

                if (result.IsCompleted)
                {
                    HConsole.WriteLine(this, &quot;Pipe is completed (in writer)&quot;);
                    break;
                }
            }

            // tell the PipeReader that there&#39;s no more data coming
            HConsole.WriteLine(this, &quot;Pipe writer completing&quot;);
            await writer.CompleteAsync().CfAwait();
        }

        /// &lt;summary&gt;
        /// Reads from the pipe, and processes data.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;reader&quot;&gt;The &lt;see cref=&quot;PipeReader&quot;/&gt; to read from.&lt;/param&gt;
        /// &lt;returns&gt;A task representing the read loop, that completes when an empty message
        /// is received, or when there is no more data coming (writer completed).&lt;/returns&gt;
        protected async Task ReadPipeAsync(PipeReader reader)
        {
            if (reader == null) throw new ArgumentNullException(nameof(reader));

            // loop reading data from the pipe
            var state = new ReadPipeState { Reader = reader };
            while (await ReadPipeLoop0(state).CfAwait()) { }

            // exception?
            if (state.Failed)
            {
                if (state.Exception != null)
                {
                    // TODO what shall we do with the exception?
                    HConsole.WriteLine(this, &quot;ERROR &quot; + state.Exception.SourceException);
                }
            }

            // mark the PipeReader as complete
            HConsole.WriteLine(this, &quot;Pipe reader completing&quot;);
            await reader.CompleteAsync().CfAwait();
        }

        /// &lt;summary&gt;
        /// Reads from the pipe, and processes data.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;state&quot;&gt;The reading state.&lt;/param&gt;
        /// &lt;returns&gt;A task that will complete when data has been read and processed,
        /// and represents whether to continue reading.&lt;/returns&gt;
        private async ValueTask&lt;bool&gt; ReadPipeLoop0(ReadPipeState state)
        {
            // await data from the pipe
            HConsole.WriteLine(this, 2, &quot;Pipe reader awaits data from the pipe&quot;);
            var result = await state.Reader.ReadAsync().CfAwait();
            state.Buffer = result.Buffer;

            // no data means it&#39;s over
            if (state.Buffer.Length == 0)
            {
                HConsole.WriteLine(this, 2, &quot;Pipe reader received no data&quot;);
                return false;
            }

            HConsole.WriteLine(this, 2, $&quot;Pipe reader received data, buffer size is {state.Buffer.Length} bytes&quot;);

            // process data
            while (await ReadPipeLoop1(state).CfAwait()) { }

            // tell the PipeReader how much of the buffer we have consumed
            state.Reader.AdvanceTo(state.Buffer.Start, state.Buffer.End);

            // shutdown on crash
            if (state.Failed)
                return false;

            // stop reading if there&#39;s no more data coming
            if (result.IsCompleted)
            {
                HConsole.WriteLine(this, &quot;Pipe is completed (in reader)&quot;);
                return false;
            }

            return true;
        }

        /// &lt;summary&gt;
        /// Processes data from the pipe.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;state&quot;&gt;The reading state.&lt;/param&gt;
        /// &lt;returns&gt;A task that will complete when data has been processed,
        /// and represents whether to continue processing.&lt;/returns&gt;
        private async ValueTask&lt;bool&gt; ReadPipeLoop1(ReadPipeState state)
        {
            HConsole.WriteLine(this, 2, &quot;Pipe reader processes data&quot; + HConsole.Lines(this, 1, state.Buffer.Dump()));

            if (_prefixLength &gt; 0)
            {
                if (state.Buffer.Length &lt; _prefixLength)
                {
                    HConsole.WriteLine(this, 2, &quot;Pipe reader has not enough data&quot;);
                    return false;
                }

                // we have a prefix, handle lit
                try
                {
                    HConsole.WriteLine(this, 2, &quot;Pipe reader received prefix&quot;);
                    await _onReceivePrefixBytes(this, state.Buffer.Slice(0, _prefixLength)).CfAwait();
                    state.Buffer = state.Buffer.Slice(_prefixLength);
                    _prefixLength = 0;
                }
                catch (Exception e)
                {
                    // error while processing, report and shutdown
                    HConsole.WriteLine(this, &quot;Pipe reader encountered an exception while handling the prefix (shutdown)&quot;);
                    HConsole.WriteLine(this, e);
                    state.CaptureExceptionAndFail(e);
                    return false;
                }

                HConsole.WriteLine(this, 2, &quot;Pipe reader processes data&quot;);
            }

            HConsole.WriteLine(this, 2, &quot;Handle message bytes&quot; + HConsole.Lines(this, 1, state.Buffer.Dump()));
            try
            {
                // handle the bytes (and slice the buffer accordingly)
                return _onReceiveMessageBytes(this, state);
            }
            catch (Exception e)
            {
                // error while processing, report
                HConsole.WriteLine(this, &quot;Pipe reader encountered an exception while handling message bytes&quot;);
                HConsole.WriteLine(this, e);
                state.CaptureExceptionAndFail(e);
                return false;
            }
        }

        /// &lt;inheritdoc /&gt;
        public async ValueTask DisposeAsync()
        {
            // note: DisposeAsync should not throw (CA1065)

            if (Interlocked.CompareExchange(ref _isActive, 0, 1) == 0)
                return;

            // requests that the pipe stops processing - which will trigger
            // ShutdownInternal which will close the socket etc
            HConsole.WriteLine(this, &quot;Cancel pipe&quot;);
            _streamReadCancellationTokenSource.Cancel();

            // wait for everything to be down
            await Task.WhenAll(_pipeWritingThenShutdown, _pipeReadingThenShutdown).CfAwait();
            HConsole.WriteLine(this, &quot;Pipe is down&quot;);

            // dispose, ignore exceptions
            try
            {
                _stream.Close();
                _stream.Dispose();
            }
            catch { /* ignore */ }

            try
            {
                _socket.Shutdown(SocketShutdown.Both);
                _socket.Dispose();
            }
            catch { /* ignore */ }

            // ok to dispose again
            _streamReadCancellationTokenSource.Dispose();
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[35,9,35,117,0],[53,9,53,70,0],[55,13,55,21,0],[57,13,57,42,0],[58,9,58,10,0],[63,26,63,30,0],[76,20,76,42,0],[79,17,79,36,0],[80,21,80,115,0],[82,17,82,98,0],[83,13,83,14,0],[97,20,97,41,0],[100,17,100,36,0],[101,21,101,115,0],[103,17,103,97,0],[104,13,104,14,0],[114,13,114,42,0],[115,13,115,58,0],[116,9,116,10,0],[126,20,126,31,0],[129,17,129,36,0],[130,21,130,115,0],[132,17,132,87,0],[133,13,133,14,0],[139,33,139,47,0],[144,38,144,42,0],[144,43,144,55,0],[149,41,149,45,0],[149,46,149,58,0],[154,40,154,44,0],[154,45,154,57,0],[159,45,159,82,0],[164,44,164,80,0],[170,32,170,37,0],[176,80,176,114,0],[184,13,184,48,0],[185,17,185,87,0],[186,13,186,68,0],[187,17,187,86,0],[188,9,188,10,0],[198,13,198,81,0],[199,13,199,81,0],[201,13,201,33,0],[203,13,203,52,0],[205,13,205,39,0],[208,13,208,32,0],[209,13,209,66,0],[210,13,210,107,0],[211,13,211,56,0],[212,13,212,107,0],[213,9,213,10,0],[223,13,223,73,0],[224,17,224,24,0],[228,13,228,52,0],[231,13,231,57,0],[235,13,235,80,0],[236,13,236,35,0],[236,36,236,62,0],[241,17,241,33,0],[242,17,242,55,0],[243,17,243,33,0],[244,13,244,14,0],[245,13,245,18,0],[245,34,245,35,0],[250,13,250,64,0],[251,9,251,10,0],[263,13,263,32,0],[264,17,264,30,0],[269,17,269,89,0],[270,17,270,46,0],[271,13,271,14,0],[272,13,272,32,0],[277,17,277,61,0],[278,17,278,30,0],[282,13,282,25,0],[283,9,283,10,0],[292,13,292,50,0],[293,9,293,10,0],[304,13,304,32,0],[304,33,304,81,0],[305,13,305,32,0],[305,33,305,81,0],[312,17,312,66,0],[317,21,317,116,0],[319,21,319,40,0],[322,25,322,31,0],[325,21,325,49,0],[326,17,326,18,0],[327,17,327,51,0],[331,21,331,27,0],[333,17,333,37,0],[338,21,338,27,0],[343,17,343,43,0],[346,17,346,66,0],[348,17,348,40,0],[357,13,357,52,0],[358,9,358,10,0],[368,13,368,32,0],[368,33,368,81,0],[371,13,371,63,0],[372,13,372,57,0],[375,13,375,30,0],[377,17,377,45,0],[386,13,386,52,0],[387,9,387,10,0],[399,13,399,67,0],[400,13,400,42,0],[403,13,403,42,0],[406,17,406,30,0],[412,13,412,57,0],[415,13,415,74,0],[418,13,418,30,0],[419,17,419,30,0],[422,13,422,36,0],[425,17,425,30,0],[428,13,428,25,0],[429,9,429,10,0],[441,13,441,35,0],[443,17,443,57,0],[446,21,446,34,0],[453,21,453,103,0],[454,21,454,70,0],[455,21,455,39,0],[456,17,456,18,0],[457,17,457,36,0],[462,21,462,54,0],[463,21,463,34,0],[473,17,473,60,0],[475,13,475,32,0],[480,17,480,50,0],[481,17,481,30,0],[483,9,483,10,0],[490,13,490,71,0],[491,17,491,24,0],[496,13,496,57,0],[499,13,499,94,0],[505,17,505,33,0],[506,17,506,35,0],[507,13,507,14,0],[508,13,508,18,0],[508,34,508,35,0],[512,17,512,55,0],[513,17,513,35,0],[514,13,514,14,0],[515,13,515,18,0],[515,34,515,35,0],[518,13,518,58,0],[519,9,519,10,0]]);
    </script>
  </body>
</html>