<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Clustering\ClusterEvents.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Hazelcast.Core;
using Hazelcast.Events;
using Hazelcast.Exceptions;
using Hazelcast.Messaging;
using Hazelcast.Models;
using Hazelcast.Protocol.Codecs;
using Microsoft.Extensions.Logging;

namespace Hazelcast.Clustering
{
    /// &lt;summary&gt;
    /// Provides the cluster events service for a cluster.
    /// &lt;/summary&gt;
    internal partial class ClusterEvents : IAsyncDisposable
    {
        private readonly TerminateConnections _terminateConnections;

        private readonly ClusterState _clusterState;
        private readonly ClusterMessaging _clusterMessaging;
        private readonly ClusterMembers _clusterMembers;
        private readonly DistributedEventScheduler _scheduler;
        private readonly ILogger _logger;

        private readonly CancellationTokenSource _cancel = new CancellationTokenSource();
        private readonly object _mutex = new object(); // subscriptions and connections

        private Func&lt;ValueTask&gt; _partitionsUpdated;
        private Func&lt;MembersUpdatedEventArgs, ValueTask&gt; _membersUpdated;

        private readonly object _clusterViewsMutex = new object();
        private MemberConnection _clusterViewsConnection; // the connection which supports the view event
        private long _clusterViewsCorrelationId; // the correlation id of the view event subscription
        private Task _clusterViewsTask; // the task that assigns a connection to support the view event

        private volatile int _disposed;

        // connections
        private readonly HashSet&lt;MemberConnection&gt; _connections = new HashSet&lt;MemberConnection&gt;();
        private TaskCompletionSource&lt;object&gt; _connectionOpened;

        // subscription id -&gt; subscription
        // the master subscriptions list
        private readonly ConcurrentDictionary&lt;Guid, ClusterSubscription&gt; _subscriptions = new ConcurrentDictionary&lt;Guid, ClusterSubscription&gt;();

        // subscribe tasks
        private readonly object _subscribeTasksMutex = new object();
        private Dictionary&lt;MemberConnection, Task&gt; _subscribeTasks = new Dictionary&lt;MemberConnection, Task&gt;(); // the tasks that subscribe new connections

        // correlation id -&gt; subscription
        // used to match a subscription to an incoming event message
        // each connection has its own correlation id, so there can be many entries per cluster subscription
        private readonly ConcurrentDictionary&lt;long, ClusterSubscription&gt; _correlatedSubscriptions = new ConcurrentDictionary&lt;long, ClusterSubscription&gt;();

        // ghost subscriptions, to be collected
        // subscriptions that have failed to properly unsubscribe and now we need to take care of them
        private readonly HashSet&lt;MemberSubscription&gt; _collectSubscriptions = new HashSet&lt;MemberSubscription&gt;();
        private readonly object _collectMutex = new object();
        private Task _collectTask; // the task that collects ghost subscriptions

        static ClusterEvents()
        {
            HConsole.Configure(x =&gt; x.Configure&lt;ClusterEvents&gt;().SetPrefix(&quot;CLUST.EVTS&quot;));
        }

        public ClusterEvents(ClusterState clusterState, ClusterMessaging clusterMessaging, TerminateConnections terminateConnections, ClusterMembers clusterMembers)
        {
            _clusterState = clusterState;
            _clusterMessaging = clusterMessaging;
            _clusterMembers = clusterMembers;

            _logger = _clusterState.LoggerFactory.CreateLogger&lt;ClusterEvents&gt;();
            _scheduler = new DistributedEventScheduler(_clusterState.LoggerFactory);
            _terminateConnections = terminateConnections;

            _objectLifecycleEventSubscription = new ObjectLifecycleEventSubscription(_clusterState, this)
            {
                ObjectCreated = args =&gt; _objectCreated.AwaitEach(args),
                ObjectDestroyed = args =&gt; _objectDestroyed.AwaitEach(args)
            };

            _partitionLostEventSubscription = new PartitionLostEventSubscription(_clusterState, this, clusterMembers)
            {
                PartitionLost = args =&gt; _partitionLost.AwaitEach(args)
            };
        }

        /// &lt;summary&gt;
        /// (internal for tests only) Gets the subscriptions.
        /// &lt;/summary&gt;
        internal ConcurrentDictionary&lt;Guid, ClusterSubscription&gt; Subscriptions =&gt; _subscriptions;

        /// &lt;summary&gt;
        /// (internal for tests only) Gets the correlated subscriptions.
        /// &lt;/summary&gt;
        internal ConcurrentDictionary&lt;long, ClusterSubscription&gt; CorrelatedSubscriptions =&gt; _correlatedSubscriptions;

        /// &lt;summary&gt;
        /// (internal for tests only) Gets the ghost subscriptions that need to be collected.
        /// &lt;/summary&gt;
        internal HashSet&lt;MemberSubscription&gt; CollectSubscriptions =&gt; _collectSubscriptions;

        #region Add/Remove Subscriptions

        // _connections is the list of known member connections
        //   connections are added &amp; removed by handling the ConnectionOpened and ConnectionClosed events
        //   note: a connection may be opened yet not correspond to any member
        //
        // _subscriptions is the list of known cluster subscriptions
        //   subscriptions are added &amp; removed by invoking Add/RemoveSubscriptionAsync
        //   each subscription in _subscriptions must be added to each connection in _connections
        //
        // when a subscription is added,
        // - (mutex): capture _connections connections, add the subscription to _subscriptions
        // - for each connection
        //   - add a correlated subscription (before adding on server!)
        //   - add the subscription to the connection on server
        //     - fails
        //       - remove the correlated subscription
        //       - because
        //         - the connection is not active anymore = skip &amp; continue with other connections
        //         - any other reason = queue all member connections for collection
        //       - fail
        //   - try-add a member connection to subscription
        //     - fails (because the subscription is not active anymore)
        //       - remove the correlated subscription
        //       - nothing else to do: the subscription has been de-activated = clean
        //       - fail
        //
        // when a connection is added
        // - (mutex): capture _subscriptions subscriptions, add the connection to _connections
        // - for each subscription
        //   - add a correlated subscription (before adding on server!)
        //   - add the subscription to the connection on server
        //     - fails
        //       - remove the correlated subscription
        //       - because
        //         - the connection is not active anymore = queue all created member subscriptions for collection
        //         - for any other reason = terminate the connection
        //       - exit
        //   - try-add the corresponding member connection to the subscription
        //     - fails (because the subscription is not active anymore)
        //       - remove the correlated subscription
        //       - queue the member connection for collection
        //       - skip &amp; continue with other subscriptions
        //
        //
        // when a subscription is removed
        // - (mutex): remove the subscription from _subscriptions
        // - de-activate the subscription (cannot add member subscriptions anymore)
        // - for each member connection in the subscription,
        //   - clear the correlated subscription
        //   - remove from server
        //     - fails because the connection is not active anymore = consider it a success
        //     - fails for any other reason = queue the member subscription for collection
        //
        // note: meanwhile, if a connection is
        // - added: it will not see the subscription, or see it de-activated
        // - removed: removing from server will be considered a success
        //
        //
        // when a connection is removed
        // - (mutex): capture _subscriptions subscriptions, remove the connection from _connections
        // - for each subscription
        //   - remove the member subscription for the removed connection (cannot remove from server, connection is down)
        //   - remove the corresponding correlated subscription
        // - if it is the cluster views connection
        //   - clear
        //   - remove the corresponding correlated subscription
        //   - start assigning another connection
        //
        // note: meanwhile, if a subscription is
        // - added: it will not see the connection
        // - removed: never mind, we just have nothing to remove

        /// &lt;summary&gt;
        /// Adds a subscription.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;subscription&quot;&gt;The subscription.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;A cancellation token.&lt;/param&gt;
        /// &lt;returns&gt;A task that will complete when the subscription has been added.&lt;/returns&gt;
        public async Task AddSubscriptionAsync(ClusterSubscription subscription, CancellationToken cancellationToken = default)
        {
            if (subscription == null) throw new ArgumentNullException(nameof(subscription));

            // atomically get connections and add the subscription
            List&lt;MemberConnection&gt; connections;
            lock (_mutex)
            {
                // capture connections
                connections = _connections.ToList();

                // failing would be a nasty internal error but better report it
                if (!_subscriptions.TryAdd(subscription.Id, subscription))
                    throw new InvalidOperationException(&quot;A subscription with the same identifier already exists.&quot;);
            }

            // add the subscription to each captured connection
            // TODO: consider adding in parallel
            foreach (var connection in connections)
            {
                if (cancellationToken.IsCancellationRequested)
                {
                    CollectSubscription(subscription); // undo what has been done already
                    cancellationToken.ThrowIfCancellationRequested(); // and throw
                }

                // this never throws
                var attempt = await AddSubscriptionAsync(subscription, connection, cancellationToken).CfAwait();

                switch (attempt.Value)
                {
                    case InstallResult.Success: // good
                    case InstallResult.ConnectionNotActive: // ignore it
                        continue;

                    case InstallResult.SubscriptionNotActive:
                        // not active = has been de-activated = what has been done already has been undone
                        throw new HazelcastException(&quot;Failed to add the subscription because it was removed.&quot;);

                    case InstallResult.Failed: // also if canceled
                        CollectSubscription(subscription); // undo what has been done already
                        throw new HazelcastException(&quot;Failed to add subscription (see inner exception).&quot;, attempt.Exception);

                    default:
                        throw new NotSupportedException();
                }
            }
        }

        // adds a subscription on one member
        private async ValueTask&lt;Attempt&lt;InstallResult&gt;&gt; AddSubscriptionAsync(ClusterSubscription subscription, MemberConnection connection, CancellationToken cancellationToken)
        {
            // if we already know the connection is not active anymore, ignore it
            // otherwise, install on this member - may throw if the connection goes away in the meantime
            if (!connection.Active) return Attempt.Fail(InstallResult.ConnectionNotActive);

            // add correlated subscription now so it is ready when the first events come
            var correlationId = _clusterState.GetNextCorrelationId();
            _correlatedSubscriptions[correlationId] = subscription;

            // the original subscription.SubscribeRequest message may be used concurrently,
            // we need a safe clone so we can use our own correlation id in a safe way.
            var subscribeRequest = subscription.SubscribeRequest.CloneWithNewCorrelationId(correlationId);

            // talk to the server
            ClientMessage response;
            try
            {
                response = await _clusterMessaging.SendToMemberAsync(subscribeRequest, connection, correlationId, cancellationToken).CfAwait();
            }
            catch (Exception e)
            {
                _correlatedSubscriptions.TryRemove(correlationId, out _);
                return connection.Active
                    ? Attempt.Fail(InstallResult.Failed, e) // also if canceled
                    : Attempt.Fail(InstallResult.ConnectionNotActive);
            }

            // try to add the member subscription to the cluster subscription
            // fails if the cluster subscription is not active anymore
            var memberSubscription = subscription.ReadSubscriptionResponse(response, connection);
            var added = subscription.TryAddMemberSubscription(memberSubscription);
            if (added) return InstallResult.Success;

            // the subscription is not active anymore
            _correlatedSubscriptions.TryRemove(correlationId, out _);
            CollectSubscription(memberSubscription);
            return Attempt.Fail(InstallResult.SubscriptionNotActive);
        }

        // (background) adds subscriptions on one member - when a connection is added
        private async Task AddSubscriptionsAsync(MemberConnection connection, IReadOnlyCollection&lt;ClusterSubscription&gt; subscriptions, CancellationToken cancellationToken)
        {
            // this is a background task and therefore should never throw!

            foreach (var subscription in subscriptions)
            {
                if (cancellationToken.IsCancellationRequested) return;

                // this never throws
                var attempt = await AddSubscriptionAsync(subscription, connection, cancellationToken).CfAwait();

                switch (attempt.Value)
                {
                    case InstallResult.Success: // ok
                    case InstallResult.SubscriptionNotActive: // ignore it
                        continue;

                    case InstallResult.ConnectionNotActive:
                        // not active = has been removed = what has been done already has been undone
                        break; // simply exit

                    case InstallResult.Failed:
                        // failed to talk to the server - this connection is not working
                        _terminateConnections.Add(connection);
                        break; // exit

                    default:
                        continue;
                }
            }

            // we are done now
            lock (_subscribeTasksMutex) _subscribeTasks.Remove(connection);
        }

        /// &lt;summary&gt;
        /// Removes a subscription.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;subscriptionId&quot;&gt;The unique identifier of the subscription.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;A cancellation token.&lt;/param&gt;
        /// &lt;returns&gt;Whether the subscription was removed.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;This may throw in something goes wrong. In this case, the subscription
        /// is de-activated but remains in the lists, so that it is possible to try again.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public async ValueTask&lt;bool&gt; RemoveSubscriptionAsync(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            // get and remove the subscription
            ClusterSubscription subscription;
            lock (_mutex)
            {
                if (!_subscriptions.TryRemove(subscriptionId, out subscription))
                    return false; // unknown subscription
            }

            await RemoveSubscriptionAsync(subscription, cancellationToken).CfAwait();
            return true;
        }

        // removes a subscription
        private async ValueTask RemoveSubscriptionAsync(ClusterSubscription subscription, CancellationToken cancellationToken)
        {
            // de-activate the subscription: all further events will be ignored
            subscription.Deactivate();

            // for each member subscription
            foreach (var memberSubscription in subscription)
            {
                // runs them all regardless of cancellation

                // remove the correlated subscription
                _correlatedSubscriptions.TryRemove(memberSubscription.CorrelationId, out _);

                // remove from the server
                // and, if it fails, enqueue for collection
                if (await RemoveSubscriptionAsync(memberSubscription, cancellationToken).CfAwait())
                    subscription.Remove(memberSubscription);
                else
                    CollectSubscription(memberSubscription);
            }
        }

        // remove a subscription from one member
        private async ValueTask&lt;bool&gt; RemoveSubscriptionAsync(MemberSubscription subscription, CancellationToken cancellationToken)
        {
            // fast: if the connection is down, consider the subscription removed
            if (!subscription.Connection.Active) return true;

            try
            {
                // remove the member subscription = trigger the server-side un-subscribe
                // this *may* throw if we fail to talk to the member
                // this *may* return false for some reason
                var unsubscribeRequest = subscription.ClusterSubscription.CreateUnsubscribeRequest(subscription.ServerSubscriptionId);
                var responseMessage = await _clusterMessaging.SendToMemberAsync(unsubscribeRequest, subscription.Connection, cancellationToken).CfAwait();
                var removed = subscription.ClusterSubscription.ReadUnsubscribeResponse(responseMessage);
                return removed;
            }
            catch (Exception e)
            {
                // if the connection is down, consider the subscription removed
                if (!subscription.Connection.Active) return true;

                // otherwise something went wrong and maybe we want to try again
                _logger.LogError(e, &quot;Caught an exception while unsubscribing to events.&quot;);
                return false;
            }
        }

        // clears the subscriptions of a member that is gone fishing
        // the connection is down, no way to unsubscribe, just clear the data structures
        private void ClearMemberSubscriptions(IEnumerable&lt;ClusterSubscription&gt; subscriptions, MemberConnection connection)
        {
            foreach (var subscription in subscriptions)
            {
                // remove the correlated subscription
                // remove the client subscription
                if (subscription.TryRemove(connection, out var memberSubscription))
                    _correlatedSubscriptions.TryRemove(memberSubscription.CorrelationId, out _);
            }
        }

        #endregion

        #region Cluster Views

        /// &lt;summary&gt;
        /// Clears the connection currently supporting the cluster view event, if it matches the specified &lt;paramref name=&quot;connection&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;connection&quot;&gt;A connection.&lt;/param&gt;
        /// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt; if the current connection matched the specified connection, and was cleared; otherwise &lt;c&gt;false&lt;/c&gt;.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;If &lt;paramref name=&quot;connection&quot;/&gt; was supporting the cluster view event, and was not the last connection,
        /// this starts a background task to assign another connection to support the cluster view event.&lt;/para&gt;
        /// &lt;/remarks&gt;
        private void ClearClusterViewsConnection(MemberConnection connection)
        {
            // note: we do not &quot;unsubscribe&quot; - if we come here, the connection is gone

            lock (_clusterViewsMutex)
            {
                // if the specified client is *not* the cluster events client, ignore
                if (_clusterViewsConnection != connection)
                    return;

                // otherwise, clear the connection
                _clusterViewsConnection = null;
                _correlatedSubscriptions.TryRemove(_clusterViewsCorrelationId, out _);
                _clusterViewsCorrelationId = 0;

                HConsole.WriteLine(this, &quot;ClusterViews: no connection.&quot;);

                // assign another connection (async)
                _clusterViewsTask ??= AssignClusterViewsConnectionAsync(null, _cancel.Token);
            }
        }

        /// &lt;summary&gt;
        /// Proposes a connection to support the cluster view event.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;connection&quot;&gt;A connection.&lt;/param&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;if there is no connection currently supporting the cluster view event, then this starts a background
        /// task to assign a connection to support the event, trying the supplied &lt;paramref name=&quot;connection&quot;/&gt; first.&lt;/para&gt;
        /// &lt;/remarks&gt;
        private void ProposeClusterViewsConnection(MemberConnection connection)
        {
            lock (_clusterViewsMutex)
            {
                if (_clusterViewsConnection == null)
                    _clusterViewsTask ??= AssignClusterViewsConnectionAsync(connection, _cancel.Token);
            }
        }

        /// &lt;summary&gt;
        /// Assigns a connection to support the cluster view event.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;connection&quot;&gt;An optional candidate connection.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;A cancellation token.&lt;/param&gt;
        /// &lt;returns&gt;A task that will complete when a connection has been assigned to handle the cluster views event.&lt;/returns&gt;
        private async Task AssignClusterViewsConnectionAsync(MemberConnection connection, CancellationToken cancellationToken)
        {
            // TODO: consider throttling

            ValueTask&lt;MemberConnection&gt; WaitRandomConnection(CancellationToken token)
            {
                var c = _clusterMembers.GetRandomConnection();
                return c == null
                    ? WaitRandomConnection2(token)
                    : new ValueTask&lt;MemberConnection&gt;(c);
            }

            async ValueTask&lt;MemberConnection&gt; WaitRandomConnection2(CancellationToken token)
            {
                MemberConnection c = null;
                while (!token.IsCancellationRequested &amp;&amp;
                       ((c = _clusterMembers.GetRandomConnection()) == null || !c.Active))
                {
                    lock (_mutex) _connectionOpened = new TaskCompletionSource&lt;object&gt;();
                    using var reg = token.Register(() =&gt; _connectionOpened.TrySetCanceled());
                    await _connectionOpened.Task.CfAwait();
                    lock (_mutex) _connectionOpened = null;
                }
                return c;
            }

            // this will only exit once a connection is assigned, or the task is
            // cancelled, when the cluster goes down (and never up again)
            while (!cancellationToken.IsCancellationRequested)
            {
                connection ??= await WaitRandomConnection(cancellationToken).CfAwait();

                // try to subscribe, relying on the default invocation timeout,
                // so this is not going to last forever - we know it will end
                var correlationId = _clusterState.GetNextCorrelationId();
                if (!await SubscribeToClusterViewsAsync(connection, correlationId, cancellationToken).CfAwait()) // does not throw
                {
                    // failed =&gt; try another connection
                    connection = null;
                    continue;
                }

                // success!
                lock (_clusterViewsMutex)
                {
                    if (connection.Active)
                    {
                        _clusterViewsConnection = connection;
                        _clusterViewsCorrelationId = correlationId;
                        _clusterViewsTask = null;
                        HConsole.WriteLine(this, $&quot;ClusterViews: connection {connection.Id.ToShortString()} [{correlationId}]&quot;);
                        break;
                    }
                }

                // if the connection was not active anymore, we have rejected it
                // if the connection was active, and we have accepted it, and it de-activates,
                // then ClearClusterViewsConnection will deal with it
            }
        }

        /// &lt;summary&gt;
        /// Subscribes a connection to the cluster view event.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;connection&quot;&gt;The connection.&lt;/param&gt;
        /// &lt;param name=&quot;correlationId&quot;&gt;The correlation identifier.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;A cancellation token.&lt;/param&gt;
        /// &lt;returns&gt;A task that will complete when the subscription has been processed, and represent whether it was successful.&lt;/returns&gt;
        private async Task&lt;bool&gt; SubscribeToClusterViewsAsync(MemberConnection connection, long correlationId, CancellationToken cancellationToken)
        {
            // aka subscribe to member/partition view events
            HConsole.TraceLine(this, &quot;subscribe&quot;);

            // handles the event
            ValueTask HandleEventAsync(ClientMessage message, object _)
                =&gt; ClientAddClusterViewListenerCodec.HandleEventAsync(message,
                    HandleCodecMemberViewEvent,
                    HandleCodecPartitionViewEvent,
                    connection.Id,
                    _clusterState.LoggerFactory);

            try
            {
                var subscribeRequest = ClientAddClusterViewListenerCodec.EncodeRequest();
                _correlatedSubscriptions[correlationId] = new ClusterSubscription(HandleEventAsync);
                _ = await _clusterMessaging.SendToMemberAsync(subscribeRequest, connection, correlationId, cancellationToken).CfAwait();
                HConsole.WriteLine(this, &quot;Subscribed to cluster views&quot;);
                return true;
            }
            catch (Exception e)
            {
                HConsole.WriteLine(this, &quot;failed &quot; + e);
                _correlatedSubscriptions.TryRemove(correlationId, out _);
                _logger.LogWarning(e, &quot;Failed to subscribe to cluster events, may retry.&quot;);
                return false;
            }
        }

        /// &lt;summary&gt;
        /// Handles the &#39;members view&#39; event.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;version&quot;&gt;The version.&lt;/param&gt;
        /// &lt;param name=&quot;members&quot;&gt;The members.&lt;/param&gt;
        /// &lt;param name=&quot;state&quot;&gt;A state object.&lt;/param&gt;
        private async ValueTask HandleCodecMemberViewEvent(int version, ICollection&lt;MemberInfo&gt; members, object state)
        {
            var eventArgs = _clusterMembers.SetMembers(version, members);

            // nothing to do if members have been skipped (due to version)
            if (eventArgs == null) return;

            // raise events (On... does not throw)
            await _membersUpdated.AwaitEach(eventArgs).CfAwait();
        }

        /// &lt;summary&gt;
        /// Handles the &#39;partitions view&#39; event.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;version&quot;&gt;The version.&lt;/param&gt;
        /// &lt;param name=&quot;partitions&quot;&gt;The partitions.&lt;/param&gt;
        /// &lt;param name=&quot;state&quot;&gt;A state object.&lt;/param&gt;
        private async ValueTask HandleCodecPartitionViewEvent(int version, IList&lt;KeyValuePair&lt;Guid, IList&lt;int&gt;&gt;&gt; partitions, object state)
        {
            var clientId = (Guid) state;

            var updated = _clusterState.Partitioner.NotifyPartitionView(clientId, version, MapPartitions(partitions));
            if (!updated) return;

            // signal once
            //if (Interlocked.CompareExchange(ref _firstPartitionsViewed, 1, 0) == 0)
            //    _firstPartitionsView.Release();

            // raise event
            // On... does not throw
            await _partitionsUpdated.AwaitEach().CfAwait();
        }

        /// &lt;summary&gt;
        /// Maps partitions from the event representation to our internal representation.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;partitions&quot;&gt;The event representation of partitions.&lt;/param&gt;
        /// &lt;returns&gt;Our internal representation of partitions.&lt;/returns&gt;
        private static Dictionary&lt;int, Guid&gt; MapPartitions(IEnumerable&lt;KeyValuePair&lt;Guid, IList&lt;int&gt;&gt;&gt; partitions)
        {
            var map = new Dictionary&lt;int, Guid&gt;();
            foreach (var (memberId, partitionIds) in partitions)
            foreach (var partitionId in partitionIds)
                map[partitionId] = memberId;
            return map;
        }

        #endregion

        #region Collect Ghosts

        // add all member subscriptions of a cluster subscription to be collected, start the collect task if needed
        private void CollectSubscription(ClusterSubscription subscription)
        {
            lock (_collectMutex)
            {
                foreach (var memberSubscription in subscription)
                    _collectSubscriptions.Add(memberSubscription);
                _collectTask ??= CollectSubscriptionsAsync(_cancel.Token);
            }
        }

        // add a member subscription to be collected, start the collect task if needed
        private void CollectSubscription(MemberSubscription subscription)
        {
            lock (_collectMutex)
            {
                _collectSubscriptions.Add(subscription);
                _collectTask ??= CollectSubscriptionsAsync(_cancel.Token);
            }
        }

        // body of the subscription collection task
        private async Task CollectSubscriptionsAsync(CancellationToken cancellationToken)
        {
            List&lt;MemberSubscription&gt; removedSubscriptions = null;

            HConsole.WriteLine(this, &quot;CollectSubscription starting&quot;);

            // if canceled, will be awaited properly
            await Task.Delay(_clusterState.Options.Events.SubscriptionCollectDelay, cancellationToken).CfAwait();

            while (!cancellationToken.IsCancellationRequested)
            {
                // capture subscriptions to collect
                List&lt;MemberSubscription&gt; subscriptions;
                lock (_collectMutex)
                {
                    subscriptions = _collectSubscriptions.ToList();
                }

                HConsole.WriteLine(this, $&quot;CollectSubscription loop for {subscriptions.Count} member subscriptions&quot;);

                // try to remove captured subscriptions
                // if canceled, will be awaited properly
                removedSubscriptions?.Clear();
                var timeLimit = DateTime.Now - _clusterState.Options.Events.SubscriptionCollectTimeout;
                foreach (var subscription in subscriptions)
                {
                    HConsole.WriteLine(this, &quot;CollectSubscription collects&quot;);

                    try
                    {
                        var removed = await RemoveSubscriptionAsync(subscription, cancellationToken).CfAwait();
                        if (removed || subscription.ClusterSubscription.DeactivateTime &lt; timeLimit)
                        {
                            subscription.ClusterSubscription.Remove(subscription);
                            (removedSubscriptions ??= new List&lt;MemberSubscription&gt;()).Add(subscription);
                        }
                    }
                    catch (OperationCanceledException)
                    {
                        return; // cancelled - stop everything
                    }
                    catch (Exception e)
                    {
                        _logger.LogError(e, &quot;An error occurred while collecting subscriptions.&quot;);
                    }
                }

                HConsole.WriteLine(this, $&quot;CollectSubscription collected {removedSubscriptions?.Count ?? 0} subscriptions&quot;);

                // update subscriptions to collect
                // none remaining = exit the task
                lock (_collectMutex)
                {
                    if (removedSubscriptions != null)
                    {
                        foreach (var subscription in removedSubscriptions)
                            _collectSubscriptions.Remove(subscription);
                    }

                    if (_collectSubscriptions.Count == 0)
                    {
                        HConsole.WriteLine(this, &quot;CollectSubscription exits&quot;);
                        _collectTask = null;
                        return;
                    }
                }

                HConsole.WriteLine(this, &quot;CollectSubscription waits&quot;);

                // else, wait + loop / try again
                // if canceled, will be awaited properly
                await Task.Delay(_clusterState.Options.Events.SubscriptionCollectPeriod, cancellationToken).CfAwait();
            }
        }

        #endregion

        #region Events

        /// &lt;summary&gt;
        /// Gets or sets an action that will be executed when members have been updated.
        /// &lt;/summary&gt;
        public Func&lt;MembersUpdatedEventArgs, ValueTask&gt; MembersUpdated
        {
            get =&gt; _membersUpdated;
            set
            {
                _clusterState.ThrowIfPropertiesAreReadOnly();
                _membersUpdated = value;
            }
        }

        /// &lt;summary&gt;
        /// Gets or sets an action that will be executed when partitions have been updated.
        /// &lt;/summary&gt;
        public Func&lt;ValueTask&gt; PartitionsUpdated
        {
            get =&gt; _partitionsUpdated;
            set
            {
                _clusterState.ThrowIfPropertiesAreReadOnly();
                _partitionsUpdated = value;
            }
        }

        #endregion

        #region Event Handlers

        /// &lt;summary&gt;
        /// Handles a connection being created.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;connection&quot;&gt;&lt;/param&gt;
        public void OnConnectionCreated(MemberConnection connection)
        {
            // wires reception of event messages
            connection.ReceivedEvent += OnReceivedEvent;
        }

        /// &lt;summary&gt;
        /// Handles a connection being opened.
        /// &lt;/summary&gt;
#pragma warning disable IDE0060 // Remove unused parameters
#pragma warning disable CA1801 // Review unused parameters
        // unused parameters are required, this is an event handler
        public ValueTask OnConnectionOpened(MemberConnection connection, bool isFirstEver, bool isFirst, bool isNewCluster)
#pragma warning restore CA1801
#pragma warning restore IDE0060
        {
            // atomically add the connection and capture known subscriptions
            List&lt;ClusterSubscription&gt; subscriptions;
            lock (_mutex)
            {
                _connections.Add(connection);
                subscriptions = _subscriptions.Values.ToList();
                _connectionOpened?.TrySetResult(null);
            }

            // in case we don&#39;t have one already...
            ProposeClusterViewsConnection(connection);

            // for this new connection... we need to add all known subscriptions to it, and this is
            // going to happen in the background - yes, it means that the connection could be used
            // even before all subscriptions have been added and thus some events may fail to trigger,
            // we don&#39;t offer any strict guarantee on events anyways

            lock (_subscribeTasksMutex)
            {
                if (_subscribeTasks != null)
                    _subscribeTasks[connection] = AddSubscriptionsAsync(connection, subscriptions, _cancel.Token);
            }

            return default;
        }

        /// &lt;summary&gt;
        /// Handles a connection being closed.
        /// &lt;/summary&gt;
        public ValueTask OnConnectionClosed(MemberConnection connection)
        {
            // atomically remove the connection and capture known subscriptions
            List&lt;ClusterSubscription&gt; subscriptions;
            lock (_mutex)
            {
                _connections.Remove(connection);
                subscriptions = _subscriptions.Values.ToList();
            }

            // just clear subscriptions,
            // cannot unsubscribes from the server since the client is not connected anymore
            ClearMemberSubscriptions(subscriptions, connection);

            // clear, if that was the cluster views connection,
            // and then start the task to assign another one)
            ClearClusterViewsConnection(connection);

            return default;
        }

        /// &lt;summary&gt;
        /// Handles an event message.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;message&quot;&gt;The event message.&lt;/param&gt;
        public void OnReceivedEvent(ClientMessage message)
        {
            HConsole.WriteLine(this, &quot;Handle event message&quot;);

            // get the matching subscription
            if (!_correlatedSubscriptions.TryGetValue(message.CorrelationId, out var subscription))
            {
                _clusterState.Instrumentation.CountMissedEvent(message);
                _logger.LogWarning($&quot;No event handler for [{message.CorrelationId}]&quot;);
                HConsole.WriteLine(this, $&quot;No event handler for [{message.CorrelationId}]&quot;);
                return;
            }

            // schedule the event - will run async, but sequentially per-partition
            // (queues the event, returns immediately, does not await on handlers)
            _scheduler.Add(subscription, message);
        }

        #endregion

        /// &lt;inheritdoc /&gt;
        public async ValueTask DisposeAsync()
        {
            if (Interlocked.CompareExchange(ref _disposed, 1, 0) == 1)
                return;

            HConsole.WriteLine(this, &quot;Dispose scheduler.&quot;);
            await _scheduler.DisposeAsync().CfAwait();
            HConsole.WriteLine(this, &quot;Dispose subscriptions.&quot;);
            await _objectLifecycleEventSubscription.DisposeAsync().CfAwait();
            await _partitionLostEventSubscription.DisposeAsync().CfAwait();

            _cancel.Cancel();

            HConsole.WriteLine(this, &quot;Await cluster views task.&quot;);
            await _clusterViewsTask.MaybeNull().CfAwaitCanceled();
            HConsole.WriteLine(this, &quot;Dispose collect task.&quot;);
            await _collectTask.MaybeNull().CfAwaitCanceled();

            HConsole.WriteLine(this, &quot;Await subscribe tasks.&quot;);
            Task[] tasks;
            lock (_subscribeTasksMutex)
            {
                tasks = _subscribeTasks.Values.ToArray();
                _subscribeTasks = null;
            }
            await Task.WhenAll(tasks).CfAwait();

            _cancel.Dispose();

            // connection is going down
            // it will be disposed as well as all other connections
            // and subscriptions will terminate
            _clusterViewsConnection = null;

            HConsole.WriteLine(this, &quot;Down.&quot;);
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[44,9,44,90,1],[45,9,45,55,1],[50,9,50,67,1],[58,9,58,99,1],[63,9,63,145,1],[66,9,66,69,1],[67,9,67,111,1],[72,9,72,155,1],[76,9,76,112,1],[77,9,77,62,1],[83,9,83,10,1],[85,9,85,165,1],[87,13,87,42,1],[88,13,88,50,1],[89,13,89,46,1],[91,13,91,81,1],[92,13,92,85,1],[93,13,93,58,1],[95,13,97,41,1],[97,41,97,71,1],[97,71,98,43,1],[98,43,98,75,1],[98,75,99,15,1],[101,13,103,41,1],[103,41,103,71,0],[103,71,104,15,1],[105,9,105,10,1],[110,83,110,97,1],[115,93,115,117,1],[120,70,120,91,1],[203,13,203,38,1],[203,39,203,93,0],[207,13,207,26,1],[210,17,210,53,1],[213,17,213,75,1],[214,21,214,116,0],[215,13,215,14,1],[219,22,219,36,1],[219,37,219,39,1],[219,40,219,51,1],[221,17,221,63,1],[223,21,223,55,0],[224,21,224,70,0],[228,17,228,113,1],[230,17,230,39,1],[238,25,238,112,0],[241,25,241,59,0],[242,25,242,126,0],[245,25,245,59,0],[248,9,248,10,1],[255,13,255,36,1],[255,37,255,92,0],[258,13,258,70,1],[259,13,259,68,1],[263,13,263,107,1],[269,17,269,144,1],[270,13,270,14,1],[271,13,271,32,0],[273,17,273,74,0],[274,17,276,71,0],[281,13,281,98,1],[282,13,282,83,1],[283,13,283,23,1],[283,24,283,53,1],[286,13,286,70,0],[287,13,287,53,0],[288,13,288,70,0],[289,9,289,10,1],[296,22,296,38,1],[296,39,296,41,1],[296,42,296,55,1],[298,17,298,63,1],[298,64,298,71,0],[301,17,301,113,1],[303,17,303,39,1],[315,25,315,63,0],[324,13,324,40,1],[324,41,324,76,1],[325,9,325,10,1],[341,13,341,26,1],[343,17,343,81,1],[344,21,344,34,1],[345,13,345,14,1],[347,13,347,86,1],[348,13,348,25,1],[349,9,349,10,1],[355,13,355,39,1],[358,22,358,44,1],[358,45,358,47,1],[358,48,358,60,1],[363,17,363,93,1],[367,17,367,100,1],[368,21,368,61,1],[370,21,370,61,1],[371,13,371,14,1],[372,9,372,10,1],[378,13,378,49,1],[378,50,378,62,0],[385,17,385,135,1],[386,17,386,155,1],[387,17,387,105,1],[388,17,388,32,1],[390,13,390,32,1],[393,17,393,53,1],[393,54,393,66,0],[396,17,396,91,1],[397,17,397,30,1],[399,9,399,10,1],[405,22,405,38,1],[405,39,405,41,1],[405,42,405,55,1],[409,17,409,84,1],[410,21,410,97,1],[412,9,412,10,1],[431,13,431,38,1],[434,17,434,59,1],[435,21,435,28,1],[438,17,438,48,1],[439,17,439,87,1],[440,17,440,48,1],[445,17,445,94,1],[446,13,446,14,1],[447,9,447,10,1],[459,13,459,38,1],[461,17,461,53,1],[462,21,462,104,1],[463,13,463,14,1],[464,9,464,10,1],[478,17,478,63,1],[479,17,481,58,1],[486,17,486,43,1],[487,17,488,91,1],[490,21,490,34,1],[490,35,490,90,1],[491,21,491,58,1],[491,58,491,92,0],[491,92,491,94,1],[492,21,492,60,1],[493,21,493,34,1],[493,35,493,60,1],[494,17,494,18,1],[495,17,495,26,1],[496,13,496,14,1],[500,13,500,63,1],[502,17,502,88,1],[506,17,506,74,1],[507,17,507,113,1],[510,21,510,39,1],[511,21,511,30,1],[515,17,515,42,1],[517,21,517,43,1],[519,25,519,62,1],[520,25,520,68,1],[521,25,521,50,1],[523,25,523,31,1],[525,17,525,18,0],[531,9,531,10,1],[547,20,551,49,1],[555,17,555,90,1],[556,17,556,101,1],[557,17,557,137,1],[559,17,559,29,1],[561,13,561,32,1],[564,17,564,74,1],[565,17,565,92,1],[566,17,566,30,1],[568,9,568,10,1],[578,13,578,74,1],[581,13,581,35,1],[581,36,581,43,0],[584,13,584,66,1],[585,9,585,10,1],[595,13,595,41,1],[597,13,597,119,1],[598,13,598,26,1],[598,27,598,34,1],[606,13,606,60,1],[607,9,607,10,1],[616,13,616,51,1],[617,22,617,50,1],[617,51,617,53,1],[617,54,617,64,1],[618,22,618,37,1],[618,38,618,40,1],[618,41,618,53,1],[619,17,619,45,1],[620,13,620,24,1],[630,13,630,33,0],[632,26,632,48,0],[632,49,632,51,0],[632,52,632,64,0],[633,21,633,67,0],[634,17,634,75,0],[635,13,635,14,0],[636,9,636,10,0],[641,13,641,33,1],[643,17,643,57,1],[644,17,644,75,1],[645,13,645,14,1],[646,9,646,10,1],[651,13,651,66,1],[656,13,656,114,1],[658,13,658,63,1],[662,17,662,37,1],[664,21,664,68,1],[665,17,665,18,1],[671,17,671,47,1],[672,17,672,104,1],[673,26,673,42,1],[673,43,673,45,1],[673,46,673,59,1],[679,25,679,112,1],[680,25,680,100,1],[682,29,682,83,1],[683,29,683,105,1],[685,21,685,22,1],[686,21,686,55,0],[688,25,688,32,0],[690,21,690,40,0],[692,25,692,98,0],[693,21,693,22,0],[694,17,694,18,1],[700,17,700,37,1],[702,21,702,54,1],[704,34,704,50,1],[704,51,704,53,1],[704,54,704,74,1],[705,29,705,72,1],[708,21,708,58,1],[711,25,711,45,1],[712,25,712,32,1],[714,17,714,18,0],[720,17,720,119,0],[722,9,722,10,1],[733,20,733,35,1],[736,17,736,62,1],[737,17,737,41,1],[738,13,738,14,1],[746,20,746,38,1],[749,17,749,62,1],[750,17,750,44,1],[751,13,751,14,1],[765,13,765,57,1],[766,9,766,10,1],[780,13,780,26,1],[782,17,782,46,1],[783,17,783,64,1],[784,17,784,55,1],[785,13,785,14,1],[788,13,788,55,1],[795,13,795,40,1],[797,17,797,45,1],[798,21,798,115,1],[799,13,799,14,1],[801,13,801,28,1],[811,13,811,26,1],[813,17,813,49,1],[814,17,814,64,1],[815,13,815,14,1],[819,13,819,65,1],[823,13,823,53,1],[825,13,825,28,1],[837,13,837,100,1],[839,17,839,73,0],[840,17,840,87,0],[842,17,842,24,0],[847,13,847,51,1],[848,9,848,10,1],[855,13,855,71,1],[856,17,856,24,0],[859,13,859,55,1],[861,13,861,78,1],[862,13,862,76,1],[864,13,864,30,1],[867,13,867,67,1],[869,13,869,62,1],[873,13,873,40,1],[875,17,875,58,1],[876,17,876,40,1],[877,13,877,14,1],[878,13,878,49,1],[880,13,880,31,1],[885,13,885,44,1],[888,9,888,10,1]]);
    </script>
  </body>
</html>