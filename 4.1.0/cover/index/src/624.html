<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Core\TaskCoreExtensions.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#nullable enable

using System;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Hazelcast.Exceptions;

namespace Hazelcast.Core
{
    /// &lt;summary&gt;
    /// Provides extension method to the &lt;see cref=&quot;Task&quot;/&gt; and &lt;see cref=&quot;Task{TResult}&quot;/&gt; classes,
    /// and the &lt;see cref=&quot;ValueTask&quot;/&gt; and &lt;see cref=&quot;ValueTask{TResult}&quot;/&gt; structs.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// &lt;para&gt;See: https://devblogs.microsoft.com/dotnet/configureawait-faq/.&lt;/para&gt;
    /// &lt;/remarks&gt;
    internal static class TaskCoreExtensions
    {
        // NOTES
        //
        // in this class, we trust our code that [NotNull] arguments will not be null,
        // and do *not* check arguments for null.

        /// &lt;summary&gt;
        /// Gets this task if it is not &lt;c&gt;null&lt;/c&gt;, or a completed task.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;task&quot;&gt;The task.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;paramref name=&quot;task&quot;/&gt; if it is not &lt;c&gt;null&lt;/c&gt;; otherwise &lt;c&gt;Task.CompletedTask&lt;/c&gt;.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;Use this method to await a task that may be &lt;c&gt;null&lt;/c&gt;.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public static Task MaybeNull(this Task? task)
            =&gt; task ?? Task.CompletedTask;

        /// &lt;summary&gt;
        /// Configures an awaiter used to await this &lt;see cref=&quot;Task&quot;/&gt;, continuing on
        /// any synchronization context.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;task&quot;&gt;The task.&lt;/param&gt;
        /// &lt;returns&gt;An object used to await this &lt;see cref=&quot;Task&quot;/&gt;.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;This is equivalent to &lt;c&gt;ConfigureAwait(false)&lt;/c&gt;.&lt;/para&gt;
        /// &lt;/remarks&gt;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ConfiguredTaskAwaitable CfAwait([NotNull] this Task task)
            =&gt; task.ConfigureAwait(false);

        /// &lt;summary&gt;
        /// Configures an awaiter used to await this &lt;see cref=&quot;Task{TResult}&quot;/&gt;, continuing on
        /// any synchronization context.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;task&quot;&gt;The task.&lt;/param&gt;
        /// &lt;returns&gt;An object used to await this &lt;see cref=&quot;Task{TResult}&quot;/&gt;.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;This is equivalent to &lt;c&gt;ConfigureAwait(false)&lt;/c&gt;.&lt;/para&gt;
        /// &lt;/remarks&gt;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ConfiguredTaskAwaitable&lt;T&gt; CfAwait&lt;T&gt;([NotNull] this Task&lt;T&gt; task)
            =&gt; task.ConfigureAwait(false);

        /// &lt;summary&gt;
        /// Configures an awaiter used to await this &lt;see cref=&quot;ValueTask&quot;/&gt;, continuing on
        /// any synchronization context.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;task&quot;&gt;The task.&lt;/param&gt;
        /// &lt;returns&gt;An object used to await this &lt;see cref=&quot;ValueTask&quot;/&gt;.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;This is equivalent to &lt;c&gt;ConfigureAwait(false)&lt;/c&gt;.&lt;/para&gt;
        /// &lt;/remarks&gt;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ConfiguredValueTaskAwaitable CfAwait(this ValueTask task)
            =&gt; task.ConfigureAwait(false);

        /// &lt;summary&gt;
        /// Configures an awaiter used to await this &lt;see cref=&quot;ValueTask{TResult}&quot;/&gt;, continuing on
        /// any synchronization context.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;task&quot;&gt;The task.&lt;/param&gt;
        /// &lt;returns&gt;An object used to await this &lt;see cref=&quot;ValueTask{TResult}&quot;/&gt;.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;This is equivalent to &lt;c&gt;ConfigureAwait(false)&lt;/c&gt;.&lt;/para&gt;
        /// &lt;/remarks&gt;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ConfiguredValueTaskAwaitable&lt;T&gt; CfAwait&lt;T&gt;(this ValueTask&lt;T&gt; task)
            =&gt; task.ConfigureAwait(false);

        /// &lt;summary&gt;
        /// Configures an awaiter used to await this &lt;see cref=&quot;Task&quot;/&gt;, continuing on
        /// any synchronization context, and not throwing any exception.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;task&quot;&gt;The task.&lt;/param&gt;
        /// &lt;returns&gt;An object used to await this &lt;see cref=&quot;Task&quot;/&gt;.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;This is equivalent to &lt;c&gt;ConfigureAwait(false)&lt;/c&gt;, and in addition
        /// any exception thrown by the task is swallowed and observed (in order not
        /// to become an unobserved exception).&lt;/para&gt;
        /// &lt;/remarks&gt;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ConfiguredTaskNoThrowAwaitable CfAwaitNoThrow([NotNull] this Task task)
            =&gt; new ConfiguredTaskNoThrowAwaitable(task);

        /// &lt;summary&gt;
        /// Configures an awaiter used to await this &lt;see cref=&quot;ValueTask&quot;/&gt;, continuing on
        /// any synchronization context, and not throwing any exception.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;task&quot;&gt;The task.&lt;/param&gt;
        /// &lt;returns&gt;An object used to await this &lt;see cref=&quot;ValueTask&quot;/&gt;.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;This is equivalent to &lt;c&gt;ConfigureAwait(false)&lt;/c&gt;, and in addition
        /// any exception thrown by the task is swallowed and observed (in order not
        /// to become an unobserved exception).&lt;/para&gt;
        /// &lt;/remarks&gt;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ConfiguredValueTaskNoThrowAwaitable CfAwaitNoThrow(this ValueTask task)
            =&gt; new ConfiguredValueTaskNoThrowAwaitable(task);

        /// &lt;summary&gt;
        /// Configures an awaiter used to await this &lt;see cref=&quot;Task&quot;/&gt;, continuing on
        /// any synchronization context, and not throwing an exception if the task is
        /// canceled.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;task&quot;&gt;The task.&lt;/param&gt;
        /// &lt;returns&gt;An object used to await this &lt;see cref=&quot;Task&quot;/&gt;.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;This is equivalent to &lt;c&gt;ConfigureAwait(false)&lt;/c&gt;, and in addition
        /// any cancelled exception thrown by the task is swallowed and observed (in order not
        /// to become an unobserved exception). Other exceptions are thrown.&lt;/para&gt;
        /// &lt;/remarks&gt;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ConfiguredTaskNoThrowCanceledAwaitable CfAwaitCanceled([NotNull] this Task task)
            =&gt; new ConfiguredTaskNoThrowCanceledAwaitable(task);

        /// &lt;summary&gt;
        /// Configures an awaiter used to await this &lt;see cref=&quot;Task&quot;/&gt;, no longer than the
        /// specified &lt;paramref name=&quot;timeout&quot;/&gt;, and continuing on any synchronization context.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;task&quot;&gt;The task.&lt;/param&gt;
        /// &lt;param name=&quot;timeout&quot;&gt;The timeout.&lt;/param&gt;
        /// &lt;param name=&quot;cancellation&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;An object used to await this &lt;see cref=&quot;Task&quot;/&gt;.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;This is equivalent to &lt;c&gt;ConfigureAwait(false)&lt;/c&gt;, and in addition
        /// it throws a &lt;see cref=&quot;TaskTimeoutException&quot;/&gt; if the task runs longer than the
        /// specified &lt;paramref name=&quot;timeout&quot;/&gt;.&lt;/para&gt;
        /// &lt;para&gt;In this case, it is only the &lt;c&gt;await&lt;/c&gt; that is aborted: the original
        /// &lt;paramref name=&quot;task&quot;/&gt; keeps running in the background. However, if a
        /// &lt;paramref name=&quot;cancellation&quot;/&gt; source is provided, it is canceled, thus giving
        /// an opportunity to the task to cancel its operations in the background.&lt;/para&gt;
        /// &lt;para&gt;In case of a timeout, exceptions throw by the &lt;paramref name=&quot;task&quot;/&gt; are
        /// observed, i.e. they will not come out as unobserved exceptions.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public static ConfiguredTaskAwaitable CfAwait(this Task task, TimeSpan timeout, CancellationTokenSource? cancellation = null)
            =&gt; AwaitWithTimeout(task, timeout.RoundedMilliseconds().ClampToInt32(), cancellation).ConfigureAwait(false);

        /// &lt;summary&gt;
        /// Configures an awaiter used to await this &lt;see cref=&quot;Task&quot;/&gt;, continuing on
        /// any synchronization context, until a timeout is reached.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;task&quot;&gt;The task.&lt;/param&gt;
        /// &lt;param name=&quot;timeoutMilliseconds&quot;&gt;The timeout.&lt;/param&gt;
        /// &lt;param name=&quot;cancellation&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;An object used to await this &lt;see cref=&quot;Task&quot;/&gt;.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;This is equivalent to &lt;c&gt;ConfigureAwait(false)&lt;/c&gt;, and in addition
        /// it throws a &lt;see cref=&quot;TaskTimeoutException&quot;/&gt; if the task runs longer than the
        /// specified &lt;paramref name=&quot;timeoutMilliseconds&quot;/&gt;.&lt;/para&gt;
        /// &lt;para&gt;In this case, it is only the &lt;c&gt;await&lt;/c&gt; that is aborted: the original
        /// &lt;paramref name=&quot;task&quot;/&gt; keeps running in the background. However, if a
        /// &lt;paramref name=&quot;cancellation&quot;/&gt; source is provided, it is canceled, thus giving
        /// an opportunity to the task to cancel its operations in the background.&lt;/para&gt;
        /// &lt;para&gt;In case of a timeout, exceptions throw by the &lt;paramref name=&quot;task&quot;/&gt; are
        /// observed, i.e. they will not come out as unobserved exceptions.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public static ConfiguredTaskAwaitable CfAwait(this Task task, int timeoutMilliseconds, CancellationTokenSource? cancellation = null)
            =&gt; AwaitWithTimeout(task, timeoutMilliseconds, cancellation).ConfigureAwait(false);

        /// &lt;summary&gt;
        /// Configures an awaiter used to await this &lt;see cref=&quot;Task{TResult}&quot;/&gt;, continuing on
        /// any synchronization context, until a timeout is reached.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;task&quot;&gt;The task.&lt;/param&gt;
        /// &lt;param name=&quot;timeout&quot;&gt;The timeout.&lt;/param&gt;
        /// &lt;param name=&quot;cancellation&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;An object used to await this &lt;see cref=&quot;Task{TResult}&quot;/&gt;.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;This is equivalent to &lt;c&gt;ConfigureAwait(false)&lt;/c&gt;, and in addition
        /// it throws a &lt;see cref=&quot;TaskTimeoutException&quot;/&gt; if the task runs longer than the
        /// specified &lt;paramref name=&quot;timeout&quot;/&gt;.&lt;/para&gt;
        /// &lt;para&gt;In this case, it is only the &lt;c&gt;await&lt;/c&gt; that is aborted: the original
        /// &lt;paramref name=&quot;task&quot;/&gt; keeps running in the background. However, if a
        /// &lt;paramref name=&quot;cancellation&quot;/&gt; source is provided, it is canceled, thus giving
        /// an opportunity to the task to cancel its operations in the background.&lt;/para&gt;
        /// &lt;para&gt;In case of a timeout, exceptions throw by the &lt;paramref name=&quot;task&quot;/&gt; are
        /// observed, i.e. they will not come out as unobserved exceptions.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public static ConfiguredTaskAwaitable&lt;TResult&gt; CfAwait&lt;TResult&gt;(this Task&lt;TResult&gt; task, TimeSpan timeout, CancellationTokenSource? cancellation = null)
            =&gt; AwaitWithTimeout(task, timeout.RoundedMilliseconds().ClampToInt32(), cancellation).ConfigureAwait(false);

        /// &lt;summary&gt;
        /// Configures an awaiter used to await this &lt;see cref=&quot;Task{TResult}&quot;/&gt;, continuing on
        /// any synchronization context, until a timeout is reached.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;task&quot;&gt;The task.&lt;/param&gt;
        /// &lt;param name=&quot;timeoutMilliseconds&quot;&gt;The timeout.&lt;/param&gt;
        /// &lt;param name=&quot;cancellation&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;An object used to await this &lt;see cref=&quot;Task{TResult}&quot;/&gt;.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;This is equivalent to &lt;c&gt;ConfigureAwait(false)&lt;/c&gt;, and in addition
        /// it throws a &lt;see cref=&quot;TaskTimeoutException&quot;/&gt; if the task runs longer than the
        /// specified &lt;paramref name=&quot;timeoutMilliseconds&quot;/&gt;.&lt;/para&gt;
        /// &lt;para&gt;In this case, it is only the &lt;c&gt;await&lt;/c&gt; that is aborted: the original
        /// &lt;paramref name=&quot;task&quot;/&gt; keeps running in the background. However, if a
        /// &lt;paramref name=&quot;cancellation&quot;/&gt; source is provided, it is canceled, thus giving
        /// an opportunity to the task to cancel its operations in the background.&lt;/para&gt;
        /// &lt;para&gt;In case of a timeout, exceptions throw by the &lt;paramref name=&quot;task&quot;/&gt; are
        /// observed, i.e. they will not come out as unobserved exceptions.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public static ConfiguredTaskAwaitable&lt;TResult&gt; CfAwait&lt;TResult&gt;(this Task&lt;TResult&gt; task, int timeoutMilliseconds, CancellationTokenSource? cancellation = null)
            =&gt; AwaitWithTimeout(task, timeoutMilliseconds, cancellation).ConfigureAwait(false);

        private static async Task AwaitWithTimeout(Task task, int timeoutMilliseconds, CancellationTokenSource? cancellation)
        {
            if (timeoutMilliseconds &lt; 0)
            {
                await task.ConfigureAwait(false);
                return;
            }

            using var delayCancel = new CancellationTokenSource();
            var delay = Task.Delay(timeoutMilliseconds, delayCancel.Token);

            await Task.WhenAny(task, delay).ConfigureAwait(false);

            // if the delay is not completed, cancel it &amp; observe the corresponding exception
            if (!delay.IsCompleted)
            {
                delayCancel.Cancel(); // task cancellation are never unobserved
            }

            // if the task is completed (success or fault...), return
            if (task.IsCompleted)
            {
                await task.CfAwait();
                return;
            }

            // signal the task it should cancel
            cancellation?.Cancel();

            // task cancellation are never unobserved
            // OTOH the task *could* throw another exception
            // and... most people will probably ignore them or forget to pay
            // attention, so it feels safer to observe these exceptions
            task.ObserveException();

            // else timeout
            throw new TaskTimeoutException(ExceptionMessages.Timeout, task);
        }

        private static async Task&lt;TResult&gt; AwaitWithTimeout&lt;TResult&gt;(Task&lt;TResult&gt; task, int timeoutMilliseconds, CancellationTokenSource? cancellation)
        {
            if (timeoutMilliseconds &lt; 0)
            {
                return await task.ConfigureAwait(false);
            }

            using var delayCancel = new CancellationTokenSource();
            var delay = Task.Delay(timeoutMilliseconds, delayCancel.Token);

            await Task.WhenAny(task, delay).ConfigureAwait(false);

            // if the delay is not completed, cancel it &amp; observe the corresponding exception
            if (!delay.IsCompleted)
            {
                delayCancel.Cancel(); // task cancellation are never unobserved
            }

            // if the task is completed (success or fault...), return
            if (task.IsCompleted)
            {
                return await task.CfAwait();
            }

            // signal the task it should cancel
            cancellation?.Cancel();

            // task cancellation are never unobserved
            // OTOH the task *could* throw another exception
            // and... most people will probably ignore them or forget to pay
            // attention, so it feels safer to observe these exceptions
            task.ObserveException();

            // else timeout
            throw new TaskTimeoutException(ExceptionMessages.Timeout, task);
        }

        /// &lt;summary&gt;
        /// Observes the exception of this &lt;see cref=&quot;Task&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;task&quot;&gt;The task.&lt;/param&gt;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ObserveException([NotNull] this Task task)
#pragma warning disable CS4014 // Because this call is not awaited...
#pragma warning disable CA2012 // Use ValueTasks correctly - no we don&#39;t
            =&gt; ObserveExceptionInternal(task);
#pragma warning restore CS4014
#pragma warning restore CA2012

        // this indirect method will end up inlined, and exists only to
        // prevent CS4014 to pop on the code calling ObserveException
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static async ValueTask ObserveExceptionInternal([NotNull] Task task)
            =&gt; await new ConfiguredTaskNoThrowAwaitable(task);

        /// &lt;summary&gt;
        /// Provides an awaitable object that allows for configured awaits on &lt;see cref=&quot;Task&quot;/&gt;.
        /// &lt;/summary&gt;
        public readonly struct ConfiguredTaskNoThrowAwaitable : ICriticalNotifyCompletion
        {
            private readonly Task _task;

            /// &lt;summary&gt;
            /// Initializes a new instance of the &lt;see cref=&quot;ConfiguredTaskNoThrowAwaitable&quot;/&gt; struct.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;task&quot;&gt;The &lt;see cref=&quot;Task&quot;/&gt;.&lt;/param&gt;
            internal ConfiguredTaskNoThrowAwaitable([NotNull] Task task)
            {
                _task = task;
            }

            /// &lt;summary&gt;
            /// Gets the awaiter for this awaitable.
            /// &lt;/summary&gt;
            /// &lt;returns&gt;The awaiter.&lt;/returns&gt;
            public ConfiguredTaskNoThrowAwaitable GetAwaiter() =&gt; this;

            /// &lt;summary&gt;
            /// Gets whether the task being awaited is completed.
            /// &lt;/summary&gt;
            /// &lt;returns&gt;Whether the task being awaited is completed.&lt;/returns&gt;
            public bool IsCompleted
                =&gt; _task.IsCompleted;

            /// &lt;summary&gt;Ends the await on the completed &lt;see cref=&quot;Task&quot;/&gt;.&lt;/summary&gt;
            // [StackTraceHidden] is framework-internal
            public void GetResult()
            {
                // this is where we swallowed the task&#39;s possible exception
                // still, must observe the exception else it remains unobserved
                if (!_task.IsCompletedSuccessfully()) { _ = _task.Exception; }
            }

            // ConfiguredTaskAwaitable is a simple class that just returns a
            // ConfiguredTaskAwaitable.ConfiguredTaskAwaiter for GetAwaiter()
            //
            // That awaiter invokes the TaskAwaiter.OnCompletedInternal method
            // for OnCompleted and UnsafeOnCompleted - that is all - but that
            // method is internal, so the only way for us to invoke it is
            // through a ConfiguredTaskAwaiter - which only has an internal ctor,
            // so through a ConfiguredTaskAwaitable.
            //
            // so, the methods below use ConfigureAwait(false) to create the
            // correct ConfiguredTaskAwaitable.ConfiguredTaskAwaiter, and get
            // it to complete as expected.
            //
            // references:
            // https://github.com/dotnet/runtime/issues/22144
            // https://github.com/dotnet/runtime/issues/27723

            /// &lt;summary&gt;
            /// Schedules the continuation onto the &lt;see cref=&quot;Task&quot;/&gt; associated with this &lt;see cref=&quot;TaskAwaiter&quot;/&gt;.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;continuation&quot;&gt;The action to invoke when the await operation completes.&lt;/param&gt;
            public void OnCompleted(Action continuation)
                =&gt; _task.ConfigureAwait(false).GetAwaiter().OnCompleted(continuation);

            /// &lt;summary&gt;
            /// Schedules the continuation onto the &lt;see cref=&quot;Task&quot;/&gt; associated with this &lt;see cref=&quot;TaskAwaiter&quot;/&gt;.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;continuation&quot;&gt;The action to invoke when the await operation completes.&lt;/param&gt;
            public void UnsafeOnCompleted(Action continuation)
                =&gt; _task.ConfigureAwait(false).GetAwaiter().OnCompleted(continuation);
        }

        /// &lt;summary&gt;
        /// Provides an awaitable object that allows for configured awaits on &lt;see cref=&quot;ValueTask&quot;/&gt;.
        /// &lt;/summary&gt;
        public readonly struct ConfiguredValueTaskNoThrowAwaitable : ICriticalNotifyCompletion
        {
            private readonly ValueTask _task;

            /// &lt;summary&gt;
            /// Initializes a new instance of the &lt;see cref=&quot;ConfiguredValueTaskNoThrowAwaitable&quot;/&gt; struct.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;task&quot;&gt;The &lt;see cref=&quot;ValueTask&quot;/&gt;.&lt;/param&gt;
            internal ConfiguredValueTaskNoThrowAwaitable(ValueTask task)
            {
                _task = task;
            }

            /// &lt;summary&gt;
            /// Gets the awaiter for this awaitable.
            /// &lt;/summary&gt;
            /// &lt;returns&gt;The awaiter.&lt;/returns&gt;
            public ConfiguredValueTaskNoThrowAwaitable GetAwaiter() =&gt; this;

            /// &lt;summary&gt;
            /// Gets whether the task being awaited is completed.
            /// &lt;/summary&gt;
            /// &lt;returns&gt;Whether the task being awaited is completed.&lt;/returns&gt;
            public bool IsCompleted
                =&gt; _task.IsCompleted;

            /// &lt;summary&gt;Ends the await on the completed &lt;see cref=&quot;Task&quot;/&gt;.&lt;/summary&gt;
            // [StackTraceHidden] is framework-internal
            public void GetResult()
            {
                // this is where we swallowed the task&#39;s possible exception
                // still, must observe the exception else it remains unobserved

                // value tasks are different from tasks: they don&#39;t hold the
                // exception, if there&#39;s an exception then there has to be
                // an underlying task holding the exception

                if (!_task.IsCompletedSuccessfully) { _ = _task.AsTask().Exception; }
            }

            // see notes in ConfiguredTaskNoThrowAwaitable

            /// &lt;summary&gt;
            /// Schedules the continuation onto the &lt;see cref=&quot;Task&quot;/&gt; associated with this &lt;see cref=&quot;TaskAwaiter&quot;/&gt;.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;continuation&quot;&gt;The action to invoke when the await operation completes.&lt;/param&gt;
            public void OnCompleted(Action continuation)
                =&gt; _task.ConfigureAwait(false).GetAwaiter().OnCompleted(continuation);

            /// &lt;summary&gt;
            /// Schedules the continuation onto the &lt;see cref=&quot;Task&quot;/&gt; associated with this &lt;see cref=&quot;TaskAwaiter&quot;/&gt;.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;continuation&quot;&gt;The action to invoke when the await operation completes.&lt;/param&gt;
            public void UnsafeOnCompleted(Action continuation)
                =&gt; _task.ConfigureAwait(false).GetAwaiter().OnCompleted(continuation);
        }

        /// &lt;summary&gt;
        /// Provides an awaitable object that allows for configured awaits on &lt;see cref=&quot;Task&quot;/&gt;.
        /// &lt;/summary&gt;
        public readonly struct ConfiguredTaskNoThrowCanceledAwaitable : ICriticalNotifyCompletion
        {
            private readonly Task _task;

            /// &lt;summary&gt;
            /// Initializes a new instance of the &lt;see cref=&quot;ConfiguredTaskNoThrowCanceledAwaitable&quot;/&gt; struct.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;task&quot;&gt;The &lt;see cref=&quot;Task&quot;/&gt;.&lt;/param&gt;
            public ConfiguredTaskNoThrowCanceledAwaitable([NotNull] Task task)
            {
                _task = task;
            }

            /// &lt;summary&gt;
            /// Gets the awaiter for this awaitable.
            /// &lt;/summary&gt;
            /// &lt;returns&gt;The awaiter.&lt;/returns&gt;
            public ConfiguredTaskNoThrowCanceledAwaitable GetAwaiter() =&gt; this;

            /// &lt;summary&gt;
            /// Gets whether the task being awaited is completed.
            /// &lt;/summary&gt;
            /// &lt;returns&gt;Whether the task being awaited is completed.&lt;/returns&gt;
            public bool IsCompleted
                =&gt; _task.IsCompleted;

            /// &lt;summary&gt;Ends the await on the completed &lt;see cref=&quot;Task&quot;/&gt;.&lt;/summary&gt;
            // [StackTraceHidden] is framework-internal
            public void GetResult()
            {
                if (_task.IsCanceled)
                {
                    // this is where we swallowed the task&#39;s exception
                    // still, must observe it else it remains unobserved
                    _ = _task.Exception;
                }
                else
                {
                    // whatever happens, happens
                    _task.ConfigureAwait(false).GetAwaiter().GetResult();
                }
            }

            // see notes in ConfiguredTaskNoThrowAwaitable

            /// &lt;summary&gt;
            /// Schedules the continuation onto the &lt;see cref=&quot;Task&quot;/&gt; associated with this &lt;see cref=&quot;TaskAwaiter&quot;/&gt;.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;continuation&quot;&gt;The action to invoke when the await operation completes.&lt;/param&gt;
            public void OnCompleted(Action continuation)
                =&gt; _task.ConfigureAwait(false).GetAwaiter().OnCompleted(continuation);

            /// &lt;summary&gt;
            /// Schedules the continuation onto the &lt;see cref=&quot;Task&quot;/&gt; associated with this &lt;see cref=&quot;TaskAwaiter&quot;/&gt;.
            /// &lt;/summary&gt;
            /// &lt;param name=&quot;continuation&quot;&gt;The action to invoke when the await operation completes.&lt;/param&gt;
            public void UnsafeOnCompleted(Action continuation)
                =&gt; _task.ConfigureAwait(false).GetAwaiter().OnCompleted(continuation);
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[49,16,49,42,1],[62,16,62,42,1],[75,16,75,42,1],[88,16,88,42,1],[101,16,101,42,1],[116,16,116,56,1],[131,16,131,61,1],[147,16,147,64,1],[169,16,169,120,1],[191,16,191,95,0],[213,16,213,120,1],[235,16,235,95,0],[239,13,239,41,1],[241,17,241,50,0],[242,17,242,24,0],[245,13,245,67,1],[246,13,246,76,1],[248,13,248,67,1],[251,13,251,36,1],[253,17,253,38,1],[257,13,257,34,1],[259,17,259,38,1],[260,17,260,24,1],[264,13,264,36,1],[270,13,270,37,1],[273,13,273,77,1],[274,9,274,10,1],[278,13,278,41,1],[280,17,280,57,0],[283,13,283,67,1],[284,13,284,76,1],[286,13,286,67,1],[289,13,289,36,1],[291,17,291,38,1],[295,13,295,34,1],[297,17,297,45,1],[301,13,301,36,0],[307,13,307,37,0],[310,13,310,77,0],[311,9,311,10,1],[321,16,321,46,1],[329,16,329,62,1],[344,17,344,30,1],[345,13,345,14,1],[351,67,351,71,1],[358,20,358,37,1],[366,17,366,54,1],[366,57,366,77,1],[367,13,367,14,1],[391,20,391,86,0],[398,20,398,86,1],[414,17,414,30,1],[415,13,415,14,1],[421,72,421,76,1],[428,20,428,37,1],[441,17,441,52,1],[441,55,441,84,1],[442,13,442,14,1],[451,20,451,86,0],[458,20,458,86,1],[474,17,474,30,1],[475,13,475,14,1],[481,75,481,79,1],[488,20,488,37,1],[494,17,494,38,1],[498,21,498,41,1],[503,21,503,74,1],[505,13,505,14,1],[514,20,514,86,0],[521,20,521,86,1]]);
    </script>
  </body>
</html>