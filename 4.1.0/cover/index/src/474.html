<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Messaging\ClientMessageFragmentingExtensions.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using Hazelcast.Core;
using Hazelcast.Exceptions;

namespace Hazelcast.Messaging
{
    /// &lt;summary&gt;
    /// Provides extension methods to the &lt;see cref=&quot;ClientMessage&quot;/&gt; class for fragmenting messages.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// &lt;para&gt;When a message is fragmented, it is sent&lt;/para&gt;
    /// &lt;para&gt;For instance, if the original message is composed of the following message frames
    /// (MF): MF0, MF1, MF2, MF3, MF4, MF5(final) it could be fragmented into FF0(begin), MF0,
    /// MF1(final) then FF1, MF2, MF3 then FF2(end), MF4, MF5(final) with the fragmentation
    /// frames (FF) containing the fragment identifier.&lt;/para&gt;
    /// &lt;/remarks&gt;
    internal static class ClientMessageFragmentingExtensions
    {
        // we can use one single static sequence of fragment identifiers
        // Java uses a static CallIdSequenceWithoutBackPressure

        /// &lt;summary&gt;
        /// (internal for tests only)
        /// Gets the fragment identifiers sequence.
        /// &lt;/summary&gt;
        internal static ISequence&lt;long&gt; FragmentIdSequence = new Int64Sequence();

        /// &lt;summary&gt;
        /// Creates a new fragment.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;frame&quot;&gt;The first frame of the fragment.&lt;/param&gt;
        /// &lt;returns&gt;The new fragment.&lt;/returns&gt;
        private static ClientMessage NewFragment(Frame frame)
        {
            // TODO control allocations?
            // here we are allocating a small byte array which could come from an ArrayPool
            // but then, it would need to be returned to that same ArrayPool, which means
            // that we would need to flag those frames, and make sure we return their bytes
            // at the right time - which would be... when? should we make messages and
            // frames disposable then to avoid memory leaks?

            var f = new Frame(new byte[FrameFields.SizeOf.FragmentId]);
            f.WriteFragmentId(FragmentIdSequence.GetNext());
            return new ClientMessage(f).Append(frame.ShallowClone());
        }

        /// &lt;summary&gt;
        /// Fragments a message.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;message&quot;&gt;The message to fragment.&lt;/param&gt;
        /// &lt;param name=&quot;maxSize&quot;&gt;The maximum size of each fragment.&lt;/param&gt;
        /// &lt;returns&gt;An enumeration of fragments.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;Some fragments may be larger than &lt;paramref name=&quot;maxSize&quot;/&gt; if the original
        /// message contains frames large than &lt;paramref name=&quot;maxSize&quot;/&gt;, which cannot be
        /// fragmented.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public static IEnumerable&lt;ClientMessage&gt; Fragment(this ClientMessage message, int maxSize)
        {
            if (message == null) throw new ArgumentNullException(nameof(message));

            var size = 0;
            for (var frame = message.FirstFrame; frame != null; frame = frame.Next)
                size += frame.Length;

            // if this entire message is small enough,
            // return it without splitting it at all
            if (size &lt; maxSize)
            {
                yield return message;
                yield break;
            }

            ClientMessage ready = null;
            ClientMessage current = null;
            size = 0;

            // whether when creating a new fragment, or appending to an existing fragment,
            // make sure to shallow-clone the frames, as their flags might be modified, ie
            // the last frame of each segment will be marked as final

            for (var frame = message.FirstFrame; frame != null; frame = frame.Next)
            {
                if (frame.Length &gt; maxSize)
                {
                    // if this frame enough is too big, yield the current fragment if any,
                    // then yield a fragment containing only this frame, and continue from
                    // zero

                    if (ready != null)
                        yield return ready;
                    ready = current;

                    if (ready != null)
                        yield return ready;
                    ready = NewFragment(frame);

                    current = null;
                    size = 0;
                }
                else
                {
                    // otherwise, try to accumulate this frame

                    size += frame.Length;

                    if (size &lt;= maxSize)
                    {
                        // if total size is still small enough, create a current fragment
                        // if necessary, and append the frame, and continue accumulating

                        if (current == null)
                            current = NewFragment(frame);
                        else
                            current.Append(frame.ShallowClone());
                    }
                    else
                    {
                        // otherwise, we have to have a current fragment (but just make sure),
                        // so yield it, and then continue with a new fragment

                        if (ready != null)
                            yield return ready;
                        ready = current ?? throw new HazelcastException(&quot;panic&quot;);

                        current = NewFragment(frame);
                        size = frame.Length;
                    }
                }
            }

            var last = current ?? ready;
            if (last != null) last.Flags |= ClientMessageFlags.EndFragment;

            if (ready != null) yield return ready;
            if (current != null) yield return current;
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[41,9,41,82,1],[57,13,57,72,1],[58,13,58,61,1],[59,13,59,70,1],[75,13,75,33,1],[75,34,75,83,1],[77,13,77,26,1],[78,18,78,48,1],[78,50,78,63,1],[78,65,78,83,1],[79,17,79,38,1],[83,13,83,32,1],[85,17,85,38,1],[86,17,86,29,1],[89,13,89,40,1],[90,13,90,42,1],[91,13,91,22,1],[97,18,97,48,1],[97,50,97,63,1],[97,65,97,83,1],[99,17,99,44,1],[105,21,105,39,1],[106,25,106,44,1],[107,21,107,37,1],[109,21,109,39,1],[110,25,110,44,1],[111,21,111,48,1],[113,21,113,36,1],[114,21,114,30,1],[120,21,120,42,1],[122,21,122,41,1],[127,25,127,45,1],[128,29,128,58,1],[130,29,130,66,1],[137,25,137,43,1],[138,29,138,48,1],[139,25,139,82,1],[141,25,141,54,1],[142,25,142,45,1],[147,13,147,41,1],[148,13,148,30,1],[148,31,148,76,1],[150,13,150,31,1],[150,32,150,51,1],[151,13,151,33,1],[151,34,151,55,1],[152,9,152,10,1]]);
    </script>
  </body>
</html>