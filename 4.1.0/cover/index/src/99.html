<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Serialization\Collections\ReadOnlyLazyDictionary.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections;
using System.Collections.Generic;

namespace Hazelcast.Serialization.Collections
{
    /// &lt;summary&gt;
    /// Represent a lazy dictionary of keys and values.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TKey&quot;&gt;The type of the keys.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TValue&quot;&gt;The type of the values.&lt;/typeparam&gt;
    /// &lt;remarks&gt;
    /// &lt;para&gt;The key objects are always &lt;see cref=&quot;IData&quot;/&gt; instances.&lt;/para&gt;
    /// &lt;para&gt;This class is not thread-safe for writing: it should be entirely populated
    /// in a thread-safe way, before being returned to readers.&lt;/para&gt;
    /// &lt;para&gt;This class is thread-safe for reading, however for performance purposes, some values may
    /// be deserialized multiple times in multi-threaded situations.&lt;/para&gt;
    /// &lt;/remarks&gt;
    internal sealed class ReadOnlyLazyDictionary&lt;TKey, TValue&gt; : IReadOnlyDictionary&lt;TKey, TValue&gt;
    {
        private readonly SerializationService _serializationService;

        private readonly Dictionary&lt;IData, ReadOnlyLazyEntry&lt;TKey, TValue&gt;&gt; _entries = new Dictionary&lt;IData, ReadOnlyLazyEntry&lt;TKey, TValue&gt;&gt;();
        private readonly Dictionary&lt;TKey, ReadOnlyLazyEntry&lt;TKey, TValue&gt;&gt; _keyEntries = new Dictionary&lt;TKey, ReadOnlyLazyEntry&lt;TKey, TValue&gt;&gt;();

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;ReadOnlyLazyDictionary{TKey,TValue}&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;serializationService&quot;&gt;The serialization service.&lt;/param&gt;
        public ReadOnlyLazyDictionary(SerializationService serializationService)
        {
            _serializationService = serializationService;
        }

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;ReadOnlyLazyDictionary{TKey,TValue}&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;entries&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;serializationService&quot;&gt;The serialization service.&lt;/param&gt;
        public ReadOnlyLazyDictionary(IEnumerable&lt;KeyValuePair&lt;IData, IData&gt;&gt; entries, SerializationService serializationService)
        {
            _serializationService = serializationService;
            Add(entries);
        }

        /// &lt;summary&gt;
        /// Gets the entries.
        /// &lt;/summary&gt;
        public Dictionary&lt;IData, ReadOnlyLazyEntry&lt;TKey, TValue&gt;&gt; Entries =&gt; _entries;

        /// &lt;summary&gt;
        /// Adds entries.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;entries&quot;&gt;Entries.&lt;/param&gt;
        public void Add(IEnumerable&lt;KeyValuePair&lt;IData, IData&gt;&gt; entries)
        {
            foreach (var (keyData, valueObject) in entries)
                _entries.Add(keyData, new ReadOnlyLazyEntry&lt;TKey, TValue&gt;(keyData, valueObject));
        }

        /// &lt;summary&gt;
        /// Adds a key-value pair.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;keyData&quot;&gt;The key data.&lt;/param&gt;
        /// &lt;param name=&quot;value&quot;&gt;The value.&lt;/param&gt;
        public void Add(IData keyData, TValue value)
        {
            _entries.Add(keyData, new ReadOnlyLazyEntry&lt;TKey, TValue&gt;(keyData, value));
        }

        /// &lt;summary&gt;
        /// Ensures that an entry has a key.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;entry&quot;&gt;The entry.&lt;/param&gt;
        private void EnsureKey(ReadOnlyLazyEntry&lt;TKey, TValue&gt; entry)
        {
            if (entry.HasKey) return;

            entry.Key = _serializationService.ToObject&lt;TKey&gt;(entry.KeyData);
        }

        /// &lt;summary&gt;
        /// Ensures that an entry has a value.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;entry&quot;&gt;The entry.&lt;/param&gt;
        private void EnsureValue(ReadOnlyLazyEntry&lt;TValue&gt; entry)
        {
            if (entry.HasValue) return;

            entry.Value = _serializationService.ToObject&lt;TValue&gt;(entry.ValueData);
        }

        /// &lt;inheritdoc /&gt;
        public IEnumerator&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; GetEnumerator()
        {
            foreach (var entry in _entries.Values)
            {
                // deserialize
                EnsureKey(entry);
                EnsureValue(entry);

                // while we&#39;re at it, ensure it&#39;s in the key entries too
                if (!_keyEntries.ContainsKey(entry.Key))
                    _keyEntries.Add(entry.Key, entry);

                yield return new KeyValuePair&lt;TKey, TValue&gt;(entry.Key, entry.Value);
            }
        }

        /// &lt;inheritdoc /&gt;
        IEnumerator IEnumerable.GetEnumerator() =&gt; GetEnumerator();

        /// &lt;inheritdoc /&gt;
        public int Count =&gt; _entries.Count;

        /// &lt;inheritdoc /&gt;
        public bool ContainsKey(TKey key)
        {
            if (key == null) throw new ArgumentNullException(nameof(key));

            // fast: use key entries
            if (_keyEntries.ContainsKey(key)) return true;

            // slower: serialize
            var keyData = _serializationService.ToData(key);

            // exit if no corresponding entry
            if (!_entries.TryGetValue(keyData, out var entry)) return false;

            // else, while we&#39;re at it, update the entry + key entries
            if (!entry.HasKey) entry.Key = key;
            _keyEntries.Add(key, entry);

            return true;
        }

        /// &lt;inheritdoc /&gt;
        public bool TryGetValue(TKey key, out TValue value)
        {
            value = default;

            // fast: use key entries
            if (_keyEntries.TryGetValue(key, out var cacheEntry))
            {
                EnsureValue(cacheEntry);
                value = cacheEntry.Value;
                return true;
            }

            // slower: serialize
            var keyData = _serializationService.ToData(key);

            // exit if no corresponding entry
            if (!_entries.TryGetValue(keyData, out var entry)) return false;

            // while we&#39;re at it, update the entry + key entries
            if (!entry.HasKey) entry.Key = key;
            _keyEntries.Add(key, entry);

            EnsureValue(entry);
            value = entry.Value;

            return true;
        }

        /// &lt;inheritdoc /&gt;
        public TValue this[TKey key]
        {
            get
            {
                if (TryGetValue(key, out var value))
                    return value;

                throw new KeyNotFoundException();
            }
        }

        /// &lt;inheritdoc /&gt;
        public IEnumerable&lt;TKey&gt; Keys
        {
            get
            {
                foreach (var entry in _entries.Values)
                {
                    EnsureKey(entry);
                    if (!_keyEntries.ContainsKey(entry.Key))
                        _keyEntries.Add(entry.Key, entry);
                    yield return entry.Key;
                }
            }
        }

        /// &lt;inheritdoc /&gt;
        public IEnumerable&lt;TValue&gt; Values
        {
            get
            {
                foreach (var entry in _entries.Values)
                {
                    EnsureValue(entry);
                    yield return entry.Value;
                }
            }
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[37,9,37,145,1],[37,9,37,145,0],[38,9,38,146,1],[38,9,38,146,0],[44,9,44,81,1],[46,13,46,58,1],[47,9,47,10,1],[54,9,54,130,0],[56,13,56,58,0],[57,13,57,26,0],[58,9,58,10,0],[63,78,63,86,1],[71,22,71,48,1],[71,49,71,51,1],[71,52,71,59,1],[72,17,72,98,1],[73,9,73,10,1],[82,13,82,88,1],[83,9,83,10,1],[91,13,91,30,1],[91,31,91,38,1],[93,13,93,77,1],[94,9,94,10,1],[102,13,102,32,1],[102,33,102,40,1],[104,13,104,83,1],[105,9,105,10,1],[110,22,110,31,1],[110,32,110,34,1],[110,35,110,50,1],[113,17,113,34,1],[114,17,114,36,1],[117,17,117,57,1],[118,21,118,55,1],[120,17,120,85,1],[122,9,122,10,0],[125,52,125,67,0],[128,29,128,43,1],[133,13,133,29,1],[133,30,133,75,0],[136,13,136,46,1],[136,47,136,59,0],[139,13,139,61,1],[142,13,142,63,1],[142,64,142,77,0],[145,13,145,31,1],[145,32,145,48,1],[146,13,146,41,1],[148,13,148,25,1],[154,13,154,29,1],[157,13,157,66,1],[159,17,159,41,1],[160,17,160,42,1],[161,17,161,29,1],[165,13,165,61,1],[168,13,168,63,1],[168,64,168,77,0],[171,13,171,31,1],[171,32,171,48,1],[172,13,172,41,1],[174,13,174,32,1],[175,13,175,33,1],[177,13,177,25,1],[185,17,185,53,0],[186,21,186,34,0],[188,17,188,50,0],[197,26,197,35,0],[197,36,197,38,0],[197,39,197,54,0],[199,21,199,38,0],[200,21,200,61,0],[201,25,201,59,0],[202,21,202,44,0],[204,13,204,14,0],[212,26,212,35,0],[212,36,212,38,0],[212,39,212,54,0],[214,21,214,40,0],[215,21,215,46,0],[217,13,217,14,0]]);
    </script>
  </body>
</html>