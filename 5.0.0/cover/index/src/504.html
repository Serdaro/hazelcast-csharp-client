<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Models\HOffsetDateTime.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Globalization;
using System.Text.RegularExpressions;

namespace Hazelcast.Models
{
    /// &lt;summary&gt;
    /// Represents Hazelcast SQL &lt;c&gt;TIMESTAMP_WITH_TIME_ZONE&lt;/c&gt; type corresponding to &lt;c&gt;java.time.OffsetDateTime&lt;/c&gt; in Java.
    /// &lt;/summary&gt;
    public readonly struct HOffsetDateTime : IEquatable&lt;HOffsetDateTime&gt;
    {
        private static readonly Regex ParseRegex = new Regex(
            @&quot;^(?&#39;local&#39;.+)(Z|(?&#39;offset&#39;(\+|\-)\d+:\d+))$&quot;,
            RegexOptions.Compiled | RegexOptions.ExplicitCapture
        );

        public static readonly TimeSpan MaxOffset = TimeSpan.FromHours(18);
        public static readonly TimeSpan MinOffset = TimeSpan.FromHours(-18);

        public static readonly HOffsetDateTime Max = new HOffsetDateTime(HLocalDateTime.Max, MinOffset);
        public static readonly HOffsetDateTime Min = new HOffsetDateTime(HLocalDateTime.Min, MaxOffset);

        /// &lt;summary&gt;
        /// Local part represented as &lt;see cref=&quot;HLocalDateTime&quot;/&gt;.
        /// &lt;/summary&gt;
        public HLocalDateTime LocalDateTime { get; }

        /// &lt;summary&gt;
        /// Offset value.
        /// Ranges between &lt;see cref=&quot;MinOffset&quot;/&gt; and &lt;see cref=&quot;MaxOffset&quot;/&gt; inclusive.
        /// Precision is 1 second, smaller values will be rounded and lost during serialization.
        /// &lt;/summary&gt;
        public TimeSpan Offset { get; }

        public HOffsetDateTime(HLocalDateTime localDateTime, TimeSpan offset = default)
        {
            if (offset &lt; MinOffset || offset &gt; MaxOffset)
                throw new ArgumentOutOfRangeException(nameof(offset), $@&quot;Offset must be between {MinOffset:hh\:mm} and {MaxOffset:hh\:mm}.&quot;);

            LocalDateTime = localDateTime;
            Offset = offset;
        }

        public HOffsetDateTime(DateTime localDateTime, TimeSpan offset = default) :
            this(new HLocalDateTime(localDateTime), offset)
        { }

        public HOffsetDateTime(DateTimeOffset dateTimeOffset) :
            this(new HLocalDateTime(dateTimeOffset.DateTime), dateTimeOffset.Offset)
        { }

        public bool TryToDateTimeOffset(out DateTimeOffset dateTimeOffset)
        {
            dateTimeOffset = default;

            if (!LocalDateTime.TryToDateTime(out var dateTime))
                return false;

            dateTimeOffset = new DateTimeOffset(dateTime, Offset);
            return true;
        }

        public DateTimeOffset ToDateTimeOffset() =&gt; new DateTimeOffset(LocalDateTime.ToDateTime().Ticks, Offset);

        public static explicit operator DateTimeOffset(HOffsetDateTime offsetDateTime) =&gt; offsetDateTime.ToDateTimeOffset();
        public static explicit operator HOffsetDateTime(DateTimeOffset dateTimeOffset) =&gt; new HOffsetDateTime(dateTimeOffset);

        public override string ToString()
        {
            return Offset switch
            {
                var s when s &lt; TimeSpan.Zero =&gt; LocalDateTime + &quot;-&quot; + Offset.ToString(@&quot;hh\:mm&quot;, CultureInfo.InvariantCulture),
                var s when s &gt; TimeSpan.Zero =&gt; LocalDateTime + &quot;+&quot; + Offset.ToString(@&quot;hh\:mm&quot;, CultureInfo.InvariantCulture),
                _ =&gt; LocalDateTime + &quot;Z&quot;
            };
        }

        public static bool TryParse(string s, out HOffsetDateTime offsetDateTime)
        {
            offsetDateTime = default;

            var offset = TimeSpan.Zero;
            var match = ParseRegex.Match(s);
            if (!match.Success ||
                !HLocalDateTime.TryParse(match.Groups[&quot;local&quot;].Value, out var localDateTime) ||
                (match.Groups[&quot;offset&quot;].Success &amp;&amp; !TimeSpan.TryParse(match.Groups[&quot;offset&quot;].Value.TrimStart(&#39;+&#39;), out offset)))
            {
                return false;
            }

            offsetDateTime = new HOffsetDateTime(localDateTime, offset);
            return true;
        }

        public static HOffsetDateTime Parse(string s)
        {
            return TryParse(s, out var offsetDateTime)
                ? offsetDateTime
                : throw new FormatException($&quot;Failed to parse \&quot;{s}\&quot; as {nameof(HOffsetDateTime)}.&quot;);
        }

        #region Equality members

        public bool Equals(HOffsetDateTime other)
        {
            return LocalDateTime.Equals(other.LocalDateTime) &amp;&amp; Offset.Equals(other.Offset);
        }

        public override bool Equals(object obj)
        {
            return obj is HOffsetDateTime other &amp;&amp; Equals(other);
        }

        public override int GetHashCode()
        {
            return HashCode.Combine(LocalDateTime, Offset);
        }

        public static bool operator ==(HOffsetDateTime left, HOffsetDateTime right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(HOffsetDateTime left, HOffsetDateTime right)
        {
            return !left.Equals(right);
        }

        #endregion

    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[26,9,29,11,1],[31,9,31,76,1],[32,9,32,77,1],[34,9,34,105,1],[35,9,35,105,1],[40,47,40,51,1],[47,34,47,38,1],[51,13,51,58,1],[52,17,52,142,0],[54,13,54,43,1],[55,13,55,29,1],[56,9,56,10,1],[59,13,59,60,0],[60,11,60,12,0],[63,13,63,85,1],[64,11,64,12,1],[68,13,68,38,0],[70,13,70,64,0],[71,17,71,30,0],[73,13,73,67,0],[74,13,74,25,0],[77,53,77,113,1],[79,91,79,124,1],[80,91,80,126,1],[84,13,86,23,1],[86,23,86,45,1],[86,45,86,49,1],[86,49,86,127,1],[86,127,87,23,1],[87,23,87,45,1],[87,45,87,49,1],[87,49,87,127,1],[87,127,88,22,1],[88,22,88,41,1],[88,41,89,15,1],[94,13,94,38,1],[96,13,96,40,1],[97,13,97,45,1],[98,13,100,129,1],[102,17,102,30,0],[105,13,105,73,1],[106,13,106,25,1],[111,13,113,103,1],[120,13,120,93,1],[125,13,125,66,0],[130,13,130,60,0],[135,13,135,39,0],[140,13,140,40,0]]);
    </script>
  </body>
</html>