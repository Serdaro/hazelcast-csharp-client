<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Models\HLocalTime.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Text.RegularExpressions;

namespace Hazelcast.Models
{
    /// &lt;summary&gt;
    /// Represents Hazelcast SQL &lt;c&gt;TIME&lt;/c&gt; type corresponding to &lt;c&gt;java.time.LocalTime&lt;/c&gt; in Java.
    /// &lt;/summary&gt;
    public readonly struct HLocalTime : IEquatable&lt;HLocalTime&gt;
    {
        private static readonly Regex ParseRegex = new Regex(
            @&quot;^(?&#39;hour&#39;\d+):(?&#39;minute&#39;\d+):(?&#39;second&#39;\d+)(\.(?&#39;nano&#39;\d+))?$&quot;,
            RegexOptions.Compiled | RegexOptions.ExplicitCapture
        );

        public static readonly HLocalTime Min = new HLocalTime(0, 0, 0, 0);
        public static readonly HLocalTime Max = new HLocalTime(23, 59, 59, 999_999_999);
        public static readonly HLocalTime Midnight = Min;
        public static readonly HLocalTime Noon = new HLocalTime(12, 0, 0, 0);

        /// &lt;summary&gt;
        /// Hour value. Ranges between 0 and 23 inclusive.
        /// &lt;/summary&gt;
        public byte Hour { get; }

        /// &lt;summary&gt;
        /// Minute value. Ranges between 0 and 59 inclusive.
        /// &lt;/summary&gt;
        public byte Minute { get; }

        /// &lt;summary&gt;
        /// Second value. Ranges between 0 and 59 inclusive.
        /// &lt;/summary&gt;
        public byte Second { get; }

        /// &lt;summary&gt;
        /// Nanosecond value. Ranges between 0 and 999999999 inclusive.
        /// &lt;/summary&gt;
        public int Nanosecond { get; }

        public HLocalTime(byte hour, byte minute, byte second, int nanosecond)
        {
            if (hour &gt; 23)
                throw new ArgumentOutOfRangeException(nameof(hour), @&quot;Hour must be between 0 and 23.&quot;);
            if (minute &gt; 59)
                throw new ArgumentOutOfRangeException(nameof(minute), @&quot;Minute must be between 0 and 59.&quot;);
            if (second &gt; 59)
                throw new ArgumentOutOfRangeException(nameof(second), @&quot;Second must be between 0 and 59.&quot;);
            if (nanosecond &lt; 0 || nanosecond &gt; 999_999_999)
                throw new ArgumentOutOfRangeException(nameof(nanosecond), @&quot;Nanosecond must be between 0 and 999999999.&quot;);

            Hour = hour;
            Minute = minute;
            Second = second;
            Nanosecond = nanosecond;
        }

        public HLocalTime(DateTime dateTime)
        {
            Hour = (byte)dateTime.Hour;
            Minute = (byte)dateTime.Minute;
            Second = (byte)dateTime.Second;
            Nanosecond = dateTime.Millisecond * 1000;
        }

        public HLocalTime(TimeSpan timeSpan)
        {
            Hour = (byte)timeSpan.Hours;
            Minute = (byte)timeSpan.Minutes;
            Second = (byte)timeSpan.Seconds;
            Nanosecond = timeSpan.Milliseconds * 1000;
        }

        public TimeSpan ToTimeSpan() =&gt; new TimeSpan(0, Hour, Minute, Second, Nanosecond / 1000);

        public static explicit operator TimeSpan(HLocalTime localTime) =&gt; localTime.ToTimeSpan();
        public static explicit operator HLocalTime(TimeSpan timeSpan) =&gt; new HLocalTime(timeSpan);
        public static explicit operator HLocalTime(DateTime dateTime) =&gt; new HLocalTime(dateTime);

        public override string ToString() =&gt; Nanosecond == 0
            ? $&quot;{Hour:D2}:{Minute:D2}:{Second:D2}&quot;
            : $&quot;{Hour:D2}:{Minute:D2}:{Second:D2}.{Nanosecond:D9}&quot;;

        public static bool TryParse(string s, out HLocalTime localTime)
        {
            localTime = default;

            var nano = 0;
            var match = ParseRegex.Match(s);
            if (!match.Success ||
                !byte.TryParse(match.Groups[&quot;hour&quot;].Value, out var hour) ||
                !byte.TryParse(match.Groups[&quot;minute&quot;].Value, out var minute) ||
                !byte.TryParse(match.Groups[&quot;second&quot;].Value, out var second) ||
                (match.Groups[&quot;nano&quot;].Success &amp;&amp; !int.TryParse(match.Groups[&quot;nano&quot;].Value, out nano))
            )
            {
                return false;
            }

            localTime = new HLocalTime(hour, minute, second, nano);
            return true;
        }

        public static HLocalTime Parse(string s)
        {
            return TryParse(s, out var localTime)
                ? localTime
                : throw new FormatException($&quot;Failed to parse \&quot;{s}\&quot; as {nameof(HLocalTime)}.&quot;);
        }

        #region Equality members

        public bool Equals(HLocalTime other)
        {
            return Hour == other.Hour &amp;&amp; Minute == other.Minute &amp;&amp; Second == other.Second &amp;&amp; Nanosecond == other.Nanosecond;
        }

        public override bool Equals(object obj)
        {
            return obj is HLocalTime other &amp;&amp; Equals(other);
        }

        public override int GetHashCode()
        {
            return HashCode.Combine(Hour, Minute, Second, Nanosecond);
        }

        public static bool operator ==(HLocalTime left, HLocalTime right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(HLocalTime left, HLocalTime right)
        {
            return !left.Equals(right);
        }

        #endregion

    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[25,9,28,11,1],[30,9,30,76,1],[31,9,31,89,1],[32,9,32,58,1],[33,9,33,78,1],[38,28,38,32,1],[43,30,43,34,1],[48,30,48,34,1],[53,33,53,37,1],[57,13,57,27,1],[58,17,58,104,0],[59,13,59,29,1],[60,17,60,108,0],[61,13,61,29,1],[62,17,62,108,0],[63,13,63,60,1],[64,17,64,123,0],[66,13,66,25,1],[67,13,67,29,1],[68,13,68,29,1],[69,13,69,37,1],[70,9,70,10,1],[74,13,74,40,1],[75,13,75,44,1],[76,13,76,44,1],[77,13,77,54,1],[78,9,78,10,1],[82,13,82,41,1],[83,13,83,45,1],[84,13,84,45,1],[85,13,85,55,1],[86,9,86,10,1],[88,41,88,97,1],[90,75,90,97,1],[91,74,91,98,1],[92,74,92,98,0],[94,46,96,67,1],[100,13,100,33,1],[102,13,102,26,1],[103,13,103,45,1],[104,13,109,14,1],[111,17,111,30,0],[114,13,114,68,1],[115,13,115,25,1],[120,13,122,98,1],[129,13,129,125,1],[134,13,134,61,0],[139,13,139,71,0],[144,13,144,39,0],[149,13,149,40,0]]);
    </script>
  </body>
</html>