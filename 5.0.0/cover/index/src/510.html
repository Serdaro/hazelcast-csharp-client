<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Metrics\ClientMetricSource.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using Hazelcast.Clustering;
using Hazelcast.Core;
using Microsoft.Extensions.Logging;

namespace Hazelcast.Metrics
{
    // the source of metrics for the client
    internal class ClientMetricSource : IMetricSource
    {
        private readonly Cluster _cluster;
        private readonly ILogger _logger;

        public ClientMetricSource(Cluster cluster, ILoggerFactory loggerFactory)
        {
            _cluster = cluster;
            _logger = loggerFactory.CreateLogger&lt;ClientMetricSource&gt;();
        }

        public static class MetricDescriptors
        {
            public static readonly MetricDescriptor&lt;long&gt; LastStatisticsCollectionTime = new MetricDescriptor&lt;long&gt;(&quot;lastStatisticsCollectionTime&quot;);
            public static readonly MetricDescriptor&lt;bool&gt; Enterprise = new MetricDescriptor&lt;bool&gt;(&quot;enterprise&quot;);
            public static readonly MetricDescriptor&lt;string&gt; ClientType = new MetricDescriptor&lt;string&gt;(&quot;clientType&quot;);
            public static readonly MetricDescriptor&lt;string&gt; ClientVersion = new MetricDescriptor&lt;string&gt;(&quot;clientVersion&quot;);
            public static readonly MetricDescriptor&lt;string&gt; ClientName = new MetricDescriptor&lt;string&gt;(&quot;clientName&quot;);
            public static readonly MetricDescriptor&lt;long&gt; ClusterConnectionTimestamp = new MetricDescriptor&lt;long&gt;(&quot;clusterConnectionTimestamp&quot;);
            public static readonly MetricDescriptor&lt;string&gt; ClientAddress = new MetricDescriptor&lt;string&gt;(&quot;clientAddress&quot;);

            public static class Credentials
            {
                public static readonly MetricDescriptor&lt;string&gt; Principal = new MetricDescriptor&lt;string&gt;(&quot;credentials&quot;, &quot;principal&quot;);
            }

            // ReSharper disable once InconsistentNaming
            public static class OS
            {
                public static readonly MetricDescriptor&lt;long&gt; CommittedVirtualMemorySize = new MetricDescriptor&lt;long&gt;(&quot;os&quot;, &quot;committedVirtualMemorySize&quot;);
                public static readonly MetricDescriptor&lt;long&gt; FreePhysicalMemorySize = new MetricDescriptor&lt;long&gt;(&quot;os&quot;, &quot;freePhysicalMemorySize&quot;);
                public static readonly MetricDescriptor&lt;long&gt; FreeSwapSpaceSize = new MetricDescriptor&lt;long&gt;(&quot;os&quot;, &quot;freeSwapSpaceSize&quot;);
                public static readonly MetricDescriptor&lt;long&gt; MaxFileDescriptorCount = new MetricDescriptor&lt;long&gt;(&quot;os&quot;, &quot;maxFileDescriptorCount&quot;);
                public static readonly MetricDescriptor&lt;long&gt; OpenFileDescriptorCount = new MetricDescriptor&lt;long&gt;(&quot;os&quot;, &quot;openFileDescriptorCount&quot;);
                public static readonly MetricDescriptor&lt;long&gt; ProcessCpuTime = new MetricDescriptor&lt;long&gt;(&quot;os&quot;, &quot;processCpuTime&quot;);
                public static readonly MetricDescriptor&lt;double&gt; SystemLoadAverage = new MetricDescriptor&lt;double&gt;(&quot;os&quot;, &quot;systemLoadAverage&quot;);
                public static readonly MetricDescriptor&lt;long&gt; TotalPhysicalMemorySize = new MetricDescriptor&lt;long&gt;(&quot;os&quot;, &quot;totalPhysicalMemorySize&quot;);
                public static readonly MetricDescriptor&lt;long&gt; TotalSwapSpaceSize = new MetricDescriptor&lt;long&gt;(&quot;os&quot;, &quot;totalSwapSpaceSize&quot;);
            }

            public static class Runtime
            {
                public static readonly MetricDescriptor&lt;int&gt; AvailableProcessors = new MetricDescriptor&lt;int&gt;(&quot;runtime&quot;, &quot;availableProcessors&quot;);
                public static readonly MetricDescriptor&lt;long&gt; FreeMemory = new MetricDescriptor&lt;long&gt;(&quot;runtime&quot;, &quot;freeMemory&quot;);
                public static readonly MetricDescriptor&lt;long&gt; MaxMemory = new MetricDescriptor&lt;long&gt;(&quot;runtime&quot;, &quot;maxMemory&quot;);
                public static readonly MetricDescriptor&lt;long&gt; TotalMemory = new MetricDescriptor&lt;long&gt;(&quot;runtimes&quot;, &quot;totalMemory&quot;);
                public static readonly MetricDescriptor&lt;long&gt; Uptime = new MetricDescriptor&lt;long&gt;(&quot;runtime&quot;, &quot;uptime&quot;);
                public static readonly MetricDescriptor&lt;long&gt; UsedMemory = new MetricDescriptor&lt;long&gt;(&quot;runtime&quot;, &quot;usedMemory&quot;);
            }
        }

        public IEnumerable&lt;Metric&gt; PublishMetrics()
        {
            // the Java client gets these from a random connection
            // we try to be more consistent and always pick the oldest active connection
            var connection = _cluster.Members.GetOldestConnection();
            if (connection == null)
            {
                _logger.LogDebug(&quot;Cannot send metrics, client is not connected.&quot;);
                yield break;
            }

            yield return MetricDescriptors.Enterprise.WithValue(false);
            yield return MetricDescriptors.ClientType.WithValue(&quot;CSHARP&quot;);
            yield return MetricDescriptors.ClientVersion.WithValue(ClientVersion.Version);
            yield return MetricDescriptors.ClientName.WithValue(_cluster.ClientName);
            yield return MetricDescriptors.ClusterConnectionTimestamp.WithValue(Clock.ToEpoch(connection.ConnectTime.UtcDateTime)); // TODO: ToEpoch supports DateTimeOffset
            yield return MetricDescriptors.ClientAddress.WithValue(connection.LocalEndPoint.Address.ToString());

            yield return MetricDescriptors.Credentials.Principal.WithValue(connection.Principal);

            yield return MetricDescriptors.OS.CommittedVirtualMemorySize.WithValue(Process.GetCurrentProcess().VirtualMemorySize64);
            yield return MetricDescriptors.OS.FreePhysicalMemorySize.WithoutValue();
            yield return MetricDescriptors.OS.FreeSwapSpaceSize.WithoutValue();
            yield return MetricDescriptors.OS.MaxFileDescriptorCount.WithoutValue();
            yield return MetricDescriptors.OS.OpenFileDescriptorCount.WithValue(Process.GetCurrentProcess().HandleCount);
            yield return MetricDescriptors.OS.ProcessCpuTime.WithValue((long)Process.GetCurrentProcess().TotalProcessorTime.TotalMilliseconds * 1000000);
            yield return MetricDescriptors.OS.SystemLoadAverage.WithoutValue();
            yield return MetricDescriptors.OS.TotalPhysicalMemorySize.WithoutValue();
            yield return MetricDescriptors.OS.TotalSwapSpaceSize.WithoutValue();

            yield return MetricDescriptors.Runtime.AvailableProcessors.WithValue(Environment.ProcessorCount);
            yield return MetricDescriptors.Runtime.FreeMemory.WithoutValue();
            yield return MetricDescriptors.Runtime.MaxMemory.WithValue(Process.GetCurrentProcess().MaxWorkingSet.ToInt64());
            yield return MetricDescriptors.Runtime.TotalMemory.WithValue(Process.GetCurrentProcess().WorkingSet64);
            yield return MetricDescriptors.Runtime.Uptime.WithValue((long)(DateTime.Now - Process.GetCurrentProcess().StartTime).TotalMilliseconds);
            yield return MetricDescriptors.Runtime.UsedMemory.WithValue(Process.GetCurrentProcess().WorkingSet64);
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[30,9,30,81,0],[32,13,32,32,0],[33,13,33,72,0],[34,9,34,10,0],[38,13,38,149,0],[39,13,39,113,0],[40,13,40,117,0],[41,13,41,123,0],[42,13,42,117,0],[43,13,43,145,0],[44,13,44,123,0],[48,17,48,134,0],[54,17,54,155,0],[55,17,55,147,0],[56,17,56,137,0],[57,17,57,147,0],[58,17,58,149,0],[59,17,59,131,0],[60,17,60,141,0],[61,17,61,149,0],[62,17,62,139,0],[67,17,67,144,0],[68,17,68,128,0],[69,17,69,126,0],[70,17,70,131,0],[71,17,71,120,0],[72,17,72,128,0],[80,13,80,69,0],[81,13,81,36,0],[83,17,83,83,0],[84,17,84,29,0],[87,13,87,72,0],[88,13,88,75,0],[89,13,89,91,0],[90,13,90,86,0],[91,13,91,132,0],[92,13,92,113,0],[94,13,94,98,0],[96,13,96,133,0],[97,13,97,85,0],[98,13,98,80,0],[99,13,99,85,0],[100,13,100,122,0],[101,13,101,154,0],[102,13,102,80,0],[103,13,103,86,0],[104,13,104,81,0],[106,13,106,110,0],[107,13,107,78,0],[108,13,108,125,0],[109,13,109,116,0],[110,13,110,149,0],[111,13,111,115,0],[112,9,112,10,0]]);
    </script>
  </body>
</html>