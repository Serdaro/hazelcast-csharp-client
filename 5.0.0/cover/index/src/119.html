<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Serialization\Collections\ReadOnlyLazyDictionaryOfList.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace Hazelcast.Serialization.Collections
{
    internal sealed class ReadOnlyLazyDictionaryOfList&lt;TKey, TValue&gt; : IReadOnlyDictionary&lt;TKey, IReadOnlyList&lt;TValue&gt;&gt;
    {
        private readonly SerializationService _serializationService;

        private readonly Dictionary&lt;IData, ReadOnlyLazyEntryOfList&lt;TKey, TValue&gt;&gt; _entries
            = new Dictionary&lt;IData, ReadOnlyLazyEntryOfList&lt;TKey, TValue&gt;&gt;();

        private readonly Dictionary&lt;TKey, ReadOnlyLazyEntryOfList&lt;TKey, TValue&gt;&gt; _keyEntries
            = new Dictionary&lt;TKey, ReadOnlyLazyEntryOfList&lt;TKey, TValue&gt;&gt;();


        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;ReadOnlyLazyDictionaryOfList{TKey,TValue}&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;serializationService&quot;&gt;The serialization service.&lt;/param&gt;
        public ReadOnlyLazyDictionaryOfList(SerializationService serializationService)
        {
            _serializationService = serializationService;
        }

        /// &lt;summary&gt;
        /// Adds entries.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;entries&quot;&gt;Entries.&lt;/param&gt;
        public void Add(IEnumerable&lt;KeyValuePair&lt;IData, IData&gt;&gt; entries)
        {
            foreach (var (keyData, valueObject) in entries)
            {
                if (!_entries.TryGetValue(keyData, out var entry))
                    _entries.Add(keyData, entry = new ReadOnlyLazyEntryOfList&lt;TKey, TValue&gt;(keyData, new ReadOnlyLazyList&lt;TValue&gt;(_serializationService)));
                entry.Values.Add(valueObject);
            }
        }

        /// &lt;summary&gt;
        /// Ensures that an entry has a key.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;entry&quot;&gt;The entry.&lt;/param&gt;
        private void EnsureKey(ReadOnlyLazyEntryOfList&lt;TKey, TValue&gt; entry)
        {
            if (entry.HasKey) return;

            entry.Key = _serializationService.ToObject&lt;TKey&gt;(entry.KeyData);
        }

        /// &lt;inheritdoc /&gt;
        public IEnumerator&lt;KeyValuePair&lt;TKey, IReadOnlyList&lt;TValue&gt;&gt;&gt; GetEnumerator()
        {
            foreach (var entry in _entries.Values)
            {
                // deserialize
                EnsureKey(entry);

                // while we&#39;re at it, ensure it&#39;s in the key entries too
                if (!_keyEntries.ContainsKey(entry.Key))
                    _keyEntries.Add(entry.Key, entry);

                yield return new KeyValuePair&lt;TKey, IReadOnlyList&lt;TValue&gt;&gt;(entry.Key, entry.Values);
            }
        }

        /// &lt;inheritdoc /&gt;
        IEnumerator IEnumerable.GetEnumerator() =&gt; GetEnumerator();

        /// &lt;inheritdoc /&gt;
        public int Count =&gt; _entries.Count;

        /// &lt;inheritdoc /&gt;
        public bool ContainsKey(TKey key)
        {
            if (key == null) throw new ArgumentNullException(nameof(key));

            // fast: use key entries
            if (_keyEntries.ContainsKey(key)) return true;

            // slower: serialize
            var keyData = _serializationService.ToData(key);

            // exit if no corresponding entry
            if (!_entries.TryGetValue(keyData, out var entry)) return false;

            // else, while we&#39;re at it, update the entry + key entries
            if (!entry.HasKey) entry.Key = key;
            _keyEntries.Add(key, entry);

            return true;
        }

        /// &lt;inheritdoc /&gt;
        public bool TryGetValue(TKey key, out IReadOnlyList&lt;TValue&gt; value)
        {
            value = default;

            // fast: use key entries
            if (_keyEntries.TryGetValue(key, out var cacheEntry))
            {
                value = cacheEntry.Values;
                return true;
            }

            // slower: serialize
            var keyData = _serializationService.ToData(key);

            // exit if no corresponding entry
            if (!_entries.TryGetValue(keyData, out var entry)) return false;

            // while we&#39;re at it, update the entry + key entries
            if (!entry.HasKey) entry.Key = key;
            _keyEntries.Add(key, entry);

            value = entry.Values;

            return true;
        }

        /// &lt;inheritdoc /&gt;
        public IReadOnlyList&lt;TValue&gt; this[TKey key]
        {
            get
            {
                if (TryGetValue(key, out var value))
                    return value;

                throw new KeyNotFoundException();
            }
        }

        /// &lt;inheritdoc /&gt;
        public IEnumerable&lt;TKey&gt; Keys
        {
            get
            {
                foreach (var entry in _entries.Values)
                {
                    EnsureKey(entry);
                    if (!_keyEntries.ContainsKey(entry.Key))
                        _keyEntries.Add(entry.Key, entry);
                    yield return entry.Key;
                }
            }
        }

        /// &lt;inheritdoc /&gt;
        public IEnumerable&lt;IReadOnlyList&lt;TValue&gt;&gt; Values
            =&gt; _entries.Values.Select(entry =&gt; entry.Values);
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[26,9,27,78,0],[29,9,30,77,0],[37,9,37,87,0],[39,13,39,58,0],[40,9,40,10,0],[48,22,48,48,0],[48,49,48,51,0],[48,52,48,59,0],[50,17,50,67,0],[51,21,51,156,0],[52,17,52,47,0],[54,9,54,10,0],[62,13,62,30,0],[62,31,62,38,0],[64,13,64,77,0],[65,9,65,10,0],[70,22,70,31,0],[70,32,70,34,0],[70,35,70,50,0],[73,17,73,34,0],[76,17,76,57,0],[77,21,77,55,0],[79,17,79,101,0],[81,9,81,10,0],[84,52,84,67,0],[87,29,87,43,0],[92,13,92,29,0],[92,30,92,75,0],[95,13,95,46,0],[95,47,95,59,0],[98,13,98,61,0],[101,13,101,63,0],[101,64,101,77,0],[104,13,104,31,0],[104,32,104,48,0],[105,13,105,41,0],[107,13,107,25,0],[113,13,113,29,0],[116,13,116,66,0],[118,17,118,43,0],[119,17,119,29,0],[123,13,123,61,0],[126,13,126,63,0],[126,64,126,77,0],[129,13,129,31,0],[129,32,129,48,0],[130,13,130,41,0],[132,13,132,34,0],[134,13,134,25,0],[142,17,142,53,0],[143,21,143,34,0],[145,17,145,50,0],[154,26,154,35,0],[154,36,154,38,0],[154,39,154,54,0],[156,21,156,38,0],[157,21,157,61,0],[158,25,158,59,0],[159,21,159,44,0],[161,13,161,14,0],[166,16,166,48,0],[166,48,166,60,0],[166,60,166,61,0]]);
    </script>
  </body>
</html>