<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Metrics\MetricsPublisher.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Hazelcast.Clustering;
using Hazelcast.Core;
using Hazelcast.NearCaching;
using Hazelcast.Protocol.Codecs;
using Microsoft.Extensions.Logging;

namespace Hazelcast.Metrics
{
    // the metric publishing service
    internal class MetricsPublisher : IAsyncDisposable
    {
        private readonly Cluster _cluster;
        private readonly MetricsOptions _options;
        private readonly ILogger _logger;
        private readonly List&lt;IMetricSource&gt; _metricSources = new List&lt;IMetricSource&gt;();
        private readonly List&lt;IMetricAsyncSource&gt; _metricAsyncSources = new List&lt;IMetricAsyncSource&gt;();

        private readonly CancellationTokenSource _cancel;
        private readonly Task _publishing;

        public MetricsPublisher(Cluster cluster, MetricsOptions options, ILoggerFactory loggerFactory)
        {
            _cluster = cluster;
            _options = options;
            _logger = loggerFactory.CreateLogger&lt;MetricsPublisher&gt;();

            // start the task
            _cancel = new CancellationTokenSource();
            _publishing = PublishAsync(_cancel.Token);

            _logger.LogDebug($&quot;Publishing metrics every {_options.PeriodSeconds}s&quot;);
        }

        public void AddSource(IMetricSource source)
            =&gt; _metricSources.Add(source);

        public void AddSource(IMetricAsyncSource source)
            =&gt; _metricAsyncSources.Add(source);

        private async Task PublishAsync(CancellationToken cancellationToken)
        {
            var delay = TimeSpan.FromSeconds(_options.PeriodSeconds);

            while (!cancellationToken.IsCancellationRequested)
            {
                await Task.Delay(delay, cancellationToken).CfAwait();

                try
                {
                    await SendMetricsAsync(cancellationToken).CfAwait();
                }
                catch (Exception e)
                {
                    // should never happen as SendMetricsAsync should not throw - but better be safe
                    _logger.LogError(e, &quot;Caught exception in MetricsPublished.&quot;);
                }
            }
        }


        private async Task SendMetricsAsync(CancellationToken cancellationToken)
        {
            // the Java client gets these from a random connection
            // we try to be more consistent and always pick the oldest active connection
            var connection = _cluster.Members.GetOldestConnection();
            if (connection == null)
            {
                _logger.LogDebug(&quot;Cannot send metrics, client is not connected.&quot;);
                return;
            }

            var timestamp = Clock.Milliseconds;
            var metrics = new List&lt;Metric&gt; { ClientMetricSource.MetricDescriptors.LastStatisticsCollectionTime.WithValue(timestamp) };

            foreach (var metricSource in _metricSources)
                metrics.AddRange(metricSource.PublishMetrics());

            foreach (var metricSource in _metricAsyncSources)
                await foreach (var metric in metricSource.PublishMetrics())
                    metrics.Add(metric);

            // TODO add NearCache manager as a metric source! - except, then, the source can be async!
            //await foreach (var nearCache in _nearCaches)
            //    metrics.AddRange(nearCache.Statistics.PublishMetrics());

            if (cancellationToken.IsCancellationRequested) return; // last chance to cancel

            try
            {
                byte[] bytes;
                using (var compressor = new MetricsCompressor())
                {
                    foreach (var metric in metrics)
                        compressor.Append(metric);
                    bytes = compressor.GetBytesAndReset(); // TODO: consider re-using the compressor
                }

                if (cancellationToken.IsCancellationRequested) return;

                var text = metrics.Serialize();

                if (cancellationToken.IsCancellationRequested) return;

                // non-cancelable
                _logger.LogDebug(&quot;Send stats:\n    &quot; + text.Replace(&quot;,&quot;, &quot;,\n    &quot;, StringComparison.OrdinalIgnoreCase));
                await SendMetricsAsync(timestamp, text, bytes).CfAwait();
            }
            catch (Exception e)
            {
                _logger.LogError(e, &quot;Failed to send metrics.&quot;);
            }
        }

        private async Task SendMetricsAsync(long timestamp, string attributes, byte[] metrics)
        {
            if (!_cluster.IsConnected) // last chance to avoid an exception
            {
                _logger.LogDebug(&quot;Cannot send metrics, client is not connected.&quot;);
                return;
            }

            _logger.LogDebug(&quot;Send metrics.&quot;);

            var requestMessage = ClientStatisticsCodec.EncodeRequest(timestamp, attributes, metrics);
            var responseMessage = await _cluster.Messaging.SendAsync(requestMessage).CfAwait();
            var _ = ClientStatisticsCodec.DecodeResponse(responseMessage);
        }

        /// &lt;inheritdoc /&gt;
        public async ValueTask DisposeAsync()
        {
            _cancel.Cancel();
            await _publishing.CfAwaitCanceled();
            _cancel.Dispose();
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[33,9,33,89,0],[34,9,34,104,0],[39,9,39,103,0],[41,13,41,32,0],[42,13,42,32,0],[43,13,43,70,0],[46,13,46,53,0],[47,13,47,55,0],[49,13,49,85,0],[50,9,50,10,0],[53,16,53,42,0],[56,16,56,47,0],[60,13,60,70,0],[62,13,62,63,0],[64,17,64,70,0],[68,21,68,73,0],[69,17,69,18,0],[70,17,70,36,0],[73,21,73,82,0],[74,17,74,18,0],[76,9,76,10,0],[83,13,83,69,0],[84,13,84,36,0],[86,17,86,83,0],[87,17,87,24,0],[90,13,90,48,0],[91,13,91,135,0],[93,22,93,38,0],[93,39,93,41,0],[93,42,93,56,0],[94,17,94,65,0],[96,22,96,38,0],[96,39,96,41,0],[96,42,96,61,0],[97,32,97,42,0],[97,43,97,45,0],[97,46,97,75,0],[98,21,98,41,0],[104,13,104,59,0],[104,60,104,67,0],[109,24,109,64,0],[111,30,111,40,0],[111,41,111,43,0],[111,44,111,51,0],[112,25,112,51,0],[113,21,113,59,0],[114,17,114,18,0],[116,17,116,63,0],[116,64,116,71,0],[118,17,118,48,0],[120,17,120,63,0],[120,64,120,71,0],[123,17,123,122,0],[124,17,124,74,0],[125,13,125,14,0],[126,13,126,32,0],[128,17,128,64,0],[129,13,129,14,0],[130,9,130,10,0],[134,13,134,39,0],[136,17,136,83,0],[137,17,137,24,0],[140,13,140,47,0],[142,13,142,102,0],[143,13,143,96,0],[144,13,144,75,0],[145,9,145,10,0],[150,13,150,30,0],[151,13,151,49,0],[152,13,152,31,0],[153,9,153,10,0]]);
    </script>
  </body>
</html>