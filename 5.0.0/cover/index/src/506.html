<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Models\MemberInfo.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using System.Linq;
using Hazelcast.Core;
using Hazelcast.Exceptions;
using Hazelcast.Networking;

namespace Hazelcast.Models
{
    /// &lt;summary&gt;
    /// Represents a member of a cluster.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// &lt;para&gt;This class implements &lt;see cref=&quot;IEquatable{MemberInfo}&quot;/&gt; and two instances are considered
    /// equal if their &lt;see cref=&quot;Id&quot;/&gt; are identical (the other fields are not considered for equality).&lt;/para&gt;
    /// &lt;/remarks&gt;
    public class MemberInfo : IEquatable&lt;MemberInfo&gt;
    {
        private static readonly Dictionary&lt;EndpointQualifier, NetworkAddress&gt; EmptyAddressMap = new Dictionary&lt;EndpointQualifier, NetworkAddress&gt;();

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;MemberInfo&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;id&quot;&gt;The unique identifier of the member.&lt;/param&gt;
        /// &lt;param name=&quot;address&quot;&gt;The network address of the member.&lt;/param&gt;
        /// &lt;param name=&quot;version&quot;&gt;The version of the server running the member.&lt;/param&gt;
        /// &lt;param name=&quot;isLiteMember&quot;&gt;Whether the member is a &quot;lite&quot; member.&lt;/param&gt;
        /// &lt;param name=&quot;attributes&quot;&gt;Attributes of the member.&lt;/param&gt;
        public MemberInfo(Guid id, NetworkAddress address, MemberVersion version, bool isLiteMember, IReadOnlyDictionary&lt;string, string&gt; attributes)
            : this(address, id, attributes, isLiteMember, version, false, null)
        { }

        /// &lt;summary&gt;
        /// Initializes a new instance of the &lt;see cref=&quot;MemberInfo&quot;/&gt; class.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;id&quot;&gt;The unique identifier of the member.&lt;/param&gt;
        /// &lt;param name=&quot;address&quot;&gt;The network address of the member.&lt;/param&gt;
        /// &lt;param name=&quot;version&quot;&gt;The version of the server running the member.&lt;/param&gt;
        /// &lt;param name=&quot;isLiteMember&quot;&gt;Whether the member is a &quot;lite&quot; member.&lt;/param&gt;
        /// &lt;param name=&quot;attributes&quot;&gt;Attributes of the member.&lt;/param&gt;
        /// &lt;param name=&quot;addressMapExists&quot;&gt;Whether the address map exists.&lt;/param&gt;
        /// &lt;param name=&quot;addressMap&quot;&gt;The address map.&lt;/param&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;That overload of the constructor is required by generated codecs.&lt;/para&gt;
        /// &lt;/remarks&gt;
        internal MemberInfo(NetworkAddress address, Guid id, IReadOnlyDictionary&lt;string, string&gt; attributes, bool isLiteMember, MemberVersion version, bool addressMapExists, IReadOnlyDictionary&lt;EndpointQualifier, NetworkAddress&gt; addressMap)
        {
            // yes, this constructor could be simplified, but it is used (exclusively) by the codec,
            // and must respect what the codec expects, so don&#39;t simplify it!

            Id = id;
            Address = address;
            Version = version;
            IsLiteMember = isLiteMember;
            Attributes = attributes;

            if (addressMapExists)
            {
                AddressMap = addressMap;
                PublicAddress = addressMap.WherePair((qualifier, _) =&gt; qualifier.Type == ProtocolType.Client &amp;&amp; qualifier.Identifier == &quot;public&quot;)
                    .SelectPair((_, addr) =&gt; addr)
                    .FirstOrDefault();
            }
            else
            {
                AddressMap = EmptyAddressMap; // will never get modified = safe
                PublicAddress = null;
            }
        }

        /// &lt;summary&gt;
        /// Whether to use the public address or the internal address to connect to the member.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;Determines the value of &lt;see cref=&quot;ConnectAddress&quot;/&gt;.&lt;/remarks&gt;
        internal bool UsePublicAddress { get; set; }

        /// &lt;summary&gt;
        /// Gets the unique identifier of the member.
        /// &lt;/summary&gt;
        public Guid Id { get; }

        /// &lt;summary&gt;
        /// (for internal use only) Gets the unique identifier of the member.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;Generated codecs expect this naming of the property. The public version
        /// of this is &lt;see cref=&quot;Id&quot;/&gt;.&lt;/para&gt;
        /// &lt;/remarks&gt;
        internal Guid Uuid =&gt; Id;

        /// &lt;summary&gt;
        /// Gets the network address of the member.
        /// &lt;/summary&gt;
        public NetworkAddress Address { get; }

        /// &lt;summary&gt;
        /// Gets the public network address of the member.
        /// &lt;/summary&gt;
        public NetworkAddress PublicAddress { get; }

        /// &lt;summary&gt;
        /// Gets the address to connect to.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;The address to connect to is either the &lt;see cref=&quot;PublicAddress&quot;/&gt; or the &lt;see cref=&quot;Address&quot;/&gt;,
        /// depending on the network structure and how members can be reached by the client.&lt;/remarks&gt;
        internal NetworkAddress ConnectAddress =&gt; UsePublicAddress ? PublicAddress : Address;

        /// &lt;summary&gt;
        /// Gets the version of the server running the member.
        /// &lt;/summary&gt;
        public MemberVersion Version { get; }

        /// &lt;summary&gt;
        /// Determines whether the member is a &quot;lite&quot; member.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;Lite members do not own partitions.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public bool IsLiteMember {get; }

        /// &lt;summary&gt;
        /// Gets the attributes of the member.
        /// &lt;/summary&gt;
        public IReadOnlyDictionary&lt;string, string&gt; Attributes { get; }

        /// &lt;summary&gt;
        /// Gets the address map.
        /// &lt;/summary&gt;
        internal IReadOnlyDictionary&lt;EndpointQualifier, NetworkAddress&gt; AddressMap { get; }

        /// &lt;inheritdoc /&gt;
        public override bool Equals(object obj)
            =&gt; Equals(obj as MemberInfo);

        /// &lt;summary&gt;
        /// Determines whether this &lt;see cref=&quot;MemberInfo&quot;/&gt; instance is equal to another &lt;see cref=&quot;MemberInfo&quot;/&gt; instance.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;other&quot;&gt;The other &lt;see cref=&quot;MemberInfo&quot;/&gt; instance.&lt;/param&gt;
        /// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt; if this &lt;see cref=&quot;MemberInfo&quot;/&gt; instance and the other &lt;see cref=&quot;MemberInfo&quot;/&gt; instance
        /// are considered being equal; otherwise &lt;c&gt;false&lt;/c&gt;.&lt;/returns&gt;
        public bool Equals(MemberInfo other)
        {
            if (other is null) return false;
            if (ReferenceEquals(this, other)) return true;

            // compare members on what matters: the id and the connect address

            return
                Id == other.Id &amp;&amp; 
                ConnectAddress == other.ConnectAddress;
        }

        /// &lt;summary&gt;
        /// Determines whether two &lt;see cref=&quot;MemberInfo&quot;/&gt; instances are equal.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;left&quot;&gt;The first &lt;see cref=&quot;MemberInfo&quot;/&gt; instance.&lt;/param&gt;
        /// &lt;param name=&quot;right&quot;&gt;The second &lt;see cref=&quot;MemberInfo&quot;/&gt; instance.&lt;/param&gt;
        /// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt; if the two &lt;see cref=&quot;MemberInfo&quot;/&gt; instances are considered being equal;
        /// otherwise &lt;c&gt;false&lt;/c&gt;.&lt;/returns&gt;
        public static bool operator ==(MemberInfo left, MemberInfo right)
            =&gt; left is null ? right is null : left.Equals(right);

        /// &lt;summary&gt;
        /// Determines whether two &lt;see cref=&quot;MemberInfo&quot;/&gt; instances are not equal.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;left&quot;&gt;The first &lt;see cref=&quot;MemberInfo&quot;/&gt; instance.&lt;/param&gt;
        /// &lt;param name=&quot;right&quot;&gt;The second &lt;see cref=&quot;MemberInfo&quot;/&gt; instance.&lt;/param&gt;
        /// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt; if the two &lt;see cref=&quot;MemberInfo&quot;/&gt; instances are considered being not equal;
        /// otherwise &lt;c&gt;false&lt;/c&gt;.&lt;/returns&gt;
        public static bool operator !=(MemberInfo left, MemberInfo right)
            =&gt; !(left == right);

        /// &lt;inheritdoc /&gt;
        public override int GetHashCode() =&gt; HashCode.Combine(Id, ConnectAddress);

        /// &lt;inheritdoc /&gt;
        public override string ToString()
        {
            return $&quot;(Member Address = {Address}, PublicAddress = {PublicAddress}, ConnectAddress = {ConnectAddress}, Id = {Id}, IsLite = {IsLiteMember})&quot;;
        }

        public string ToShortString(bool flagConnectAddress)
            =&gt; $&quot;{Id.ToShortString()} - {Address}{(!flagConnectAddress || UsePublicAddress ? &quot;&quot; : &quot;*&quot;)} / {(PublicAddress == null ? &quot;null&quot; : PublicAddress.ToString())}{(flagConnectAddress &amp;&amp; UsePublicAddress ? &quot;*&quot; : &quot;&quot;)}&quot;;
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[33,9,33,149,1],[44,15,44,80,1],[45,11,45,12,1],[60,9,60,241,1],[65,13,65,21,1],[66,13,66,31,1],[67,13,67,31,1],[68,13,68,41,1],[69,13,69,37,1],[71,13,71,34,1],[73,17,73,41,1],[74,17,74,72,1],[74,72,74,145,1],[74,145,75,46,1],[75,46,75,50,0],[75,50,76,39,1],[80,17,80,46,1],[81,17,81,38,1],[83,9,83,10,1],[89,42,89,46,1],[89,47,89,51,1],[94,26,94,30,1],[103,31,103,33,1],[108,41,108,45,1],[113,47,113,51,1],[120,51,120,93,1],[125,40,125,44,1],[133,35,133,39,1],[138,65,138,69,1],[143,86,143,90,1],[147,16,147,41,1],[157,13,157,31,1],[157,32,157,45,1],[158,13,158,46,1],[158,47,158,59,1],[162,13,164,56,1],[175,16,175,65,1],[185,16,185,32,1],[188,46,188,82,1],[193,13,193,156,1],[197,16,197,222,1]]);
    </script>
  </body>
</html>