<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Serialization\SerializationServiceBuilder.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using System.Linq;
using Hazelcast.Core;
using Hazelcast.Partitioning.Strategies;
using Microsoft.Extensions.Logging;

namespace Hazelcast.Serialization
{
    internal sealed class SerializationServiceBuilder
    {
        private readonly ILoggerFactory _loggerFactory;
        private const int DefaultOutBufferSize = 4*1024;

        private readonly IDictionary&lt;int, IDataSerializableFactory&gt; _dataSerializableFactories =
            new Dictionary&lt;int, IDataSerializableFactory&gt;();

        private readonly IDictionary&lt;int, IPortableFactory&gt; _portableFactories =
            new Dictionary&lt;int, IPortableFactory&gt;();

        private Endianness _endianness = Endianness.BigEndian;
        private bool _checkClassDefErrors = true;

        private ICollection&lt;IClassDefinition&gt; _classDefinitions =
            new HashSet&lt;IClassDefinition&gt;();

        private readonly SerializerHooks _hooks;
        private readonly List&lt;ISerializerDefinitions&gt; _definitions = new List&lt;ISerializerDefinitions&gt;();

        private SerializationOptions _options;

        private int _initialOutputBufferSize = DefaultOutBufferSize;

        private IPartitioningStrategy _partitioningStrategy;

        private int _portableVersion = -1;
        private byte _version = SerializationService.SerializerVersion;

        public SerializationServiceBuilder(ILoggerFactory loggerFactory)
        {
            _loggerFactory = loggerFactory;
            _hooks = new SerializerHooks();
        }

        public SerializationServiceBuilder SetVersion(byte version)
        {
            if (version &gt; SerializationService.SerializerVersion)
                throw new ArgumentException($&quot;Value cannot be higher than the max supported version ({SerializationService.SerializerVersion}).&quot;);

            _version = version;
            return this;
        }

        public SerializationServiceBuilder AddHook&lt;T&gt;()
        {
            _hooks.Add(typeof(T));
            return this;
        }

        public SerializationServiceBuilder AddHook(Type type)
        {
            _hooks.Add(type);
            return this;
        }

        public SerializationServiceBuilder AddDefinitions(ISerializerDefinitions definition)
        {
            _definitions.Add(definition);
            return this;
        }

        public SerializationServiceBuilder SetPortableVersion(int version)
        {
            if (version &lt; 0)
                throw new ArgumentOutOfRangeException(nameof(version), &quot;Value must be greater than, or equal to, zero.&quot;);

            _portableVersion = version;
            return this;
        }

        public SerializationServiceBuilder SetConfig(SerializationOptions options)
        {
            _options = options;
            if (_portableVersion &lt; 0)
                _portableVersion = options.PortableVersion;

            _checkClassDefErrors = options.ValidateClassDefinitions;
            _endianness = options.Endianness;

            return this;
        }

        public SerializationServiceBuilder AddDataSerializableFactory(int id, IDataSerializableFactory factory)
        {
            _dataSerializableFactories.Add(id, factory);
            return this;
        }

        public SerializationServiceBuilder AddPortableFactory(int id, IPortableFactory factory)
        {
            _portableFactories.Add(id, factory);
            return this;
        }

        public SerializationServiceBuilder AddClassDefinition(IClassDefinition cd)
        {
            _classDefinitions.Add(cd);
            return this;
        }

        public SerializationServiceBuilder SetCheckClassDefErrors(bool checkClassDefErrors)
        {
            _checkClassDefErrors = checkClassDefErrors;
            return this;
        }

        public SerializationServiceBuilder SetEndianness(Endianness endianness)
        {
            _endianness = endianness;
            return this;
        }

        public SerializationServiceBuilder SetPartitioningStrategy(IPartitioningStrategy partitionStrategy)
        {
            _partitioningStrategy = partitionStrategy;
            return this;
        }

        public SerializationServiceBuilder SetInitialOutputBufferSize(int initialOutputBufferSize)
        {
            if (initialOutputBufferSize &lt;= 0)
            {
                throw new ArgumentOutOfRangeException(nameof(initialOutputBufferSize), &quot;Value must be greater than zero.&quot;);
            }
            _initialOutputBufferSize = initialOutputBufferSize;
            return this;
        }

        public SerializationService Build()
        {
            if (_portableVersion &lt; 0)
                _portableVersion = 0;

            if (_options != null)
            {
                AddConfigDataSerializableFactories(_dataSerializableFactories, _options);
                AddConfigPortableFactories(_portableFactories, _options);
                _classDefinitions = _classDefinitions.Union(_options.ClassDefinitions).ToList();
            }

            var service = new SerializationService(
                _endianness,
                _portableVersion,
                _dataSerializableFactories,
                _portableFactories,
                _classDefinitions,
                _hooks,
                _definitions,
                _checkClassDefErrors,
                _partitioningStrategy,
                _initialOutputBufferSize,
                _loggerFactory);

            if (_options != null)
            {
                var globalSerializer = _options.GlobalSerializer;
                if (globalSerializer.IsConfigured)
                    service.SetGlobalSerializer(globalSerializer.Service, globalSerializer.OverrideClrSerialization);

                foreach (var serializer in _options.Serializers)
                    service.AddConfiguredSerializer(serializer.SerializedType, serializer.Service);
            }

            return service;
        }

        private static void AddConfigDataSerializableFactories(IDictionary&lt;int, IDataSerializableFactory&gt; dataSerializableFactories, SerializationOptions options)
        {
            foreach (var factoryOptions in options.DataSerializableFactories)
            {
                if (factoryOptions.Id &lt;= 0)
                    throw new ArgumentException(&quot;IDataSerializableFactory factoryId must be positive.&quot;);

                if (dataSerializableFactories.ContainsKey(factoryOptions.Id))
                    throw new InvalidOperationException($&quot;IDataSerializableFactory with factoryId {factoryOptions.Id} is already registered.&quot;);

                dataSerializableFactories.Add(factoryOptions.Id, factoryOptions.Service);
            }
        }

        private static void AddConfigPortableFactories(IDictionary&lt;int, IPortableFactory&gt; portableFactories, SerializationOptions options)
        {
            foreach (var factoryOptions in options.PortableFactories)
            {
                if (factoryOptions.Id &lt;= 0)
                    throw new ArgumentException(&quot;IPortableFactory factoryId must be positive.&quot;);

                if (portableFactories.ContainsKey(factoryOptions.Id))
                    throw new InvalidOperationException($&quot;IPortableFactory with factoryId {factoryOptions.Id} is already registered.&quot;);

                portableFactories.Add(factoryOptions.Id, factoryOptions.Service);
            }
        }

    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[29,9,30,61,1],[32,9,33,53,1],[36,9,36,50,1],[38,9,39,45,1],[42,9,42,105,1],[46,9,46,69,1],[50,9,50,43,1],[51,9,51,72,1],[53,9,53,73,1],[55,13,55,44,1],[56,13,56,44,1],[57,9,57,10,1],[61,13,61,66,1],[62,17,62,147,0],[64,13,64,32,1],[65,13,65,25,1],[70,13,70,35,1],[71,13,71,25,1],[76,13,76,30,0],[77,13,77,25,0],[82,13,82,42,1],[83,13,83,25,1],[88,13,88,29,1],[89,17,89,122,0],[91,13,91,40,1],[92,13,92,25,1],[97,13,97,32,1],[98,13,98,38,1],[99,17,99,60,1],[101,13,101,69,1],[102,13,102,46,1],[104,13,104,25,1],[109,13,109,57,1],[110,13,110,25,1],[115,13,115,49,1],[116,13,116,25,1],[121,13,121,39,1],[122,13,122,25,1],[127,13,127,56,1],[128,13,128,25,1],[133,13,133,38,1],[134,13,134,25,1],[139,13,139,55,1],[140,13,140,25,1],[145,13,145,46,1],[147,17,147,124,0],[149,13,149,64,1],[150,13,150,25,1],[155,13,155,38,1],[156,17,156,38,1],[158,13,158,34,1],[160,17,160,90,1],[161,17,161,74,1],[162,17,162,97,1],[165,13,176,33,1],[178,13,178,34,1],[180,17,180,66,1],[181,17,181,51,1],[182,21,182,118,1],[184,26,184,40,1],[184,41,184,43,1],[184,44,184,64,1],[185,21,185,100,1],[188,13,188,28,1],[193,22,193,40,1],[193,41,193,43,1],[193,44,193,77,1],[195,17,195,44,1],[196,21,196,105,1],[198,17,198,78,1],[199,21,199,144,1],[201,17,201,90,1],[203,9,203,10,1],[207,22,207,40,1],[207,41,207,43,1],[207,44,207,69,1],[209,17,209,44,1],[210,21,210,97,1],[212,17,212,70,1],[213,21,213,136,1],[215,17,215,82,1],[217,9,217,10,1]]);
    </script>
  </body>
</html>