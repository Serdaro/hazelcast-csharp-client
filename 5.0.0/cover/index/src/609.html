<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\DistributedObjects\Impl\HMultiMap.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Hazelcast.Clustering;
using Hazelcast.Core;
using Hazelcast.Messaging;
using Hazelcast.Models;
using Hazelcast.Protocol.Codecs;
using Hazelcast.Serialization;
using Hazelcast.Serialization.Collections;
using Microsoft.Extensions.Logging;

namespace Hazelcast.DistributedObjects.Impl
{
    internal class HMultiMap&lt;TKey, TValue&gt; : DistributedObjectBase, IHMultiMap&lt;TKey, TValue&gt;
    {
        private readonly ISequence&lt;long&gt; _lockReferenceIdSequence;

        public HMultiMap(string name, DistributedObjectFactory factory, Cluster cluster, SerializationService serializationService, ISequence&lt;long&gt; lockReferenceIdSequence, ILoggerFactory loggerFactory)
            : base(ServiceNames.MultiMap, name, factory, cluster, serializationService, loggerFactory)
        {
            _lockReferenceIdSequence = lockReferenceIdSequence;
        }

        /// &lt;inheritdoc /&gt;
        public Task&lt;Guid&gt; SubscribeAsync(Action&lt;MultiMapEventHandlers&lt;TKey, TValue&gt;&gt; events, bool includeValues = true, object state = null)
            =&gt; SubscribeAsync(events, Maybe.None, includeValues, state);

        /// &lt;inheritdoc /&gt;
        public Task&lt;Guid&gt; SubscribeAsync(Action&lt;MultiMapEventHandlers&lt;TKey, TValue&gt;&gt; events, TKey key, bool includeValues = true, object state = null)
            =&gt; SubscribeAsync(events, Maybe.Some(key), includeValues, state);

        private async Task&lt;Guid&gt; SubscribeAsync(Action&lt;MultiMapEventHandlers&lt;TKey, TValue&gt;&gt; events, Maybe&lt;TKey&gt; key, bool includeValues, object state)
        {
            if (events == null) throw new ArgumentNullException(nameof(events));

            var handlers = new MultiMapEventHandlers&lt;TKey, TValue&gt;();
            events(handlers);

            // 0: no entryKey
            // 1: entryKey
            var mode = key.Match(1, 0);
            var keyv = key.ValueOrDefault();

            var subscribeRequest = mode switch
            {
                0 =&gt; MultiMapAddEntryListenerCodec.EncodeRequest(Name, includeValues, Cluster.IsSmartRouting),
                1 =&gt; MultiMapAddEntryListenerToKeyCodec.EncodeRequest(Name, ToData(keyv), includeValues, Cluster.IsSmartRouting),
                _ =&gt; throw new NotSupportedException()
            };

            var subscription = new ClusterSubscription(
                subscribeRequest,
                ReadSubscribeResponse,
                CreateUnsubscribeRequest,
                ReadUnsubscribeResponse,
                HandleEventAsync,
                new MapSubscriptionState(mode, Name, handlers, state));

            await Cluster.Events.AddSubscriptionAsync(subscription).CfAwait();

            return subscription.Id;
        }

        private class MapSubscriptionState : SubscriptionState&lt;MultiMapEventHandlers&lt;TKey, TValue&gt;&gt;
        {
            public MapSubscriptionState(int mode, string name, MultiMapEventHandlers&lt;TKey, TValue&gt; handlers, object state)
                : base(name, handlers, state)
            {
                Mode = mode;
            }

            public int Mode { get; }
        }

        private ValueTask HandleEventAsync(ClientMessage eventMessage, object state)
        {
            var sstate = ToSafeState&lt;MapSubscriptionState&gt;(state);

            return sstate.Mode switch
            {
                0 =&gt; MultiMapAddEntryListenerCodec.HandleEventAsync(eventMessage, HandleEntryEventAsync, state, LoggerFactory),
                1 =&gt; MultiMapAddEntryListenerToKeyCodec.HandleEventAsync(eventMessage, HandleEntryEventAsync, state, LoggerFactory),
                _ =&gt; throw new NotSupportedException()
            };
        }

        private async ValueTask HandleEntryEventAsync(IData keyData, IData valueData, IData oldValueData, IData mergingValueData, int eventTypeData, Guid memberId, int numberOfAffectedEntries, object state)
        {
            if (eventTypeData == 0) return;
            var eventType = (MapEventTypes) eventTypeData;

            var member = Cluster.Members.GetMember(memberId);
            var key = LazyArg&lt;TKey&gt;(keyData);
            var value = LazyArg&lt;TValue&gt;(valueData);
            var oldValue = LazyArg&lt;TValue&gt;(oldValueData);
            var mergingValue = LazyArg&lt;TValue&gt;(mergingValueData);

            var sstate = ToSafeState&lt;MapSubscriptionState&gt;(state);

            // ReSharper disable once ForeachCanBePartlyConvertedToQueryUsingAnotherGetEnumerator
            foreach (var handler in sstate.Handlers)
            {
                if (handler.EventType.HasAll(eventType))
                {
                    var task = handler switch
                    {
                        IMapEntryEventHandler&lt;TKey, TValue, IHMultiMap&lt;TKey, TValue&gt;&gt; entryHandler =&gt; entryHandler.HandleAsync(this, member, key, value, oldValue, mergingValue, eventType, numberOfAffectedEntries, sstate.HandlerState),
                        IMapEventHandler&lt;TKey, TValue, IHMultiMap&lt;TKey, TValue&gt;&gt; mapHandler =&gt; mapHandler.HandleAsync(this, member, numberOfAffectedEntries, sstate.HandlerState),
                        _ =&gt; throw new NotSupportedException()
                    };
                    await task.CfAwait();
                }
            }
        }

        private static ClientMessage CreateUnsubscribeRequest(Guid subscriptionId, object state)
        {
            var sstate = ToSafeState&lt;MapSubscriptionState&gt;(state);
            return MultiMapRemoveEntryListenerCodec.EncodeRequest(sstate.Name, subscriptionId);
        }

        private static Guid ReadSubscribeResponse(ClientMessage responseMessage, object state)
        {
            var sstate = ToSafeState&lt;MapSubscriptionState&gt;(state);

            return sstate.Mode switch
            {
                0 =&gt; MultiMapAddEntryListenerCodec.DecodeResponse(responseMessage).Response,
                1 =&gt; MultiMapAddEntryListenerToKeyCodec.DecodeResponse(responseMessage).Response,
                _ =&gt; throw new NotSupportedException()
            };
        }

        private static bool ReadUnsubscribeResponse(ClientMessage unsubscribeResponseMessage, object state)
        {
            return MultiMapRemoveEntryListenerCodec.DecodeResponse(unsubscribeResponseMessage).Response;
        }

        /// &lt;inheritdoc /&gt;
        public ValueTask&lt;bool&gt; UnsubscribeAsync(Guid subscriptionId)
            =&gt; UnsubscribeBaseAsync(subscriptionId);

        /// &lt;inheritdoc /&gt;
        public async Task&lt;bool&gt; PutAsync(TKey key, TValue value)
        {
            var (keyData, valueData) = ToSafeData(key, value);
            var requestMessage = MultiMapPutCodec.EncodeRequest(Name, keyData, valueData, ContextId);
            var responseMessage = await Cluster.Messaging.SendToKeyPartitionOwnerAsync(requestMessage, keyData).CfAwait();
            return MultiMapPutCodec.DecodeResponse(responseMessage).Response;
        }

        /// &lt;inheritdoc /&gt;
        public async Task&lt;IReadOnlyCollection&lt;TValue&gt;&gt; GetAsync(TKey key)
        {
            var keyData = ToSafeData(key);
            var requestMessage = MultiMapGetCodec.EncodeRequest(Name, keyData, ContextId);
            var responseMessage = await Cluster.Messaging.SendToKeyPartitionOwnerAsync(requestMessage, keyData).CfAwait();
            var response = MultiMapGetCodec.DecodeResponse(responseMessage).Response;
            return new ReadOnlyLazyList&lt;TValue&gt;(response, SerializationService);
        }

        /// &lt;inheritdoc /&gt;
        public Task&lt;IReadOnlyCollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt; GetEntriesAsync()
             =&gt; GetEntrySetAsync(CancellationToken.None);

        private async Task&lt;IReadOnlyCollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;&gt; GetEntrySetAsync(CancellationToken cancellationToken)
        {
            var requestMessage = MultiMapEntrySetCodec.EncodeRequest(Name);
            var responseMessage = await Cluster.Messaging.SendAsync(requestMessage, cancellationToken).CfAwait();
            var response = MultiMapEntrySetCodec.DecodeResponse(responseMessage).Response;
            return new ReadOnlyLazyKeyValuePairs&lt;TKey, TValue&gt;(response, SerializationService);
        }

        /// &lt;inheritdoc /&gt;
        public async Task&lt;IReadOnlyCollection&lt;TKey&gt;&gt; GetKeysAsync()
        {
            var requestMessage = MultiMapKeySetCodec.EncodeRequest(Name);
            var responseMessage = await Cluster.Messaging.SendAsync(requestMessage).CfAwait();
            var response = MultiMapKeySetCodec.DecodeResponse(responseMessage).Response;
            return new ReadOnlyLazyList&lt;TKey&gt;(response, SerializationService);
        }

        /// &lt;inheritdoc /&gt;
        public async Task&lt;IReadOnlyCollection&lt;TValue&gt;&gt; GetValuesAsync()
        {
            var requestMessage = MultiMapValuesCodec.EncodeRequest(Name);
            var responseMessage = await Cluster.Messaging.SendAsync(requestMessage).CfAwait();
            var response  = MultiMapValuesCodec.DecodeResponse(responseMessage).Response;
            return new ReadOnlyLazyList&lt;TValue&gt;(response, SerializationService);
        }

        /// &lt;inheritdoc /&gt;
        public async Task&lt;bool&gt; ContainsEntryAsync(TKey key, TValue value)
        {
            var (keyData, valueData) = ToSafeData(key, value);
            var requestMessage = MultiMapContainsEntryCodec.EncodeRequest(Name, keyData, valueData, ContextId);
            var responseMessage = await Cluster.Messaging.SendToKeyPartitionOwnerAsync(requestMessage, keyData).CfAwait();
            return MultiMapContainsEntryCodec.DecodeResponse(responseMessage).Response;
        }

        /// &lt;inheritdoc /&gt;
        public async Task&lt;bool&gt; ContainsKeyAsync(TKey key)
        {
            var keyData = ToSafeData(key);
            var requestMessage = MultiMapContainsKeyCodec.EncodeRequest(Name, keyData, ContextId);
            var responseMessage = await Cluster.Messaging.SendToKeyPartitionOwnerAsync(requestMessage, keyData).CfAwait();
            return MultiMapContainsKeyCodec.DecodeResponse(responseMessage).Response;
        }

        /// &lt;inheritdoc /&gt;
        public async Task&lt;bool&gt; ContainsValueAsync(TValue value)
        {
            var valueData = ToSafeData(value);
            var requestMessage = MultiMapContainsValueCodec.EncodeRequest(Name, valueData);
            var responseMessage = await Cluster.Messaging.SendAsync(requestMessage).CfAwait();
            return MultiMapContainsValueCodec.DecodeResponse(responseMessage).Response;
        }

        /// &lt;inheritdoc /&gt;
        public async Task&lt;int&gt; GetSizeAsync()
        {
            var requestMessage = MultiMapSizeCodec.EncodeRequest(Name);
            var responseMessage = await Cluster.Messaging.SendAsync(requestMessage).CfAwait();
            return MultiMapSizeCodec.DecodeResponse(responseMessage).Response;
        }

        /// &lt;inheritdoc /&gt;
        public async Task&lt;int&gt; GetValueCountAsync(TKey key)
        {
            var keyData = ToSafeData(key);
            var requestMessage = MultiMapValueCountCodec.EncodeRequest(Name, keyData, ContextId);
            var responseMessage = await Cluster.Messaging.SendToKeyPartitionOwnerAsync(requestMessage, keyData).CfAwait();
            return MultiMapValueCountCodec.DecodeResponse(responseMessage).Response;
        }

        /// &lt;inheritdoc /&gt;
        public async Task&lt;bool&gt; RemoveAsync(TKey key, TValue value)
        {
            var (keyData, valueData) = ToSafeData(key, value);

            var requestMessage = MultiMapRemoveEntryCodec.EncodeRequest(Name, keyData, valueData, ContextId);
            var responseMessage = await Cluster.Messaging.SendToKeyPartitionOwnerAsync(requestMessage, keyData).CfAwait();
            return MultiMapRemoveEntryCodec.DecodeResponse(responseMessage).Response;
        }

        /// &lt;inheritdoc /&gt;
        public async Task&lt;IReadOnlyCollection&lt;TValue&gt;&gt; RemoveAsync(TKey key)
        {
            var keyData = ToSafeData(key);

            var requestMessage = MultiMapRemoveCodec.EncodeRequest(Name, keyData, ContextId);
            var responseMessage = await Cluster.Messaging.SendToKeyPartitionOwnerAsync(requestMessage, keyData).CfAwait();
            var response = MultiMapRemoveCodec.DecodeResponse(responseMessage).Response;
            return new ReadOnlyLazyList&lt;TValue&gt;(response, SerializationService);
        }

        /// &lt;inheritdoc /&gt;
        public async Task DeleteAsync(TKey key)
        {
            var keyData = ToSafeData(key);

            var requestMessage = MultiMapDeleteCodec.EncodeRequest(Name, keyData, ContextId);
            await Cluster.Messaging.SendToKeyPartitionOwnerAsync(requestMessage, keyData).CfAwait();
        }

        /// &lt;inheritdoc /&gt;
        public async Task ClearAsync()
        {
            var requestMessage = MultiMapClearCodec.EncodeRequest(Name);
            var responseMessage = await Cluster.Messaging.SendAsync(requestMessage).CfAwait();
            _ = MultiMapClearCodec.DecodeResponse(responseMessage);
        }

        /// &lt;inheritdoc /&gt;
        public Task LockAsync(TKey key)
            =&gt; LockAsync(key, TimeSpanExtensions.MinusOneMillisecond);

        /// &lt;inheritdoc /&gt;
        public Task&lt;bool&gt; TryLockAsync(TKey key)
            =&gt; TryLockAsync(key, TimeSpan.Zero, TimeSpanExtensions.MinusOneMillisecond);

        /// &lt;inheritdoc /&gt;
        public Task&lt;bool&gt; TryLockAsync(TKey key, TimeSpan timeToWait)
            =&gt; TryLockAsync(key, timeToWait, TimeSpanExtensions.MinusOneMillisecond);

        /// &lt;inheritdoc /&gt;
        public async Task&lt;bool&gt; TryLockAsync(TKey key, TimeSpan timeToWait, TimeSpan leaseTime)
        {
            var keyData = ToSafeData(key);
            var leaseTimeMs = leaseTime.RoundedMilliseconds();
            var timeToWaitMs = timeToWait.RoundedMilliseconds();
            var requestMessage = MultiMapTryLockCodec.EncodeRequest(Name, keyData, ContextId, leaseTimeMs, timeToWaitMs, _lockReferenceIdSequence.GetNext());
            var responseMessage = await Cluster.Messaging.SendToKeyPartitionOwnerAsync(requestMessage, keyData).CfAwait();
            return MultiMapTryLockCodec.DecodeResponse(responseMessage).Response;
        }

        /// &lt;inheritdoc /&gt;
        public async Task LockAsync(TKey key, TimeSpan leaseTime)
        {
            var keyData = ToSafeData(key);
            var leaseTimeMs = leaseTime.RoundedMilliseconds();
            var requestMessage = MultiMapLockCodec.EncodeRequest(Name, keyData, ContextId, leaseTimeMs, _lockReferenceIdSequence.GetNext());
            var responseMessage = await Cluster.Messaging.SendToKeyPartitionOwnerAsync(requestMessage, keyData).CfAwait();
            _ = MultiMapLockCodec.DecodeResponse(responseMessage);
        }

        /// &lt;inheritdoc /&gt;
        public async Task&lt;bool&gt; IsLockedAsync(TKey key)
        {
            var keyData = ToSafeData(key);
            var requestMessage = MultiMapIsLockedCodec.EncodeRequest(Name, keyData);
            var responseMessage = await Cluster.Messaging.SendToKeyPartitionOwnerAsync(requestMessage, keyData).CfAwait();
            return MultiMapIsLockedCodec.DecodeResponse(responseMessage).Response;
        }

        /// &lt;inheritdoc /&gt;
        public async Task UnlockAsync(TKey key)
        {
            var keyData = ToSafeData(key);
            var requestMessage = MultiMapUnlockCodec.EncodeRequest(Name, keyData, ContextId, _lockReferenceIdSequence.GetNext());
            var responseMessage = await Cluster.Messaging.SendToKeyPartitionOwnerAsync(requestMessage, keyData).CfAwait();
            _ = MultiMapUnlockCodec.DecodeResponse(responseMessage);
        }

        /// &lt;inheritdoc /&gt;
        public async Task ForceUnlockAsync(TKey key)
        {
            var keyData = ToSafeData(key);
            var requestMessage = MultiMapForceUnlockCodec.EncodeRequest(Name, keyData, _lockReferenceIdSequence.GetNext());
            var responseMessage = await Cluster.Messaging.SendToKeyPartitionOwnerAsync(requestMessage, keyData).CfAwait();
            _ = MultiMapForceUnlockCodec.DecodeResponse(responseMessage);
        }

        /// &lt;inheritdoc /&gt;
        public async IAsyncEnumerator&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; GetAsyncEnumerator(CancellationToken cancellationToken = default)
        {
            // all collections are async enumerable,
            // but by default we load the whole items set at once,
            // then iterate in memory
            var items = await GetEntrySetAsync(cancellationToken).CfAwait();
            foreach (var item in items)
                yield return item;
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[35,15,35,103,1],[37,13,37,64,1],[38,9,38,10,1],[42,16,42,72,1],[46,16,46,77,1],[50,13,50,32,1],[50,33,50,81,0],[52,13,52,70,1],[53,13,53,30,1],[57,13,57,40,1],[58,13,58,45,1],[60,13,62,22,1],[62,22,62,110,1],[62,110,63,22,1],[63,22,63,129,1],[63,129,64,22,1],[64,22,64,55,0],[64,55,65,15,1],[67,13,73,72,1],[75,13,75,79,1],[77,13,77,36,1],[78,9,78,10,1],[83,19,83,46,1],[85,17,85,29,1],[86,13,86,14,1],[88,31,88,35,1],[93,13,93,67,1],[95,13,97,22,1],[97,22,97,127,1],[97,127,98,22,1],[98,22,98,132,1],[98,132,99,22,1],[99,22,99,55,0],[99,55,100,15,1],[105,13,105,36,1],[105,37,105,44,0],[106,13,106,59,1],[108,13,108,62,1],[109,13,109,46,1],[110,13,110,52,1],[111,13,111,58,1],[112,13,112,66,1],[114,13,114,67,1],[117,22,117,33,1],[117,34,117,36,1],[117,37,117,52,1],[119,17,119,57,1],[121,21,123,103,1],[123,103,123,234,1],[123,234,124,96,1],[124,96,124,178,0],[124,178,125,30,1],[125,30,125,63,0],[125,63,126,23,1],[127,21,127,42,1],[130,9,130,10,1],[134,13,134,67,1],[135,13,135,96,1],[140,13,140,67,1],[142,13,144,22,1],[144,22,144,92,1],[144,92,145,22,1],[145,22,145,97,1],[145,97,146,22,1],[146,22,146,55,0],[146,55,147,15,1],[152,13,152,105,1],[157,16,157,52,1],[162,13,162,63,1],[163,13,163,102,1],[164,13,164,123,1],[165,13,165,78,1],[166,9,166,10,1],[171,13,171,43,1],[172,13,172,91,1],[173,13,173,123,1],[174,13,174,86,1],[175,13,175,81,1],[176,9,176,10,1],[180,17,180,57,1],[184,13,184,76,1],[185,13,185,114,1],[186,13,186,91,1],[187,13,187,96,1],[188,9,188,10,1],[193,13,193,74,1],[194,13,194,95,1],[195,13,195,89,1],[196,13,196,79,1],[197,9,197,10,1],[202,13,202,74,1],[203,13,203,95,1],[204,13,204,90,1],[205,13,205,81,1],[206,9,206,10,1],[211,13,211,63,1],[212,13,212,112,1],[213,13,213,123,1],[214,13,214,88,1],[215,9,215,10,1],[220,13,220,43,1],[221,13,221,99,1],[222,13,222,123,1],[223,13,223,86,1],[224,9,224,10,1],[229,13,229,47,1],[230,13,230,92,1],[231,13,231,95,1],[232,13,232,88,1],[233,9,233,10,1],[238,13,238,72,1],[239,13,239,95,1],[240,13,240,79,1],[241,9,241,10,1],[246,13,246,43,1],[247,13,247,98,1],[248,13,248,123,1],[249,13,249,85,1],[250,9,250,10,1],[255,13,255,63,1],[257,13,257,110,1],[258,13,258,123,1],[259,13,259,86,1],[260,9,260,10,1],[265,13,265,43,1],[267,13,267,94,1],[268,13,268,123,1],[269,13,269,89,1],[270,13,270,81,1],[271,9,271,10,1],[276,13,276,43,1],[278,13,278,94,1],[279,13,279,101,1],[280,9,280,10,1],[285,13,285,73,1],[286,13,286,95,1],[287,13,287,68,1],[288,9,288,10,1],[292,16,292,70,1],[296,16,296,88,1],[300,16,300,85,1],[305,13,305,43,1],[306,13,306,63,1],[307,13,307,65,1],[308,13,308,158,1],[309,13,309,123,1],[310,13,310,82,1],[311,9,311,10,1],[316,13,316,43,1],[317,13,317,63,1],[318,13,318,141,1],[319,13,319,123,1],[320,13,320,67,1],[321,9,321,10,1],[326,13,326,43,1],[327,13,327,85,1],[328,13,328,123,1],[329,13,329,83,1],[330,9,330,10,1],[335,13,335,43,1],[336,13,336,130,1],[337,13,337,123,1],[338,13,338,69,1],[339,9,339,10,1],[344,13,344,43,1],[345,13,345,124,1],[346,13,346,123,1],[347,13,347,74,1],[348,9,348,10,1],[356,13,356,77,0],[357,22,357,30,0],[357,31,357,33,0],[357,34,357,39,0],[358,17,358,35,0],[359,9,359,10,0]]);
    </script>
  </body>
</html>