<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Metrics\MetricsCompressor.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using System.IO;
using Hazelcast.Core;
using Ionic.Zlib;

namespace Hazelcast.Metrics
{
    // compresses metrics, closely following the MetricsCompressor.java code to ensure interoperability
    internal class MetricsCompressor : IDisposable
    {
        private const int InitialStringsBufferSize = 2 &lt;&lt; 10; // 2kB
        private const int InitialMetricsBufferSize = 2 &lt;&lt; 11; // 4kB
        private const int InitialTempBufferSize = 2 &lt;&lt; 8; // 512B

        // about compression
        // read https://stackoverflow.com/questions/6522778/java-util-zip-deflater-equivalent-in-c-sharp
        // System.IO.Compression.DeflateStream is *not* Java-compatible!
        // now using ZlibStream from DotNetZip, would be worth benchmarking against SharpZipLib

        // output streams for the blob containing the strings
        private MemoryStream _stringsBuffer;
        private ZlibStream _stringsCompressStream;
        private DataOutputStream _stringsOutput;

        // output streams for the blob containing the metrics
        private MemoryStream _metricsBuffer;
        private ZlibStream _metricsCompressStream;
        private DataOutputStream _metricsOutput;

        // temporary buffer to avoid fragmented writes to the compressed streams, when
        // when writing primitive fields - TODO: is this needed in C#?
        private readonly MemoryStream _tempBuffer;
        private readonly DataOutputStream _tempOutput;

        private SortedDictionary&lt;string, int&gt; _strings = new SortedDictionary&lt;string, int&gt;();
        private int _count;
        private IMetricDescriptor _lastDescriptor;
        private bool _disposed, _closed;

        public MetricsCompressor()
        {
            Reset(InitialStringsBufferSize, InitialMetricsBufferSize);

            // that one is never reset
            _tempBuffer = new MemoryStream(InitialTempBufferSize);
            _tempOutput = new DataOutputStream(_tempBuffer);
        }

        private static void Reset(ref MemoryStream buffer, ref ZlibStream compress, ref DataOutputStream output, int size)
        {
            compress?.Dispose();

            // shrink if capacity is more than 50% larger than the estimated size
            if (buffer == null || buffer.Capacity &gt; 3 * size/ 2)
            {
                buffer?.Dispose();
                buffer = new MemoryStream(size);
            }

            buffer.Seek(0, SeekOrigin.Begin);
            compress = new ZlibStream(buffer, CompressionMode.Compress, CompressionLevel.BestSpeed, true);
            output = new DataOutputStream(compress);
        }

        private void Reset(int stringsBufferSize, int metricsBufferSize)
        {
            Reset(ref _stringsBuffer, ref _stringsCompressStream, ref _stringsOutput, stringsBufferSize);
            Reset(ref _metricsBuffer, ref _metricsCompressStream, ref _metricsOutput, metricsBufferSize);

            _strings = new SortedDictionary&lt;string, int&gt;();
            _count = 0;
            _lastDescriptor = null;
            _closed = false;
        }

        public void Dispose()
        {
            if (_disposed) return;
            _disposed = true;

            _tempBuffer?.Dispose();

            _stringsCompressStream?.Dispose();
            _stringsBuffer?.Dispose();

            _metricsCompressStream?.Dispose();
            _metricsBuffer?.Dispose();
        }

        public void Append(Metric metric)
        {
            if (_closed) throw new InvalidOperationException(&quot;Compressor is closed.&quot;);

            // TODO: if we buffered metrics and ordered them by prefix we could save more space?

            if (!(metric is Metric&lt;double&gt;) &amp;&amp;
                !(metric is Metric&lt;long&gt;) &amp;&amp;
                !(metric is Metric&lt;int&gt;))
            {
                // we can only send numeric metrics, everything else is ignored
                return;
            }

            _tempBuffer.Seek(0, SeekOrigin.Begin);
            AppendDescriptor(metric.Descriptor);

            switch (metric)
            {
                case Metric&lt;double&gt; doubleMetric:
                    _tempOutput.WriteByte((byte) MetricValueType.Double);
                    _tempOutput.WriteDouble(doubleMetric.Value);
                    break;
                case Metric&lt;long&gt; longMetric:
                    _tempOutput.WriteByte((byte) MetricValueType.Long);
                    _tempOutput.WriteLong(longMetric.Value);
                    break;
                case Metric&lt;int&gt; intMetric:
                    _tempOutput.WriteByte((byte) MetricValueType.Long);
                    _tempOutput.WriteLong(intMetric.Value);
                    break;
            }

            // protect case
            if (_tempBuffer.Position &gt; int.MaxValue) throw new InvalidOperationException($&quot;Out of range: _tempBuffer.Position ({_tempBuffer.Position}).&quot;);

            _metricsOutput.Write(_tempBuffer.GetBuffer(), 0, (int) _tempBuffer.Position);
        }

        private void AppendDescriptor(IMetricDescriptor descriptor)
        {
            var mask = GetMask(descriptor);
            _tempOutput.WriteByte((byte) mask);

            if (mask.HasNone(DescriptorMask.Prefix))
                _tempOutput.WriteInt(GetStringId(descriptor.Prefix));

            if (mask.HasNone(DescriptorMask.Name))
                _tempOutput.WriteInt(GetStringId(descriptor.Name));

            if (mask.HasNone(DescriptorMask.DiscriminatorName))
                _tempOutput.WriteInt(GetStringId(descriptor.DiscriminatorKey));

            if (mask.HasNone(DescriptorMask.DiscriminatorValue))
                _tempOutput.WriteInt(GetStringId(descriptor.DiscriminatorValue));

            if (mask.HasNone(DescriptorMask.Unit))
                _tempOutput.WriteByte((byte) descriptor.Unit);

            //if (mask.HasNone(DescriptorMask.ExcludedTargets))
            //    tmpDos.WriteByte(MetricTarget.BitSet(descriptor.ExcludedTargets));

            if (mask.HasNone(DescriptorMask.TagCount))
                _tempOutput.WriteByte((byte) descriptor.Tags.Count);

            // further compression would be possible by writing only the different tags
            foreach (var (tagName, tagValue) in descriptor.Tags)
            {
                _tempOutput.WriteInt(GetStringId(tagName));
                _tempOutput.WriteInt(GetStringId(tagValue));
            }

            _count++;
            _lastDescriptor = descriptor; // TODO: Java clones the descriptor, are we safe?
        }

        private DescriptorMask GetMask(IMetricDescriptor descriptor)
        {
            var mask = DescriptorMask.None;

            // &quot;excluded targets&quot; are not supported, hence always masked
            mask |= DescriptorMask.ExcludedTargets;

            if (_lastDescriptor == null)
                return mask;

            if (descriptor.Prefix == _lastDescriptor.Prefix)
                mask |= DescriptorMask.Prefix;

            if (descriptor.Name == _lastDescriptor.Name)
                mask |= DescriptorMask.Name;

            if (descriptor.DiscriminatorKey == _lastDescriptor.DiscriminatorKey)
                mask |= DescriptorMask.DiscriminatorName;

            if (descriptor.DiscriminatorValue == _lastDescriptor.DiscriminatorValue)
                mask |= DescriptorMask.DiscriminatorValue;

            if (descriptor.Unit == _lastDescriptor.Unit)
                mask |= DescriptorMask.Unit;

            // &quot;excluded targets&quot; are not supported, hence always masked
            //if (Objects.equals(descriptor.excludedTargets(), lastDescriptor.excludedTargets()))
            //    mask |= DescriptorMask.ExcludedTargets;

            if (descriptor.TagCount == _lastDescriptor.TagCount)
                mask |= DescriptorMask.TagCount;

            return mask;
        }

        private int GetStringId(string s)
        {
            if (s == null)
                return -1;

            if (_strings.TryGetValue(s, out var id))
                return id;

            id = _strings.Count;
            _strings[s] = id;
            return id;
        }

        private void AppendStrings()
        {
            _stringsOutput.WriteInt(_strings.Count);
            var prevText = &quot;&quot;;

            // sorted dictionary is ordered by natural order of its keys
            // so that delta-processing is efficient
            foreach (var (stringText, stringId) in _strings)
            {
                // this should have been checked earlier, this is a safety check
                // this protects the length casts to byte below
                if (stringText.Length &gt; byte.MaxValue)
                    throw new InvalidOperationException($&quot;Out of range: stringText.Length (\&quot;{stringText}\&quot;).&quot;);

                // find the span of chars that is common to stringText and prevText
                var maxCommonLen = Math.Min(prevText.Length, stringText.Length);
                var commonLen = 0;
                while (commonLen &lt; maxCommonLen &amp;&amp; stringText[commonLen] == prevText[commonLen])
                    commonLen++;

                // compute the length of remaining, non-common chars
                var diffLen = stringText.Length - commonLen;

                // write through temp buffer
                _tempBuffer.Seek(0, SeekOrigin.Begin);

                // write
                _tempOutput.WriteInt(stringId);
                _tempOutput.WriteByte((byte) commonLen);
                _tempOutput.WriteByte((byte) diffLen);
                _tempOutput.WriteString(stringText, commonLen, diffLen);

                // protect case
                if (_tempBuffer.Position &gt; int.MaxValue) throw new InvalidOperationException($&quot;Out of range: _tempBuffer.Position ({_tempBuffer.Position}).&quot;);

                _stringsOutput.Write(_tempBuffer.GetBuffer(), 0, (int) _tempBuffer.Position);

                prevText = stringText;
            }
        }

        private byte[] GetBytes()
        {
            const int binaryFormatVersion = 1;
            const int sizeVersion = 2;
            const int sizeDictionaryBlob = 4;
            const int sizeCountMetrics = 4;

            const int bitsInByte = 8;
            const int byteMask = 0xff;

            // close the compressor, we&#39;re going to dispose the compressed streams
            _closed = true;

            AppendStrings();

            // got to dispose the compressed streams to flush them all
            _stringsCompressStream.Dispose();
            _stringsCompressStream = null;
            _metricsCompressStream.Dispose();
            _metricsCompressStream = null;

            // version info + dictionary length + dictionary blob + number of metrics + metrics blob
            var completeSize = sizeVersion + sizeDictionaryBlob + _stringsBuffer.Position + sizeCountMetrics + _metricsBuffer.Position;

            // protect casts
            if (completeSize &gt; int.MaxValue) throw new InvalidOperationException($&quot;Out of range: completeSize ({completeSize}).&quot;);
            if (_stringsBuffer.Position &gt; int.MaxValue) throw new InvalidOperationException($&quot;Out of range: _stringsBuffer.Length ({_stringsBuffer.Position}).&quot;);
            if (_metricsBuffer.Position &gt; int.MaxValue) throw new InvalidOperationException($&quot;Out of range: _metricsBuffer.Length ({_metricsBuffer.Position}).&quot;);

            using var buffer = new MemoryStream((int) completeSize);
            var output = new DataOutputStream(buffer);

            // ReSharper disable once ShiftExpressionResultEqualsZero - well, yes
            output.WriteByte((binaryFormatVersion &gt;&gt; bitsInByte) &amp; byteMask);
            output.WriteByte(binaryFormatVersion &amp; byteMask);

            output.WriteInt((int) _stringsBuffer.Position);
            output.Write(_stringsBuffer.GetBuffer(), 0, (int) _stringsBuffer.Position);
            output.WriteInt(_count);
            output.Write(_metricsBuffer.GetBuffer(), 0, (int) _metricsBuffer.Position);

            return buffer.ToArray();
        }

        public byte[] GetBytesAndReset()
        {
            var bytes = GetBytes();

            const int sizeFactoryNumerator = 11;
            const int sizeFactoryDenominator = 10;

            // TODO: use .Length vs .Position vs .Capacity?!
            var dictionaryBufferSize = (int) _stringsBuffer.Length * sizeFactoryNumerator / sizeFactoryDenominator;
            var metricsBufferSize = (int) _metricsBuffer.Length * sizeFactoryNumerator / sizeFactoryDenominator;
            Reset(dictionaryBufferSize, metricsBufferSize);

            return bytes;
        }

        [Flags]
        private enum DescriptorMask : byte
        {
            None = 0,
            Prefix = 1,
            Name = 1 &lt;&lt; 1,
            DiscriminatorName = 1 &lt;&lt; 2,
            DiscriminatorValue = 1 &lt;&lt; 3,
            Unit = 1 &lt;&lt; 4,
            ExcludedTargets = 1 &lt;&lt; 5,
            TagCount = 1 &lt;&lt; 6
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[50,9,50,94,0],[55,9,55,35,0],[57,13,57,71,0],[60,13,60,67,0],[61,13,61,61,0],[62,9,62,10,0],[66,13,66,33,0],[69,13,69,65,0],[71,17,71,35,0],[72,17,72,49,0],[75,13,75,46,0],[76,13,76,107,0],[77,13,77,53,0],[78,9,78,10,0],[82,13,82,106,0],[83,13,83,106,0],[85,13,85,60,0],[86,13,86,24,0],[87,13,87,36,0],[88,13,88,29,0],[89,9,89,10,0],[93,13,93,27,0],[93,28,93,35,0],[94,13,94,30,0],[96,13,96,36,0],[98,13,98,47,0],[99,13,99,39,0],[101,13,101,47,0],[102,13,102,39,0],[103,9,103,10,0],[107,13,107,25,0],[107,26,107,87,0],[111,13,113,42,0],[116,17,116,24,0],[119,13,119,51,0],[120,13,120,49,0],[125,21,125,74,0],[126,21,126,65,0],[127,21,127,27,0],[129,21,129,72,0],[130,21,130,61,0],[131,21,131,27,0],[133,21,133,72,0],[134,21,134,60,0],[139,13,139,53,0],[139,54,139,155,0],[141,13,141,90,0],[142,9,142,10,0],[146,13,146,44,0],[147,13,147,48,0],[149,13,149,53,0],[150,17,150,70,0],[152,13,152,51,0],[153,17,153,68,0],[155,13,155,64,0],[156,17,156,80,0],[158,13,158,65,0],[159,17,159,82,0],[161,13,161,51,0],[162,17,162,63,0],[167,13,167,55,0],[168,17,168,69,0],[171,22,171,45,0],[171,46,171,48,0],[171,49,171,64,0],[173,17,173,60,0],[174,17,174,61,0],[177,13,177,22,0],[178,13,178,42,0],[179,9,179,10,0],[183,13,183,44,0],[186,13,186,52,0],[188,13,188,41,0],[189,17,189,29,0],[191,13,191,61,0],[192,17,192,47,0],[194,13,194,57,0],[195,17,195,45,0],[197,13,197,81,0],[198,17,198,58,0],[200,13,200,85,0],[201,17,201,59,0],[203,13,203,57,0],[204,17,204,45,0],[210,13,210,65,0],[211,17,211,49,0],[213,13,213,25,0],[218,13,218,27,0],[219,17,219,27,0],[221,13,221,53,0],[222,17,222,27,0],[224,13,224,33,0],[225,13,225,30,0],[226,13,226,23,0],[231,13,231,53,0],[232,13,232,31,0],[236,22,236,48,0],[236,49,236,51,0],[236,52,236,60,0],[240,17,240,55,0],[241,21,241,113,0],[244,17,244,81,0],[245,17,245,35,0],[246,17,246,97,0],[247,21,247,33,0],[250,17,250,61,0],[253,17,253,55,0],[256,17,256,48,0],[257,17,257,57,0],[258,17,258,55,0],[259,17,259,73,0],[262,17,262,57,0],[262,58,262,159,0],[264,17,264,94,0],[266,17,266,39,0],[268,9,268,10,0],[281,13,281,28,0],[283,13,283,29,0],[286,13,286,46,0],[287,13,287,43,0],[288,13,288,46,0],[289,13,289,43,0],[292,13,292,136,0],[295,13,295,45,0],[295,46,295,131,0],[296,13,296,56,0],[296,57,296,162,0],[297,13,297,56,0],[297,57,297,162,0],[299,13,299,69,0],[300,13,300,55,0],[303,13,303,78,0],[304,13,304,62,0],[306,13,306,60,0],[307,13,307,88,0],[308,13,308,37,0],[309,13,309,88,0],[311,13,311,37,0],[312,9,312,10,0],[316,13,316,36,0],[322,13,322,116,0],[323,13,323,113,0],[324,13,324,60,0],[326,13,326,26,0]]);
    </script>
  </body>
</html>