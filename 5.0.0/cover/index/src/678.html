<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Core\ServiceFactory.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Hazelcast.Configuration.Binding;
using Hazelcast.Exceptions;

namespace Hazelcast.Core
{
    /// &lt;summary&gt;
    /// Provides methods to create instances of services.
    /// &lt;/summary&gt;
    /// &lt;remarks&gt;
    /// &lt;para&gt;The provided methods rely on the Activator.CreateInstance method to create
    /// the new instances and are not optimized for performance. It is fine to use them
    /// for e.g. creating singletons when the application starts, but they should not
    /// be used for intensive creation of objects.&lt;/para&gt;
    /// &lt;/remarks&gt;
    public static class ServiceFactory
    {
        /// &lt;summary&gt;
        /// Creates a new instance of type &lt;typeparamref name=&quot;T&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The type of the instance.&lt;/typeparam&gt;
        /// &lt;param name=&quot;stringArgs&quot;&gt;Optional string named arguments for the constructor (can be null).&lt;/param&gt;
        /// &lt;param name=&quot;paramArgs&quot;&gt;Parameter arguments for the constructor.&lt;/param&gt;
        /// &lt;returns&gt;A new instance of type &lt;typeparamref name=&quot;T&quot;/&gt;.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;This method relies on the Activator.CreateInstance or constructor
        /// invocation to create the new instance and is not optimized for performance.
        /// It is fine to use it for e.g. creating singletons when the application starts,
        /// but it should not be used for intensive creation of objects.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public static T CreateInstance&lt;T&gt;(IDictionary&lt;string, string&gt; stringArgs = null, params object[] paramArgs)
        {
#pragma warning disable CA1508 // Avoid dead conditional code
            // false-positive, https://github.com/dotnet/roslyn-analyzers/issues/3845
            if (paramArgs == null) throw new ArgumentNullException(nameof(paramArgs));
#pragma warning restore CA1508

            try
            {
                return As&lt;T&gt;(CreateInstanceInternal(typeof(T), stringArgs, paramArgs));
            }
            catch (Exception e)
            {
                throw new ServiceFactoryException($&quot;Failed to create an instance of type {typeof(T)}.&quot;, e);
            }
        }

        /// &lt;summary&gt;
        /// Creates a new instance of type &lt;paramref name=&quot;type&quot;/&gt; as &lt;typeparamref name=&quot;T&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The type of the returned instance.&lt;/typeparam&gt;
        /// &lt;param name=&quot;type&quot;&gt;The type of the created instance.&lt;/param&gt;
        /// &lt;param name=&quot;stringArgs&quot;&gt;Optional string named arguments for the constructor (can be null).&lt;/param&gt;
        /// &lt;param name=&quot;paramArgs&quot;&gt;Parameter arguments for the constructor.&lt;/param&gt;
        /// &lt;returns&gt;A new instance of type &lt;paramref name=&quot;type&quot;/&gt; as &lt;typeparamref name=&quot;T&quot;/&gt;.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;This method relies on the Activator.CreateInstance or constructor
        /// invocation to create the new instance and is not optimized for performance.
        /// It is fine to use it for e.g. creating singletons when the application starts,
        /// but it should not be used for intensive creation of objects.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public static T CreateInstance&lt;T&gt;(Type type, IDictionary&lt;string, string&gt; stringArgs = null, params object[] paramArgs)
        {
            if (type == null) throw new ArgumentNullException(nameof(type));
#pragma warning disable CA1508 // Avoid dead conditional code
            // false-positive, https://github.com/dotnet/roslyn-analyzers/issues/3845
            if (paramArgs == null) throw new ArgumentNullException(nameof(paramArgs));
#pragma warning restore CA1508

            try
            {
                return As&lt;T&gt;(CreateInstanceInternal(type, stringArgs, paramArgs));
            }
            catch (Exception e)
            {
                throw new ServiceFactoryException($&quot;Failed to create an instance of type {type} as {typeof(T)}.&quot;, e);
            }
        }

        /// &lt;summary&gt;
        /// Creates a new instance of type &lt;paramref name=&quot;typeName&quot;/&gt; as &lt;typeparamref name=&quot;T&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The type of the returned instance.&lt;/typeparam&gt;
        /// &lt;param name=&quot;typeName&quot;&gt;The name of the type of the created instance.&lt;/param&gt;
        /// &lt;param name=&quot;stringArgs&quot;&gt;Optional string named arguments for the constructor (can be null).&lt;/param&gt;
        /// &lt;param name=&quot;paramArgs&quot;&gt;Parameter arguments for the constructor.&lt;/param&gt;
        /// &lt;returns&gt;A new instance of type &lt;paramref name=&quot;typeName&quot;/&gt; as &lt;typeparamref name=&quot;T&quot;/&gt;.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;This method relies on the Activator.CreateInstance or constructor
        /// invocation to create the new instance and is not optimized for performance.
        /// It is fine to use it for e.g. creating singletons when the application starts,
        /// but it should not be used for intensive creation of objects.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public static T CreateInstance&lt;T&gt;(string typeName, IDictionary&lt;string, string&gt; stringArgs = null, params object[] paramArgs)
        {
            if (string.IsNullOrWhiteSpace(typeName)) throw new ArgumentException(ExceptionMessages.NullOrEmpty, nameof(typeName));
#pragma warning disable CA1508 // Avoid dead conditional code
            // false-positive, https://github.com/dotnet/roslyn-analyzers/issues/3845
            if (paramArgs == null) throw new ArgumentNullException(nameof(paramArgs));
#pragma warning restore CA1508

            try
            {
                return As&lt;T&gt;(CreateInstanceInternal(typeName, stringArgs, paramArgs));
            }
            catch (Exception e)
            {
                throw new ServiceFactoryException($&quot;Failed to create an instance of type {typeName} as {typeof(T)}.&quot;, e);
            }
        }

        /// &lt;summary&gt;
        /// Creates a new instance of type &lt;paramref name=&quot;type&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;type&quot;&gt;The type of the instance.&lt;/param&gt;
        /// &lt;param name=&quot;stringArgs&quot;&gt;Optional string named arguments for the constructor (can be null).&lt;/param&gt;
        /// &lt;param name=&quot;paramArgs&quot;&gt;Parameter arguments for the constructor.&lt;/param&gt;
        /// &lt;returns&gt;A new instance of type &lt;paramref name=&quot;type&quot;/&gt;.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;This method relies on the Activator.CreateInstance or constructor
        /// invocation to create the new instance and is not optimized for performance.
        /// It is fine to use it for e.g. creating singletons when the application starts,
        /// but it should not be used for intensive creation of objects.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public static object CreateInstance(Type type, IDictionary&lt;string, string&gt; stringArgs = null, params object[] paramArgs)
        {
            if (type == null) throw new ArgumentNullException(nameof(type));
#pragma warning disable CA1508 // Avoid dead conditional code
            // false-positive, https://github.com/dotnet/roslyn-analyzers/issues/3845
            if (paramArgs == null) throw new ArgumentNullException(nameof(paramArgs));
#pragma warning restore CA1508

            try
            {
                return CreateInstanceInternal(type, stringArgs, paramArgs);
            }
            catch (Exception e)
            {
                throw new ServiceFactoryException($&quot;Failed to create an instance of type {type}.&quot;, e);
            }
        }

        /// &lt;summary&gt;
        /// Creates a new instance of type &lt;paramref name=&quot;typeName&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;typeName&quot;&gt;The name of the type of the instance.&lt;/param&gt;
        /// &lt;param name=&quot;stringArgs&quot;&gt;Optional string named arguments for the constructor (can be null).&lt;/param&gt;
        /// &lt;param name=&quot;paramArgs&quot;&gt;Parameter arguments for the constructor.&lt;/param&gt;
        /// &lt;returns&gt;A new instance of type &lt;paramref name=&quot;typeName&quot;/&gt;.&lt;/returns&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;This method relies on the Activator.CreateInstance or constructor
        /// invocation to create the new instance and is not optimized for performance.
        /// It is fine to use it for e.g. creating singletons when the application starts,
        /// but it should not be used for intensive creation of objects.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public static object CreateInstance(string typeName, IDictionary&lt;string, string&gt; stringArgs = null, params object[] paramArgs)
        {
            if (string.IsNullOrWhiteSpace(typeName)) throw new ArgumentException(ExceptionMessages.NullOrEmpty, nameof(typeName));
#pragma warning disable CA1508 // Avoid dead conditional code
            // false-positive, https://github.com/dotnet/roslyn-analyzers/issues/3845
            if (paramArgs == null) throw new ArgumentNullException(nameof(paramArgs));
#pragma warning restore CA1508

            try
            {
                return CreateInstanceInternal(typeName, stringArgs, paramArgs);
            }
            catch (Exception e)
            {
                throw new ServiceFactoryException($&quot;Failed to create an instance of type {typeName}.&quot;, e);
            }
        }


        /// &lt;summary&gt;
        /// (internal for tests only)
        /// Casts an object.
        /// &lt;/summary&gt;
        internal static T As&lt;T&gt;(object o)
        {
            return o switch
            {
                T t =&gt; t,
                null =&gt; throw new ArgumentNullException(nameof(o)),
                _ =&gt; throw new InvalidCastException($&quot;Failed to cast object of type {o.GetType()} to {typeof (T)}.&quot;)
            };
        }

        private static Type GetType(string typeName)
        {
            var type = Type.GetType(typeName);
            if (type == null)
                throw new ArgumentException($&quot;Unknown type \&quot;{typeName}\&quot;.&quot;, nameof(typeName));
            return type;
        }

        /// &lt;summary&gt;
        /// (internal for tests only)
        /// Creates an instance.
        /// &lt;/summary&gt;
        internal static object CreateInstanceInternal(Type type, IDictionary&lt;string, string&gt; stringArgs, params object[] paramArgs)
        {
            if (type == null) throw new ArgumentNullException(nameof(type));
#pragma warning disable CA1508 // Avoid dead conditional code
            // false-positive, https://github.com/dotnet/roslyn-analyzers/issues/3845
            if (paramArgs == null) throw new ArgumentNullException(nameof(paramArgs));
#pragma warning restore CA1508

                // fast: use the empty ctor if no args (will throw if it does not exist)
            if ((stringArgs == null || stringArgs.Count == 0) &amp;&amp; paramArgs.Length == 0)
                return Activator.CreateInstance(type);

            var ctors = type.GetConstructors(BindingFlags.Instance | BindingFlags.Public)
                .OrderByDescending(x =&gt; x.GetParameters().Length);

            List&lt;object&gt; args = null;
            foreach (var ctor in ctors)
            {
                var parameters = ctor.GetParameters();
                if (parameters.Length == 0)
                    return Activator.CreateInstance(type);

                args ??= new List&lt;object&gt;();
                args.Clear();

                var match = true;
                foreach (var parameter in parameters)
                {
                    // ReSharper disable once UseMethodIsInstanceOfType
                    var objectArg = paramArgs.FirstOrDefault(x =&gt; parameter.ParameterType.IsAssignableFrom(x.GetType()));
                    if (objectArg != null)
                    {
                        args.Add(objectArg);
                        continue;
                    }

                    if (stringArgs != null &amp;&amp;
                        stringArgs.TryGetValue(parameter.Name, out var stringArg) &amp;&amp;
                        ConfigurationBinder.TryConvertValue(parameter.ParameterType, stringArg, &quot;&quot;, out var value, out _))
                    {
                        args.Add(value);
                        continue;
                    }

                    match = false;
                    break;
                }

                if (match)
                    return ctor.Invoke(args.ToArray());
            }

            // we know this throw - but then the exceptions are consistent
            return Activator.CreateInstance(type);
        }

        /// &lt;summary&gt;
        /// (internal for tests only)
        /// Creates an instance.
        /// &lt;/summary&gt;
        internal static object CreateInstanceInternal(string typeName, IDictionary&lt;string, string&gt; stringArgs, params object[] paramArgs)
        {
            if (string.IsNullOrWhiteSpace(typeName)) throw new ArgumentException(ExceptionMessages.NullOrEmpty, nameof(typeName));
            return CreateInstanceInternal(GetType(typeName), stringArgs, paramArgs);
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[52,13,52,35,1],[52,36,52,87,1],[57,17,57,88,1],[59,13,59,32,1],[61,17,61,108,1],[63,9,63,10,1],[81,13,81,30,1],[81,31,81,77,1],[84,13,84,35,1],[84,36,84,87,1],[89,17,89,83,1],[91,13,91,32,1],[93,17,93,118,1],[95,9,95,10,1],[113,13,113,53,1],[113,54,113,131,1],[116,13,116,35,1],[116,36,116,87,1],[121,17,121,87,1],[123,13,123,32,1],[125,17,125,122,1],[127,9,127,10,1],[144,13,144,30,1],[144,31,144,77,1],[147,13,147,35,1],[147,36,147,87,1],[152,17,152,76,1],[154,13,154,32,1],[156,17,156,103,1],[158,9,158,10,1],[175,13,175,53,1],[175,54,175,131,1],[178,13,178,35,1],[178,36,178,87,1],[183,17,183,80,1],[185,13,185,32,1],[187,17,187,107,1],[189,9,189,10,1],[198,13,200,24,1],[200,24,200,25,1],[200,25,201,25,1],[201,25,201,67,1],[201,67,202,22,1],[202,22,202,117,1],[202,117,203,15,1],[208,13,208,47,1],[209,13,209,30,1],[210,17,210,96,1],[211,13,211,25,1],[220,13,220,30,1],[220,31,220,77,1],[223,13,223,35,1],[223,36,223,87,1],[227,13,227,88,1],[228,17,228,55,1],[230,13,231,41,1],[231,41,231,65,1],[231,65,231,67,1],[233,13,233,38,1],[234,22,234,30,1],[234,31,234,33,1],[234,34,234,39,1],[236,17,236,55,1],[237,17,237,44,1],[238,21,238,59,1],[240,17,240,45,1],[241,17,241,30,1],[243,17,243,34,1],[244,26,244,39,1],[244,40,244,42,1],[244,43,244,53,1],[247,21,247,67,1],[247,67,247,120,1],[247,120,247,122,1],[248,21,248,43,1],[250,25,250,45,1],[251,25,251,34,1],[254,21,256,123,1],[258,25,258,41,1],[259,25,259,34,1],[262,21,262,35,1],[263,21,263,27,1],[266,17,266,27,1],[267,21,267,56,1],[271,13,271,51,1],[272,9,272,10,1],[280,13,280,53,1],[280,54,280,131,1],[281,13,281,85,1]]);
    </script>
  </body>
</html>