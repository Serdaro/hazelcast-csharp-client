<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>D:\a\hazelcast-csharp-client\hazelcast-csharp-client\src\Hazelcast.Net\Core\ConcurrentAsyncDictionary.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

namespace Hazelcast.Core
{
    /// &lt;summary&gt;
    /// Represents an asynchronous concurrent dictionary.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TKey&quot;&gt;The type of the keys.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TValue&quot;&gt;The type of the values.&lt;/typeparam&gt;
    internal class ConcurrentAsyncDictionary&lt;TKey, TValue&gt; : IAsyncEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;
        where TValue : class
    {
        // usage:
        // this class is used by the DistributedObjectFactory to cache its distributed objects, and by NearCache

        private readonly ConcurrentDictionary&lt;TKey, Entry&gt; _dictionary = new ConcurrentDictionary&lt;TKey, Entry&gt;();

        /// &lt;summary&gt;
        /// (internal for tests only)
        /// Adds an entry.
        /// &lt;/summary&gt;
        internal bool AddEntry(TKey key, Entry entry)
        {
            return _dictionary.TryAdd(key, entry);
        }

        /// &lt;summary&gt;
        /// Adds a key/value pair if the key does not already exists, or return the existing value if the key exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt;
        /// &lt;param name=&quot;factory&quot;&gt;A value factory.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;A cancellation token.&lt;/param&gt;
        /// &lt;returns&gt;The value in the dictionary.&lt;/returns&gt;
        public async ValueTask&lt;TValue&gt; GetOrAddAsync(TKey key, Func&lt;TKey, CancellationToken, ValueTask&lt;TValue&gt;&gt; factory, CancellationToken cancellationToken = default)
        {
            var entry = _dictionary.GetOrAdd(key, k =&gt; new Entry(k));

            // it is possible to GetOrAdd a null value, if the factory returns a null
            // value, but that value will not stay in the cache

            // fast
            // may be null but then the entry will be removed eventually
            if (entry.HasValue) return entry.Value;

            try
            {
                // await - may throw - meaning the factory has thrown, entry is failed
                var value = await entry.GetValue(factory, cancellationToken).CfAwait();
                if (value != null) return value;

                // remove the invalid entry (with null value) from the dictionary
                _dictionary.TryRemove(key, entry);
                return null; // and the entry has been removed
            }
            catch
            {
                // remove the failed entry from the dictionary
                _dictionary.TryRemove(key, entry);
                throw;
            }
        }

        /// &lt;summary&gt;
        /// Adds a key/value pair if the key does not already exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;key&quot;&gt;The key.&lt;/param&gt;
        /// &lt;param name=&quot;factory&quot;&gt;A value factory.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;A cancellation token.&lt;/param&gt;
        /// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt; if a key/value pair was added; otherwise &lt;c&gt;false&lt;/c&gt;.&lt;/returns&gt;
        public async ValueTask&lt;bool&gt; TryAddAsync(TKey key, Func&lt;TKey, CancellationToken, ValueTask&lt;TValue&gt;&gt; factory, CancellationToken cancellationToken = default)
        {
            var entry = new Entry(key);
            if (!_dictionary.TryAdd(key, entry)) return false;

            // it is not possible to add a null value, if the factory returns a null
            // value then TryAdd would return false and the value does not stay in
            // the cache

            try
            {
                // await - may throw - meaning the factory has thrown, entry is failed
                var value = await entry.GetValue(factory, cancellationToken).CfAwait();
                if (value != null) return true;

                // remove the invalid entry (with null value) from the dictionary
                _dictionary.TryRemove(key, entry);
                return false; // and the entry has been removed
            }
            catch
            {
                // remove the failed entry from the dictionary
                _dictionary.TryRemove(key, entry);
                throw;
            }
        }

        /// &lt;summary&gt;
        /// Attempts to get the value associated with a key.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;key&quot;&gt;The key identifying the entry.&lt;/param&gt;
        /// &lt;returns&gt;An attempt at getting the value associated with the specified key.&lt;/returns&gt;
        public async ValueTask&lt;Attempt&lt;TValue&gt;&gt; TryGetAsync(TKey key)
        {
            if (!_dictionary.TryGetValue(key, out var entry)) return Attempt.Failed;

            // it is not possible to get a null value
            return await TryGetEntryValueAsync(entry).CfAwait();
        }

        /// &lt;summary&gt;
        /// Tries to remove an entry, and returns the removed entry.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;key&quot;&gt;The key identifying the entry.&lt;/param&gt;
        /// &lt;returns&gt;An attempt at removing the value associated with the specified key.&lt;/returns&gt;
        public async ValueTask&lt;Attempt&lt;TValue&gt;&gt; TryGetAndRemoveAsync(TKey key)
        {
            if (!_dictionary.TryRemove(key, out var entry)) return Attempt.Failed;

            // it is not possible to get a null value
            return await TryGetEntryValueAsync(entry).CfAwait();
        }

        internal static async ValueTask&lt;Attempt&lt;TValue&gt;&gt; TryGetEntryValueAsync(Entry entry)
        {
            // it is not possible to get a null value

            // fast
            if (entry.HasValue)
            {
                if (entry.Value != null) return entry.Value;
                return Attempt.Failed;
            }

            try
            {
                var value = await entry.GetValue().CfAwait();
                if (value != null) return value;
            }
            catch
            {
                // ignore the exception here, it&#39;s handled by whatever has added the value
            }

            return Attempt.Failed;
        }

        /// &lt;summary&gt;
        /// Tries to remove an entry.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;key&quot;&gt;The key identifying the entry.&lt;/param&gt;
        /// &lt;returns&gt;true if the entry was removed; otherwise false.&lt;/returns&gt;
        public bool TryRemove(TKey key)
        {
            return _dictionary.TryRemove(key, out _);
        }

        /// &lt;summary&gt;
        /// Determines whether the dictionary contains an entry for a key.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;key&quot;&gt;The key identifying the entry.&lt;/param&gt;
        /// &lt;returns&gt;true if the dictionary contains an entry for the specified key; otherwise false.&lt;/returns&gt;
        public async ValueTask&lt;bool&gt; ContainsKeyAsync(TKey key)
        {
            if (!_dictionary.TryGetValue(key, out var entry)) return false;

            // a null value is not a value
            // return the attempt at getting the entry value
            return await TryGetEntryValueAsync(entry).CfAwait();
        }

        /// &lt;summary&gt;
        /// Clears the dictionary.
        /// &lt;/summary&gt;
        public void Clear()
        {
            _dictionary.Clear();
        }

        /// &lt;summary&gt;
        /// Gets the number of entries contained in the dictionary.
        /// &lt;/summary&gt;
        /// &lt;remarks&gt;
        /// &lt;para&gt;This is the total number of entries, including entries which do not yet have
        /// a value, and may eventually be removed if their factory throws or return a null value.&lt;/para&gt;
        /// &lt;/remarks&gt;
        public int Count =&gt; _dictionary.Count;

        /// &lt;inheritdoc /&gt;
        public IAsyncEnumerator&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; GetAsyncEnumerator(CancellationToken cancellationToken = default)
            =&gt; new AsyncEnumerator(_dictionary.GetEnumerator(), cancellationToken);

        private class AsyncEnumerator : IAsyncEnumerator&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;
        {
            private readonly IEnumerator&lt;KeyValuePair&lt;TKey, Entry&gt;&gt; _enumerator;
            private readonly CancellationToken _cancellationToken;
            private KeyValuePair&lt;TKey, TValue&gt; _current;

            public AsyncEnumerator(IEnumerator&lt;KeyValuePair&lt;TKey, Entry&gt;&gt; enumerator, CancellationToken cancellationToken)
            {
                _enumerator = enumerator ?? throw new ArgumentNullException(nameof(enumerator));
                _cancellationToken = cancellationToken;
            }

            public ValueTask DisposeAsync()
            {
                _enumerator.Dispose();
                return default;
            }

            public async ValueTask&lt;bool&gt; MoveNextAsync()
            {
                while (_enumerator.MoveNext() &amp;&amp; !_cancellationToken.IsCancellationRequested)
                {
                    var key = _enumerator.Current.Key;
                    var entry = _enumerator.Current.Value;

                    try
                    {
                        var value = entry.HasValue ? entry.Value : await entry.GetValue().CfAwait();
                        if (value == null) continue; // skip null values
                        _current = new KeyValuePair&lt;TKey, TValue&gt;(key, value);
                        return true;
                    }
                    catch
                    {
                        // ignore bogus entries
                    }
                }

                return false;
            }

            public KeyValuePair&lt;TKey, TValue&gt; Current
            {
                get
                {
                    _ = _enumerator.Current; // throw if it must throw
                    return _current;
                }
            }
        }

        /// &lt;summary&gt;
        /// (internal for tests only)
        /// Represents a dictionary entry.
        /// &lt;/summary&gt;
        internal class Entry
        {
            private readonly object _lock = new object();
            private readonly TKey _key;
            private TValue _value;
            private Task&lt;TValue&gt; _creating;

            public Entry(TKey key)
            {
                _key = key;
            }

            /// &lt;summary&gt;
            /// (internal for tests only)
            /// Initializes a new instance of the &lt;see cref=&quot;Entry&quot;/&gt; class.
            /// &lt;/summary&gt;
            internal Entry(TKey key, bool hasValue, TValue value = default, Task&lt;TValue&gt; creating = default)
            {
                _key = key;
                HasValue = hasValue;
                _value = value;
                _creating = creating;
            }

            public bool HasValue { get; private set; }

            public TValue Value
            {
                get
                {
                    if (!HasValue) throw new InvalidOperationException(&quot;Entry does not have a value.&quot;);
                    return _value;
                }
            }

            public async Task&lt;TValue&gt; GetValue(Func&lt;TKey, CancellationToken, ValueTask&lt;TValue&gt;&gt; factory, CancellationToken cancellationToken = default)
            {
                // there is only one factory, each method is not supposed to try another factory

                Task&lt;TValue&gt; creating;
                lock (_lock)
                {
                    if (HasValue) return _value;
                    creating = _creating ??= factory(_key, cancellationToken).AsTask();
                }

                _value = await creating.CfAwait();

                lock (_lock)
                {
                    HasValue = true;
                    _creating = null;
                }

                return _value;
            }

            public async Task&lt;TValue&gt; GetValue()
            {
                Task&lt;TValue&gt; creating;
                lock (_lock)
                {
                    if (HasValue) return _value;
                    creating = _creating;
                }

                return await creating.CfAwait();
            }
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[34,9,34,114,1],[42,13,42,51,1],[54,13,54,70,1],[54,56,54,68,1],[61,13,61,32,1],[61,33,61,52,1],[66,17,66,88,1],[67,17,67,35,1],[67,36,67,49,1],[70,17,70,51,1],[71,17,71,29,1],[73,13,73,18,1],[76,17,76,51,1],[77,17,77,23,1],[79,9,79,10,1],[90,13,90,40,1],[91,13,91,49,1],[91,50,91,63,1],[100,17,100,88,1],[101,17,101,35,1],[101,36,101,48,1],[104,17,104,51,1],[105,17,105,30,1],[107,13,107,18,1],[110,17,110,51,1],[111,17,111,23,1],[113,9,113,10,1],[122,13,122,62,1],[122,63,122,85,1],[125,13,125,65,1],[126,9,126,10,1],[135,13,135,60,1],[135,61,135,83,1],[138,13,138,65,1],[139,9,139,10,1],[146,13,146,32,1],[148,17,148,41,1],[148,42,148,61,1],[149,17,149,39,1],[154,17,154,62,1],[155,17,155,35,1],[155,36,155,49,1],[156,13,156,14,1],[157,13,157,18,1],[160,13,160,14,1],[162,13,162,35,1],[163,9,163,10,1],[172,13,172,54,1],[182,13,182,62,1],[182,63,182,76,1],[186,13,186,65,1],[187,9,187,10,1],[194,13,194,33,1],[195,9,195,10,1],[204,29,204,46,1],[208,16,208,83,1],[216,13,216,123,1],[218,17,218,97,1],[219,17,219,56,1],[220,13,220,14,1],[224,17,224,39,1],[225,17,225,32,1],[230,17,230,94,1],[232,21,232,55,1],[233,21,233,59,1],[237,25,237,101,1],[238,25,238,43,1],[238,44,238,53,1],[239,25,239,79,1],[240,25,240,37,1],[242,21,242,26,1],[245,21,245,22,1],[246,17,246,18,1],[248,17,248,30,1],[249,13,249,14,1],[255,21,255,45,1],[256,21,256,37,1],[267,13,267,58,1],[267,13,267,58,1],[272,13,272,35,1],[274,17,274,28,1],[275,13,275,14,1],[281,13,281,109,1],[283,17,283,28,1],[284,17,284,37,1],[285,17,285,32,1],[286,17,286,38,1],[287,13,287,14,1],[289,36,289,40,1],[289,41,289,53,1],[295,21,295,35,1],[295,36,295,104,1],[296,21,296,35,1],[305,17,305,29,1],[307,21,307,34,1],[307,35,307,49,1],[308,21,308,88,1],[309,17,309,18,1],[311,17,311,51,1],[313,17,313,29,1],[315,21,315,37,1],[316,21,316,38,1],[317,17,317,18,1],[319,17,319,31,1],[320,13,320,14,1],[325,17,325,29,1],[327,21,327,34,1],[327,35,327,49,1],[328,21,328,42,1],[329,17,329,18,1],[331,17,331,49,1],[332,13,332,14,1]]);
    </script>
  </body>
</html>